(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(factory.toString()).default;
	else if(typeof exports === 'object')
		exports["Quagga"] = factory(factory.toString()).default;
	else
		root["Quagga"] = factory(factory.toString()).default;
})(this, function(__factorySource__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 167);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_array_helper__ = __webpack_require__(3);


function BarcodeReader(config, supplements) {
    this._row = [];
    this.config = config || {};
    this.supplements = supplements;
    return this;
}

BarcodeReader.prototype._nextUnset = function (line, start) {
    var i;

    if (start === undefined) {
        start = 0;
    }
    for (i = start; i < line.length; i++) {
        if (!line[i]) {
            return i;
        }
    }
    return line.length;
};

BarcodeReader.prototype._matchPattern = function (counter, code, maxSingleError) {
    var i,
        error = 0,
        singleError = 0,
        sum = 0,
        modulo = 0,
        barWidth,
        count,
        scaled;

    maxSingleError = maxSingleError || this.SINGLE_CODE_ERROR || 1;

    for (i = 0; i < counter.length; i++) {
        sum += counter[i];
        modulo += code[i];
    }
    if (sum < modulo) {
        return Number.MAX_VALUE;
    }
    barWidth = sum / modulo;
    maxSingleError *= barWidth;

    for (i = 0; i < counter.length; i++) {
        count = counter[i];
        scaled = code[i] * barWidth;
        singleError = Math.abs(count - scaled) / scaled;
        if (singleError > maxSingleError) {
            return Number.MAX_VALUE;
        }
        error += singleError;
    }
    return error / modulo;
};

BarcodeReader.prototype._nextSet = function (line, offset) {
    var i;

    offset = offset || 0;
    for (i = offset; i < line.length; i++) {
        if (line[i]) {
            return i;
        }
    }
    return line.length;
};

BarcodeReader.prototype._correctBars = function (counter, correction, indices) {
    var length = indices.length,
        tmp = 0;
    while (length--) {
        tmp = counter[indices[length]] * (1 - (1 - correction) / 2);
        if (tmp > 1) {
            counter[indices[length]] = tmp;
        }
    }
};

BarcodeReader.prototype._matchTrace = function (cmpCounter, epsilon) {
    var counter = [],
        i,
        self = this,
        offset = self._nextSet(self._row),
        isWhite = !self._row[offset],
        counterPos = 0,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0
    },
        error;

    if (cmpCounter) {
        for (i = 0; i < cmpCounter.length; i++) {
            counter.push(0);
        }
        for (i = offset; i < self._row.length; i++) {
            if (self._row[i] ^ isWhite) {
                counter[counterPos]++;
            } else {
                if (counterPos === counter.length - 1) {
                    error = self._matchPattern(counter, cmpCounter);

                    if (error < epsilon) {
                        bestMatch.start = i - offset;
                        bestMatch.end = i;
                        bestMatch.counter = counter;
                        return bestMatch;
                    } else {
                        return null;
                    }
                } else {
                    counterPos++;
                }
                counter[counterPos] = 1;
                isWhite = !isWhite;
            }
        }
    } else {
        counter.push(0);
        for (i = offset; i < self._row.length; i++) {
            if (self._row[i] ^ isWhite) {
                counter[counterPos]++;
            } else {
                counterPos++;
                counter.push(0);
                counter[counterPos] = 1;
                isWhite = !isWhite;
            }
        }
    }

    // if cmpCounter was not given
    bestMatch.start = offset;
    bestMatch.end = self._row.length - 1;
    bestMatch.counter = counter;
    return bestMatch;
};

BarcodeReader.prototype.decodePattern = function (pattern) {
    var self = this,
        result;

    self._row = pattern;
    result = self._decode();
    if (result === null) {
        self._row.reverse();
        result = self._decode();
        if (result) {
            result.direction = BarcodeReader.DIRECTION.REVERSE;
            result.start = self._row.length - result.start;
            result.end = self._row.length - result.end;
        }
    } else {
        result.direction = BarcodeReader.DIRECTION.FORWARD;
    }
    if (result) {
        result.format = self.FORMAT;
    }
    return result;
};

BarcodeReader.prototype._matchRange = function (start, end, value) {
    var i;

    start = start < 0 ? 0 : start;
    for (i = start; i < end; i++) {
        if (this._row[i] !== value) {
            return false;
        }
    }
    return true;
};

BarcodeReader.prototype._fillCounters = function (offset, end, isWhite) {
    var self = this,
        counterPos = 0,
        i,
        counters = [];

    isWhite = typeof isWhite !== 'undefined' ? isWhite : true;
    offset = typeof offset !== 'undefined' ? offset : self._nextUnset(self._row);
    end = end || self._row.length;

    counters[counterPos] = 0;
    for (i = offset; i < end; i++) {
        if (self._row[i] ^ isWhite) {
            counters[counterPos]++;
        } else {
            counterPos++;
            counters[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return counters;
};

BarcodeReader.prototype._toCounters = function (start, counter) {
    var self = this,
        numCounters = counter.length,
        end = self._row.length,
        isWhite = !self._row[start],
        i,
        counterPos = 0;

    __WEBPACK_IMPORTED_MODULE_0__common_array_helper__["a" /* default */].init(counter, 0);

    for (i = start; i < end; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            counterPos++;
            if (counterPos === numCounters) {
                break;
            } else {
                counter[counterPos] = 1;
                isWhite = !isWhite;
            }
        }
    }

    return counter;
};

Object.defineProperty(BarcodeReader.prototype, "FORMAT", {
    value: 'unknown',
    writeable: false
});

BarcodeReader.DIRECTION = {
    FORWARD: 1,
    REVERSE: -1
};

BarcodeReader.Exception = {
    StartNotFoundException: "Start-Info was not found!",
    CodeNotFoundException: "Code could not be found!",
    PatternNotFoundException: "Pattern could not be found!"
};

BarcodeReader.CONFIG_KEYS = {};

/* harmony default export */ __webpack_exports__["a"] = (BarcodeReader);

/***/ }),
/* 2 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
    init: function init(arr, val) {
        var l = arr.length;
        while (l--) {
            arr[l] = val;
        }
    },

    /**
     * Shuffles the content of an array
     * @return {Array} the array itself shuffled
     */
    shuffle: function shuffle(arr) {
        var i = arr.length - 1,
            j,
            x;
        for (i; i >= 0; i--) {
            j = Math.floor(Math.random() * i);
            x = arr[i];
            arr[i] = arr[j];
            arr[j] = x;
        }
        return arr;
    },

    toPointList: function toPointList(arr) {
        var i,
            j,
            row = [],
            rows = [];
        for (i = 0; i < arr.length; i++) {
            row = [];
            for (j = 0; j < arr[i].length; j++) {
                row[j] = arr[i][j];
            }
            rows[i] = "[" + row.join(",") + "]";
        }
        return "[" + rows.join(",\r\n") + "]";
    },

    /**
     * returns the elements which's score is bigger than the threshold
     * @return {Array} the reduced array
     */
    threshold: function threshold(arr, _threshold, scoreFunc) {
        var i,
            queue = [];
        for (i = 0; i < arr.length; i++) {
            if (scoreFunc.apply(arr, [arr[i]]) >= _threshold) {
                queue.push(arr[i]);
            }
        }
        return queue;
    },

    maxIndex: function maxIndex(arr) {
        var i,
            max = 0;
        for (i = 0; i < arr.length; i++) {
            if (arr[i] > arr[max]) {
                max = i;
            }
        }
        return max;
    },

    max: function max(arr) {
        var i,
            max = 0;
        for (i = 0; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        return max;
    },

    sum: function sum(arr) {
        var length = arr.length,
            sum = 0;

        while (length--) {
            sum += arr[length];
        }
        return sum;
    }
});

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_merge__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_merge___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash_merge__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__barcode_reader__ = __webpack_require__(1);


var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };




function EANReader(opts, supplements) {
    opts = __WEBPACK_IMPORTED_MODULE_0_lodash_merge___default()(getDefaulConfig(), opts);
    __WEBPACK_IMPORTED_MODULE_1__barcode_reader__["a" /* default */].call(this, opts, supplements);
}

function getDefaulConfig() {
    var config = {};

    Object.keys(EANReader.CONFIG_KEYS).forEach(function (key) {
        config[key] = EANReader.CONFIG_KEYS[key].default;
    });
    return config;
}

var properties = {
    CODE_L_START: { value: 0 },
    CODE_G_START: { value: 10 },
    START_PATTERN: { value: [1, 1, 1] },
    STOP_PATTERN: { value: [1, 1, 1] },
    MIDDLE_PATTERN: { value: [1, 1, 1, 1, 1] },
    EXTENSION_START_PATTERN: { value: [1, 1, 2] },
    CODE_PATTERN: { value: [[3, 2, 1, 1], [2, 2, 2, 1], [2, 1, 2, 2], [1, 4, 1, 1], [1, 1, 3, 2], [1, 2, 3, 1], [1, 1, 1, 4], [1, 3, 1, 2], [1, 2, 1, 3], [3, 1, 1, 2], [1, 1, 2, 3], [1, 2, 2, 2], [2, 2, 1, 2], [1, 1, 4, 1], [2, 3, 1, 1], [1, 3, 2, 1], [4, 1, 1, 1], [2, 1, 3, 1], [3, 1, 2, 1], [2, 1, 1, 3]] },
    CODE_FREQUENCY: { value: [0, 11, 13, 14, 19, 25, 28, 21, 22, 26] },
    SINGLE_CODE_ERROR: { value: 0.70 },
    AVG_CODE_ERROR: { value: 0.48 },
    FORMAT: { value: "ean_13", writeable: false }
};

EANReader.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_1__barcode_reader__["a" /* default */].prototype, properties);
EANReader.prototype.constructor = EANReader;

EANReader.prototype._decodeCode = function (start, coderange) {
    var counter = [0, 0, 0, 0],
        i,
        self = this,
        offset = start,
        isWhite = !self._row[offset],
        counterPos = 0,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: start,
        end: start
    },
        code,
        error;

    if (!coderange) {
        coderange = self.CODE_PATTERN.length;
    }

    for (i = offset; i < self._row.length; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            if (counterPos === counter.length - 1) {
                for (code = 0; code < coderange; code++) {
                    error = self._matchPattern(counter, self.CODE_PATTERN[code]);
                    if (error < bestMatch.error) {
                        bestMatch.code = code;
                        bestMatch.error = error;
                    }
                }
                bestMatch.end = i;
                if (bestMatch.error > self.AVG_CODE_ERROR) {
                    return null;
                }
                return bestMatch;
            } else {
                counterPos++;
            }
            counter[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return null;
};

EANReader.prototype._findPattern = function (pattern, offset, isWhite, tryHarder, epsilon) {
    var counter = [],
        self = this,
        i,
        counterPos = 0,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
    },
        error,
        j,
        sum;

    if (!offset) {
        offset = self._nextSet(self._row);
    }

    if (isWhite === undefined) {
        isWhite = false;
    }

    if (tryHarder === undefined) {
        tryHarder = true;
    }

    if (epsilon === undefined) {
        epsilon = self.AVG_CODE_ERROR;
    }

    for (i = 0; i < pattern.length; i++) {
        counter[i] = 0;
    }

    for (i = offset; i < self._row.length; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            if (counterPos === counter.length - 1) {
                sum = 0;
                for (j = 0; j < counter.length; j++) {
                    sum += counter[j];
                }
                error = self._matchPattern(counter, pattern);

                if (error < epsilon) {
                    bestMatch.error = error;
                    bestMatch.start = i - sum;
                    bestMatch.end = i;
                    return bestMatch;
                }
                if (tryHarder) {
                    for (j = 0; j < counter.length - 2; j++) {
                        counter[j] = counter[j + 2];
                    }
                    counter[counter.length - 2] = 0;
                    counter[counter.length - 1] = 0;
                    counterPos--;
                } else {
                    return null;
                }
            } else {
                counterPos++;
            }
            counter[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return null;
};

EANReader.prototype._findStart = function () {
    var self = this,
        leadingWhitespaceStart,
        offset = self._nextSet(self._row),
        startInfo;

    while (!startInfo) {
        startInfo = self._findPattern(self.START_PATTERN, offset);
        if (!startInfo) {
            return null;
        }
        leadingWhitespaceStart = startInfo.start - (startInfo.end - startInfo.start);
        if (leadingWhitespaceStart >= 0) {
            if (self._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
                return startInfo;
            }
        }
        offset = startInfo.end;
        startInfo = null;
    }
};

EANReader.prototype._verifyTrailingWhitespace = function (endInfo) {
    var self = this,
        trailingWhitespaceEnd;

    trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start);
    if (trailingWhitespaceEnd < self._row.length) {
        if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
            return endInfo;
        }
    }
    return null;
};

EANReader.prototype._findEnd = function (offset, isWhite) {
    var self = this,
        endInfo = self._findPattern(self.STOP_PATTERN, offset, isWhite, false);

    return endInfo !== null ? self._verifyTrailingWhitespace(endInfo) : null;
};

EANReader.prototype._calculateFirstDigit = function (codeFrequency) {
    var i,
        self = this;

    for (i = 0; i < self.CODE_FREQUENCY.length; i++) {
        if (codeFrequency === self.CODE_FREQUENCY[i]) {
            return i;
        }
    }
    return null;
};

EANReader.prototype._decodePayload = function (code, result, decodedCodes) {
    var i,
        self = this,
        codeFrequency = 0x0,
        firstDigit;

    for (i = 0; i < 6; i++) {
        code = self._decodeCode(code.end);
        if (!code) {
            return null;
        }
        if (code.code >= self.CODE_G_START) {
            code.code = code.code - self.CODE_G_START;
            codeFrequency |= 1 << 5 - i;
        } else {
            codeFrequency |= 0 << 5 - i;
        }
        result.push(code.code);
        decodedCodes.push(code);
    }

    firstDigit = self._calculateFirstDigit(codeFrequency);
    if (firstDigit === null) {
        return null;
    }
    result.unshift(firstDigit);

    code = self._findPattern(self.MIDDLE_PATTERN, code.end, true, false);
    if (code === null) {
        return null;
    }
    decodedCodes.push(code);

    for (i = 0; i < 6; i++) {
        code = self._decodeCode(code.end, self.CODE_G_START);
        if (!code) {
            return null;
        }
        decodedCodes.push(code);
        result.push(code.code);
    }

    return code;
};

EANReader.prototype._decode = function () {
    var startInfo,
        self = this,
        code,
        result = [],
        decodedCodes = [],
        resultInfo = {};

    startInfo = self._findStart();
    if (!startInfo) {
        return null;
    }
    code = {
        code: startInfo.code,
        start: startInfo.start,
        end: startInfo.end
    };
    decodedCodes.push(code);
    code = self._decodePayload(code, result, decodedCodes);
    if (!code) {
        return null;
    }
    code = self._findEnd(code.end, false);
    if (!code) {
        return null;
    }

    decodedCodes.push(code);

    // Checksum
    if (!self._checksum(result)) {
        return null;
    }

    if (this.supplements.length > 0) {
        var ext = this._decodeExtensions(code.end);
        if (!ext) {
            return null;
        }
        var lastCode = ext.decodedCodes[ext.decodedCodes.length - 1],
            endInfo = {
            start: lastCode.start + ((lastCode.end - lastCode.start) / 2 | 0),
            end: lastCode.end
        };
        if (!self._verifyTrailingWhitespace(endInfo)) {
            return null;
        }
        resultInfo = {
            supplement: ext,
            code: result.join("") + ext.code
        };
    }

    return _extends({
        code: result.join(""),
        start: startInfo.start,
        end: code.end,
        codeset: "",
        startInfo: startInfo,
        decodedCodes: decodedCodes
    }, resultInfo);
};

EANReader.prototype._decodeExtensions = function (offset) {
    var i,
        start = this._nextSet(this._row, offset),
        startInfo = this._findPattern(this.EXTENSION_START_PATTERN, start, false, false),
        result;

    if (startInfo === null) {
        return null;
    }

    for (i = 0; i < this.supplements.length; i++) {
        result = this.supplements[i].decode(this._row, startInfo.end);
        if (result !== null) {
            return {
                code: result.code,
                start: start,
                startInfo: startInfo,
                end: result.end,
                codeset: "",
                decodedCodes: result.decodedCodes
            };
        }
    }
    return null;
};

EANReader.prototype._checksum = function (result) {
    var sum = 0,
        i;

    for (i = result.length - 2; i >= 0; i -= 2) {
        sum += result[i];
    }
    sum *= 3;
    for (i = result.length - 1; i >= 0; i -= 2) {
        sum += result[i];
    }
    return sum % 10 === 0;
};

EANReader.CONFIG_KEYS = {
    supplements: {
        'type': 'arrayOf(string)',
        'default': [],
        'description': 'Allowed extensions to be decoded (2 and/or 5)'
    }
};

/* harmony default export */ __webpack_exports__["a"] = (EANReader);

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(38);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),
/* 6 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = clone

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
function clone(a) {
    var out = new Float32Array(2)
    out[0] = a[0]
    out[1] = a[1]
    return out
}

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(11),
    getRawTag = __webpack_require__(120),
    objectToString = __webpack_require__(147);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
    drawRect: function drawRect(pos, size, ctx, style) {
        ctx.strokeStyle = style.color;
        ctx.fillStyle = style.color;
        ctx.lineWidth = style.lineWidth || 1;
        ctx.beginPath();
        ctx.strokeRect(pos.x, pos.y, size.x, size.y);
    },
    drawPath: function drawPath(path, def, ctx, style) {
        ctx.strokeStyle = style.color;
        ctx.fillStyle = style.color;
        ctx.lineWidth = style.lineWidth;
        ctx.beginPath();
        ctx.moveTo(path[0][def.x], path[0][def.y]);
        for (var j = 1; j < path.length; j++) {
            ctx.lineTo(path[j][def.x], path[j][def.y]);
        }
        ctx.closePath();
        ctx.stroke();
    },
    drawImage: function drawImage(imageData, size, ctx) {
        var canvasData = ctx.getImageData(0, 0, size.x, size.y),
            data = canvasData.data,
            imageDataPos = imageData.length,
            canvasDataPos = data.length,
            value;

        if (canvasDataPos / imageDataPos !== 4) {
            return false;
        }
        while (imageDataPos--) {
            value = imageData[imageDataPos];
            data[--canvasDataPos] = 255;
            data[--canvasDataPos] = value;
            data[--canvasDataPos] = value;
            data[--canvasDataPos] = value;
        }
        ctx.putImageData(canvasData, 0, 0);
        return true;
    }
});

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(134),
    listCacheDelete = __webpack_require__(135),
    listCacheGet = __webpack_require__(136),
    listCacheHas = __webpack_require__(137),
    listCacheSet = __webpack_require__(138);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(5);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(17);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(2),
    isKey = __webpack_require__(131),
    stringToPath = __webpack_require__(155),
    toString = __webpack_require__(166);

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(132);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),
/* 15 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(22);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),
/* 17 */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(97),
    isObjectLike = __webpack_require__(6);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = imageRef;
/* unused harmony export computeIntegralImage2 */
/* unused harmony export computeIntegralImage */
/* unused harmony export thresholdImage */
/* unused harmony export computeHistogram */
/* unused harmony export sharpenLine */
/* unused harmony export determineOtsuThreshold */
/* harmony export (immutable) */ __webpack_exports__["f"] = otsuThreshold;
/* unused harmony export computeBinaryImage */
/* harmony export (immutable) */ __webpack_exports__["g"] = cluster;
/* unused harmony export Tracer */
/* unused harmony export DILATE */
/* unused harmony export ERODE */
/* unused harmony export dilate */
/* unused harmony export erode */
/* unused harmony export subtract */
/* unused harmony export bitwiseOr */
/* unused harmony export countNonZero */
/* harmony export (immutable) */ __webpack_exports__["h"] = topGeneric;
/* unused harmony export grayArrayFromImage */
/* unused harmony export grayArrayFromContext */
/* harmony export (immutable) */ __webpack_exports__["c"] = grayAndHalfSampleFromCanvasData;
/* harmony export (immutable) */ __webpack_exports__["d"] = computeGray;
/* unused harmony export loadImageArray */
/* harmony export (immutable) */ __webpack_exports__["i"] = halfSample;
/* harmony export (immutable) */ __webpack_exports__["a"] = hsv2rgb;
/* unused harmony export _computeDivisors */
/* harmony export (immutable) */ __webpack_exports__["e"] = calculatePatchSize;
/* unused harmony export _parseCSSDimensionValues */
/* unused harmony export _dimensionsConverters */
/* harmony export (immutable) */ __webpack_exports__["j"] = computeImageArea;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__cluster__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__array_helper__ = __webpack_require__(3);


var vec2 = {
    clone: __webpack_require__(7)
};
var vec3 = {
    clone: __webpack_require__(84)
};

/**
 * @param x x-coordinate
 * @param y y-coordinate
 * @return ImageReference {x,y} Coordinate
 */
function imageRef(x, y) {
    var that = {
        x: x,
        y: y,
        toVec2: function toVec2() {
            return vec2.clone([this.x, this.y]);
        },
        toVec3: function toVec3() {
            return vec3.clone([this.x, this.y, 1]);
        },
        round: function round() {
            this.x = this.x > 0.0 ? Math.floor(this.x + 0.5) : Math.floor(this.x - 0.5);
            this.y = this.y > 0.0 ? Math.floor(this.y + 0.5) : Math.floor(this.y - 0.5);
            return this;
        }
    };
    return that;
};

/**
 * Computes an integral image of a given grayscale image.
 * @param imageDataContainer {ImageDataContainer} the image to be integrated
 */
function computeIntegralImage2(imageWrapper, integralWrapper) {
    var imageData = imageWrapper.data;
    var width = imageWrapper.size.x;
    var height = imageWrapper.size.y;
    var integralImageData = integralWrapper.data;
    var sum = 0,
        posA = 0,
        posB = 0,
        posC = 0,
        posD = 0,
        x,
        y;

    // sum up first column
    posB = width;
    sum = 0;
    for (y = 1; y < height; y++) {
        sum += imageData[posA];
        integralImageData[posB] += sum;
        posA += width;
        posB += width;
    }

    posA = 0;
    posB = 1;
    sum = 0;
    for (x = 1; x < width; x++) {
        sum += imageData[posA];
        integralImageData[posB] += sum;
        posA++;
        posB++;
    }

    for (y = 1; y < height; y++) {
        posA = y * width + 1;
        posB = (y - 1) * width + 1;
        posC = y * width;
        posD = (y - 1) * width;
        for (x = 1; x < width; x++) {
            integralImageData[posA] += imageData[posA] + integralImageData[posB] + integralImageData[posC] - integralImageData[posD];
            posA++;
            posB++;
            posC++;
            posD++;
        }
    }
};

function computeIntegralImage(imageWrapper, integralWrapper) {
    var imageData = imageWrapper.data;
    var width = imageWrapper.size.x;
    var height = imageWrapper.size.y;
    var integralImageData = integralWrapper.data;
    var sum = 0;

    // sum up first row
    for (var i = 0; i < width; i++) {
        sum += imageData[i];
        integralImageData[i] = sum;
    }

    for (var v = 1; v < height; v++) {
        sum = 0;
        for (var u = 0; u < width; u++) {
            sum += imageData[v * width + u];
            integralImageData[v * width + u] = sum + integralImageData[(v - 1) * width + u];
        }
    }
};

function thresholdImage(imageWrapper, threshold, targetWrapper) {
    if (!targetWrapper) {
        targetWrapper = imageWrapper;
    }
    var imageData = imageWrapper.data,
        length = imageData.length,
        targetData = targetWrapper.data;

    while (length--) {
        targetData[length] = imageData[length] < threshold ? 1 : 0;
    }
};

function computeHistogram(imageWrapper, bitsPerPixel) {
    if (!bitsPerPixel) {
        bitsPerPixel = 8;
    }
    var imageData = imageWrapper.data,
        length = imageData.length,
        bitShift = 8 - bitsPerPixel,
        bucketCnt = 1 << bitsPerPixel,
        hist = new Int32Array(bucketCnt);

    while (length--) {
        hist[imageData[length] >> bitShift]++;
    }
    return hist;
};

function sharpenLine(line) {
    var i,
        length = line.length,
        left = line[0],
        center = line[1],
        right;

    for (i = 1; i < length - 1; i++) {
        right = line[i + 1];
        //  -1 4 -1 kernel
        line[i - 1] = center * 2 - left - right & 255;
        left = center;
        center = right;
    }
    return line;
};

function determineOtsuThreshold(imageWrapper, bitsPerPixel) {
    if (!bitsPerPixel) {
        bitsPerPixel = 8;
    }
    var hist,
        threshold,
        bitShift = 8 - bitsPerPixel;

    function px(init, end) {
        var sum = 0,
            i;
        for (i = init; i <= end; i++) {
            sum += hist[i];
        }
        return sum;
    }

    function mx(init, end) {
        var i,
            sum = 0;

        for (i = init; i <= end; i++) {
            sum += i * hist[i];
        }

        return sum;
    }

    function determineThreshold() {
        var vet = [0],
            p1,
            p2,
            p12,
            k,
            m1,
            m2,
            m12,
            max = (1 << bitsPerPixel) - 1;

        hist = computeHistogram(imageWrapper, bitsPerPixel);
        for (k = 1; k < max; k++) {
            p1 = px(0, k);
            p2 = px(k + 1, max);
            p12 = p1 * p2;
            if (p12 === 0) {
                p12 = 1;
            }
            m1 = mx(0, k) * p2;
            m2 = mx(k + 1, max) * p1;
            m12 = m1 - m2;
            vet[k] = m12 * m12 / p12;
        }
        return __WEBPACK_IMPORTED_MODULE_1__array_helper__["a" /* default */].maxIndex(vet);
    }

    threshold = determineThreshold();
    return threshold << bitShift;
};

function otsuThreshold(imageWrapper, targetWrapper) {
    var threshold = determineOtsuThreshold(imageWrapper);

    thresholdImage(imageWrapper, threshold, targetWrapper);
    return threshold;
};

// local thresholding
function computeBinaryImage(imageWrapper, integralWrapper, targetWrapper) {
    computeIntegralImage(imageWrapper, integralWrapper);

    if (!targetWrapper) {
        targetWrapper = imageWrapper;
    }
    var imageData = imageWrapper.data;
    var targetData = targetWrapper.data;
    var width = imageWrapper.size.x;
    var height = imageWrapper.size.y;
    var integralImageData = integralWrapper.data;
    var sum = 0,
        v,
        u,
        kernel = 3,
        A,
        B,
        C,
        D,
        avg,
        size = (kernel * 2 + 1) * (kernel * 2 + 1);

    // clear out top & bottom-border
    for (v = 0; v <= kernel; v++) {
        for (u = 0; u < width; u++) {
            targetData[v * width + u] = 0;
            targetData[(height - 1 - v) * width + u] = 0;
        }
    }

    // clear out left & right border
    for (v = kernel; v < height - kernel; v++) {
        for (u = 0; u <= kernel; u++) {
            targetData[v * width + u] = 0;
            targetData[v * width + (width - 1 - u)] = 0;
        }
    }

    for (v = kernel + 1; v < height - kernel - 1; v++) {
        for (u = kernel + 1; u < width - kernel; u++) {
            A = integralImageData[(v - kernel - 1) * width + (u - kernel - 1)];
            B = integralImageData[(v - kernel - 1) * width + (u + kernel)];
            C = integralImageData[(v + kernel) * width + (u - kernel - 1)];
            D = integralImageData[(v + kernel) * width + (u + kernel)];
            sum = D - C - B + A;
            avg = sum / size;
            targetData[v * width + u] = imageData[v * width + u] > avg + 5 ? 0 : 1;
        }
    }
};

function cluster(points, threshold, property) {
    var i,
        k,
        cluster,
        point,
        clusters = [];

    if (!property) {
        property = "rad";
    }

    function addToCluster(newPoint) {
        var found = false;
        for (k = 0; k < clusters.length; k++) {
            cluster = clusters[k];
            if (cluster.fits(newPoint)) {
                cluster.add(newPoint);
                found = true;
            }
        }
        return found;
    }

    // iterate over each cloud
    for (i = 0; i < points.length; i++) {
        point = __WEBPACK_IMPORTED_MODULE_0__cluster__["a" /* default */].createPoint(points[i], i, property);
        if (!addToCluster(point)) {
            clusters.push(__WEBPACK_IMPORTED_MODULE_0__cluster__["a" /* default */].create(point, threshold));
        }
    }
    return clusters;
};

var Tracer = {
    trace: function trace(points, vec) {
        var iteration,
            maxIterations = 10,
            top = [],
            result = [],
            centerPos = 0,
            currentPos = 0;

        function trace(idx, forward) {
            var from,
                to,
                toIdx,
                predictedPos,
                thresholdX = 1,
                thresholdY = Math.abs(vec[1] / 10),
                found = false;

            function match(pos, predicted) {
                if (pos.x > predicted.x - thresholdX && pos.x < predicted.x + thresholdX && pos.y > predicted.y - thresholdY && pos.y < predicted.y + thresholdY) {
                    return true;
                } else {
                    return false;
                }
            }

            // check if the next index is within the vec specifications
            // if not, check as long as the threshold is met

            from = points[idx];
            if (forward) {
                predictedPos = {
                    x: from.x + vec[0],
                    y: from.y + vec[1]
                };
            } else {
                predictedPos = {
                    x: from.x - vec[0],
                    y: from.y - vec[1]
                };
            }

            toIdx = forward ? idx + 1 : idx - 1;
            to = points[toIdx];
            while (to && (found = match(to, predictedPos)) !== true && Math.abs(to.y - from.y) < vec[1]) {
                toIdx = forward ? toIdx + 1 : toIdx - 1;
                to = points[toIdx];
            }

            return found ? toIdx : null;
        }

        for (iteration = 0; iteration < maxIterations; iteration++) {
            // randomly select point to start with
            centerPos = Math.floor(Math.random() * points.length);

            // trace forward
            top = [];
            currentPos = centerPos;
            top.push(points[currentPos]);
            while ((currentPos = trace(currentPos, true)) !== null) {
                top.push(points[currentPos]);
            }
            if (centerPos > 0) {
                currentPos = centerPos;
                while ((currentPos = trace(currentPos, false)) !== null) {
                    top.push(points[currentPos]);
                }
            }

            if (top.length > result.length) {
                result = top;
            }
        }
        return result;
    }
};

var DILATE = 1;
var ERODE = 2;

function dilate(inImageWrapper, outImageWrapper) {
    var v,
        u,
        inImageData = inImageWrapper.data,
        outImageData = outImageWrapper.data,
        height = inImageWrapper.size.y,
        width = inImageWrapper.size.x,
        sum,
        yStart1,
        yStart2,
        xStart1,
        xStart2;

    for (v = 1; v < height - 1; v++) {
        for (u = 1; u < width - 1; u++) {
            yStart1 = v - 1;
            yStart2 = v + 1;
            xStart1 = u - 1;
            xStart2 = u + 1;
            sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
            outImageData[v * width + u] = sum > 0 ? 1 : 0;
        }
    }
};

function erode(inImageWrapper, outImageWrapper) {
    var v,
        u,
        inImageData = inImageWrapper.data,
        outImageData = outImageWrapper.data,
        height = inImageWrapper.size.y,
        width = inImageWrapper.size.x,
        sum,
        yStart1,
        yStart2,
        xStart1,
        xStart2;

    for (v = 1; v < height - 1; v++) {
        for (u = 1; u < width - 1; u++) {
            yStart1 = v - 1;
            yStart2 = v + 1;
            xStart1 = u - 1;
            xStart2 = u + 1;
            sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
            outImageData[v * width + u] = sum === 5 ? 1 : 0;
        }
    }
};

function subtract(aImageWrapper, bImageWrapper, resultImageWrapper) {
    if (!resultImageWrapper) {
        resultImageWrapper = aImageWrapper;
    }
    var length = aImageWrapper.data.length,
        aImageData = aImageWrapper.data,
        bImageData = bImageWrapper.data,
        cImageData = resultImageWrapper.data;

    while (length--) {
        cImageData[length] = aImageData[length] - bImageData[length];
    }
};

function bitwiseOr(aImageWrapper, bImageWrapper, resultImageWrapper) {
    if (!resultImageWrapper) {
        resultImageWrapper = aImageWrapper;
    }
    var length = aImageWrapper.data.length,
        aImageData = aImageWrapper.data,
        bImageData = bImageWrapper.data,
        cImageData = resultImageWrapper.data;

    while (length--) {
        cImageData[length] = aImageData[length] || bImageData[length];
    }
};

function countNonZero(imageWrapper) {
    var length = imageWrapper.data.length,
        data = imageWrapper.data,
        sum = 0;

    while (length--) {
        sum += data[length];
    }
    return sum;
};

function topGeneric(list, top, scoreFunc) {
    var i,
        minIdx = 0,
        min = 0,
        queue = [],
        score,
        hit,
        pos;

    for (i = 0; i < top; i++) {
        queue[i] = {
            score: 0,
            item: null
        };
    }

    for (i = 0; i < list.length; i++) {
        score = scoreFunc.apply(this, [list[i]]);
        if (score > min) {
            hit = queue[minIdx];
            hit.score = score;
            hit.item = list[i];
            min = Number.MAX_VALUE;
            for (pos = 0; pos < top; pos++) {
                if (queue[pos].score < min) {
                    min = queue[pos].score;
                    minIdx = pos;
                }
            }
        }
    }

    return queue;
};

function grayArrayFromImage(htmlImage, offsetX, ctx, array) {
    ctx.drawImage(htmlImage, offsetX, 0, htmlImage.width, htmlImage.height);
    var ctxData = ctx.getImageData(offsetX, 0, htmlImage.width, htmlImage.height).data;
    computeGray(ctxData, array);
};

function grayArrayFromContext(ctx, size, offset, array) {
    var ctxData = ctx.getImageData(offset.x, offset.y, size.x, size.y).data;
    computeGray(ctxData, array);
};

function grayAndHalfSampleFromCanvasData(canvasData, size, outArray) {
    var topRowIdx = 0;
    var bottomRowIdx = size.x;
    var endIdx = Math.floor(canvasData.length / 4);
    var outWidth = size.x / 2;
    var outImgIdx = 0;
    var inWidth = size.x;
    var i;

    while (bottomRowIdx < endIdx) {
        for (i = 0; i < outWidth; i++) {
            outArray[outImgIdx] = (0.299 * canvasData[topRowIdx * 4 + 0] + 0.587 * canvasData[topRowIdx * 4 + 1] + 0.114 * canvasData[topRowIdx * 4 + 2] + (0.299 * canvasData[(topRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(topRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(topRowIdx + 1) * 4 + 2]) + (0.299 * canvasData[bottomRowIdx * 4 + 0] + 0.587 * canvasData[bottomRowIdx * 4 + 1] + 0.114 * canvasData[bottomRowIdx * 4 + 2]) + (0.299 * canvasData[(bottomRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(bottomRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(bottomRowIdx + 1) * 4 + 2])) / 4;
            outImgIdx++;
            topRowIdx = topRowIdx + 2;
            bottomRowIdx = bottomRowIdx + 2;
        }
        topRowIdx = topRowIdx + inWidth;
        bottomRowIdx = bottomRowIdx + inWidth;
    }
};

function computeGray(imageData, outArray, config) {
    var l = imageData.length / 4 | 0,
        i,
        singleChannel = config && config.singleChannel === true;

    if (singleChannel) {
        for (i = 0; i < l; i++) {
            outArray[i] = imageData[i * 4 + 0];
        }
    } else {
        for (i = 0; i < l; i++) {
            outArray[i] = 0.299 * imageData[i * 4 + 0] + 0.587 * imageData[i * 4 + 1] + 0.114 * imageData[i * 4 + 2];
        }
    }
};

function loadImageArray(src, callback, canvas) {
    if (!canvas) {
        canvas = document.createElement('canvas');
    }
    var img = new Image();
    img.callback = callback;
    img.onload = function () {
        canvas.width = this.width;
        canvas.height = this.height;
        var ctx = canvas.getContext('2d');
        ctx.drawImage(this, 0, 0);
        var array = new Uint8Array(this.width * this.height);
        ctx.drawImage(this, 0, 0);
        var data = ctx.getImageData(0, 0, this.width, this.height).data;
        computeGray(data, array);
        this.callback(array, {
            x: this.width,
            y: this.height
        }, this);
    };
    img.src = src;
};

/**
 * @param inImg {ImageWrapper} input image to be sampled
 * @param outImg {ImageWrapper} to be stored in
 */
function halfSample(inImgWrapper, outImgWrapper) {
    var inImg = inImgWrapper.data;
    var inWidth = inImgWrapper.size.x;
    var outImg = outImgWrapper.data;
    var topRowIdx = 0;
    var bottomRowIdx = inWidth;
    var endIdx = inImg.length;
    var outWidth = inWidth / 2;
    var outImgIdx = 0;
    while (bottomRowIdx < endIdx) {
        for (var i = 0; i < outWidth; i++) {
            outImg[outImgIdx] = Math.floor((inImg[topRowIdx] + inImg[topRowIdx + 1] + inImg[bottomRowIdx] + inImg[bottomRowIdx + 1]) / 4);
            outImgIdx++;
            topRowIdx = topRowIdx + 2;
            bottomRowIdx = bottomRowIdx + 2;
        }
        topRowIdx = topRowIdx + inWidth;
        bottomRowIdx = bottomRowIdx + inWidth;
    }
};

function hsv2rgb(hsv, rgb) {
    var h = hsv[0],
        s = hsv[1],
        v = hsv[2],
        c = v * s,
        x = c * (1 - Math.abs(h / 60 % 2 - 1)),
        m = v - c,
        r = 0,
        g = 0,
        b = 0;

    rgb = rgb || [0, 0, 0];

    if (h < 60) {
        r = c;
        g = x;
    } else if (h < 120) {
        r = x;
        g = c;
    } else if (h < 180) {
        g = c;
        b = x;
    } else if (h < 240) {
        g = x;
        b = c;
    } else if (h < 300) {
        r = x;
        b = c;
    } else if (h < 360) {
        r = c;
        b = x;
    }
    rgb[0] = (r + m) * 255 | 0;
    rgb[1] = (g + m) * 255 | 0;
    rgb[2] = (b + m) * 255 | 0;
    return rgb;
};

function _computeDivisors(n) {
    var largeDivisors = [],
        divisors = [],
        i;

    for (i = 1; i < Math.sqrt(n) + 1; i++) {
        if (n % i === 0) {
            divisors.push(i);
            if (i !== n / i) {
                largeDivisors.unshift(Math.floor(n / i));
            }
        }
    }
    return divisors.concat(largeDivisors);
};

function _computeIntersection(arr1, arr2) {
    var i = 0,
        j = 0,
        result = [];

    while (i < arr1.length && j < arr2.length) {
        if (arr1[i] === arr2[j]) {
            result.push(arr1[i]);
            i++;
            j++;
        } else if (arr1[i] > arr2[j]) {
            j++;
        } else {
            i++;
        }
    }
    return result;
};

function calculatePatchSize(patchSize, imgSize) {
    var divisorsX = _computeDivisors(imgSize.x),
        divisorsY = _computeDivisors(imgSize.y),
        wideSide = Math.max(imgSize.x, imgSize.y),
        common = _computeIntersection(divisorsX, divisorsY),
        nrOfPatchesList = [8, 10, 15, 20, 32, 60, 80],
        nrOfPatchesMap = {
        "x-small": 5,
        "small": 4,
        "medium": 3,
        "large": 2,
        "x-large": 1
    },
        nrOfPatchesIdx = nrOfPatchesMap[patchSize] || nrOfPatchesMap.medium,
        nrOfPatches = nrOfPatchesList[nrOfPatchesIdx],
        desiredPatchSize = Math.floor(wideSide / nrOfPatches),
        optimalPatchSize;

    function findPatchSizeForDivisors(divisors) {
        var i = 0,
            found = divisors[Math.floor(divisors.length / 2)];

        while (i < divisors.length - 1 && divisors[i] < desiredPatchSize) {
            i++;
        }
        if (i > 0) {
            if (Math.abs(divisors[i] - desiredPatchSize) > Math.abs(divisors[i - 1] - desiredPatchSize)) {
                found = divisors[i - 1];
            } else {
                found = divisors[i];
            }
        }
        if (desiredPatchSize / found < nrOfPatchesList[nrOfPatchesIdx + 1] / nrOfPatchesList[nrOfPatchesIdx] && desiredPatchSize / found > nrOfPatchesList[nrOfPatchesIdx - 1] / nrOfPatchesList[nrOfPatchesIdx]) {
            return { x: found, y: found };
        }
        return null;
    }

    optimalPatchSize = findPatchSizeForDivisors(common);
    if (!optimalPatchSize) {
        optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(wideSide));
        if (!optimalPatchSize) {
            optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(desiredPatchSize * nrOfPatches));
        }
    }
    return optimalPatchSize;
};

function _parseCSSDimensionValues(value) {
    var dimension = {
        value: parseFloat(value),
        unit: value.indexOf("%") === value.length - 1 ? "%" : "%"
    };

    return dimension;
};

var _dimensionsConverters = {
    top: function top(dimension, context) {
        if (dimension.unit === "%") {
            return Math.floor(context.height * (dimension.value / 100));
        }
    },
    right: function right(dimension, context) {
        if (dimension.unit === "%") {
            return Math.floor(context.width - context.width * (dimension.value / 100));
        }
    },
    bottom: function bottom(dimension, context) {
        if (dimension.unit === "%") {
            return Math.floor(context.height - context.height * (dimension.value / 100));
        }
    },
    left: function left(dimension, context) {
        if (dimension.unit === "%") {
            return Math.floor(context.width * (dimension.value / 100));
        }
    }
};

function computeImageArea(inputWidth, inputHeight, area) {
    var context = { width: inputWidth, height: inputHeight };

    var parsedArea = Object.keys(area).reduce(function (result, key) {
        var value = area[key],
            parsed = _parseCSSDimensionValues(value),
            calculated = _dimensionsConverters[key](parsed, context);

        result[key] = calculated;
        return result;
    }, {});

    return {
        sx: parsedArea.left,
        sy: parsedArea.top,
        sw: parsedArea.right - parsedArea.left,
        sh: parsedArea.bottom - parsedArea.top
    };
};

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__subImage__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_cv_utils__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_array_helper__ = __webpack_require__(3);



var vec2 = {
    clone: __webpack_require__(7)
};

/**
 * Represents a basic image combining the data and size.
 * In addition, some methods for manipulation are contained.
 * @param size {x,y} The size of the image in pixel
 * @param data {Array} If given, a flat array containing the pixel data
 * @param ArrayType {Type} If given, the desired DataType of the Array (may be typed/non-typed)
 * @param initialize {Boolean} Indicating if the array should be initialized on creation.
 * @returns {ImageWrapper}
 */
function ImageWrapper(size, data, ArrayType, initialize) {
    if (!data) {
        if (ArrayType) {
            this.data = new ArrayType(size.x * size.y);
            if (ArrayType === Array && initialize) {
                __WEBPACK_IMPORTED_MODULE_2__common_array_helper__["a" /* default */].init(this.data, 0);
            }
        } else {
            this.data = new Uint8Array(size.x * size.y);
            if (Uint8Array === Array && initialize) {
                __WEBPACK_IMPORTED_MODULE_2__common_array_helper__["a" /* default */].init(this.data, 0);
            }
        }
    } else {
        this.data = data;
    }
    this.size = size;
}

/**
 * tests if a position is within the image with a given offset
 * @param imgRef {x, y} The location to test
 * @param border Number the padding value in pixel
 * @returns {Boolean} true if location inside the image's border, false otherwise
 * @see cvd/image.h
 */
ImageWrapper.prototype.inImageWithBorder = function (imgRef, border) {
    return imgRef.x >= border && imgRef.y >= border && imgRef.x < this.size.x - border && imgRef.y < this.size.y - border;
};

/**
 * Performs bilinear sampling
 * @param inImg Image to extract sample from
 * @param x the x-coordinate
 * @param y the y-coordinate
 * @returns the sampled value
 * @see cvd/vision.h
 */
ImageWrapper.sample = function (inImg, x, y) {
    var lx = Math.floor(x);
    var ly = Math.floor(y);
    var w = inImg.size.x;
    var base = ly * inImg.size.x + lx;
    var a = inImg.data[base + 0];
    var b = inImg.data[base + 1];
    var c = inImg.data[base + w];
    var d = inImg.data[base + w + 1];
    var e = a - b;
    x -= lx;
    y -= ly;

    var result = Math.floor(x * (y * (e - c + d) - e) + y * (c - a) + a);
    return result;
};

/**
 * Initializes a given array. Sets each element to zero.
 * @param array {Array} The array to initialize
 */
ImageWrapper.clearArray = function (array) {
    var l = array.length;
    while (l--) {
        array[l] = 0;
    }
};

/**
 * Creates a {SubImage} from the current image ({this}).
 * @param from {ImageRef} The position where to start the {SubImage} from. (top-left corner)
 * @param size {ImageRef} The size of the resulting image
 * @returns {SubImage} A shared part of the original image
 */
ImageWrapper.prototype.subImage = function (from, size) {
    return new __WEBPACK_IMPORTED_MODULE_0__subImage__["a" /* default */](from, size, this);
};

/**
 * Creates an {ImageWrapper) and copies the needed underlying image-data area
 * @param imageWrapper {ImageWrapper} The target {ImageWrapper} where the data should be copied
 * @param from {ImageRef} The location where to copy from (top-left location)
 */
ImageWrapper.prototype.subImageAsCopy = function (imageWrapper, from) {
    var sizeY = imageWrapper.size.y,
        sizeX = imageWrapper.size.x;
    var x, y;
    for (x = 0; x < sizeX; x++) {
        for (y = 0; y < sizeY; y++) {
            imageWrapper.data[y * sizeX + x] = this.data[(from.y + y) * this.size.x + from.x + x];
        }
    }
};

ImageWrapper.prototype.copyTo = function (imageWrapper) {
    var length = this.data.length,
        srcData = this.data,
        dstData = imageWrapper.data;

    while (length--) {
        dstData[length] = srcData[length];
    }
};

/**
 * Retrieves a given pixel position from the image
 * @param x {Number} The x-position
 * @param y {Number} The y-position
 * @returns {Number} The grayscale value at the pixel-position
 */
ImageWrapper.prototype.get = function (x, y) {
    return this.data[y * this.size.x + x];
};

/**
 * Retrieves a given pixel position from the image
 * @param x {Number} The x-position
 * @param y {Number} The y-position
 * @returns {Number} The grayscale value at the pixel-position
 */
ImageWrapper.prototype.getSafe = function (x, y) {
    var i;

    if (!this.indexMapping) {
        this.indexMapping = {
            x: [],
            y: []
        };
        for (i = 0; i < this.size.x; i++) {
            this.indexMapping.x[i] = i;
            this.indexMapping.x[i + this.size.x] = i;
        }
        for (i = 0; i < this.size.y; i++) {
            this.indexMapping.y[i] = i;
            this.indexMapping.y[i + this.size.y] = i;
        }
    }
    return this.data[this.indexMapping.y[y + this.size.y] * this.size.x + this.indexMapping.x[x + this.size.x]];
};

/**
 * Sets a given pixel position in the image
 * @param x {Number} The x-position
 * @param y {Number} The y-position
 * @param value {Number} The grayscale value to set
 * @returns {ImageWrapper} The Image itself (for possible chaining)
 */
ImageWrapper.prototype.set = function (x, y, value) {
    this.data[y * this.size.x + x] = value;
    return this;
};

/**
 * Sets the border of the image (1 pixel) to zero
 */
ImageWrapper.prototype.zeroBorder = function () {
    var i,
        width = this.size.x,
        height = this.size.y,
        data = this.data;
    for (i = 0; i < width; i++) {
        data[i] = data[(height - 1) * width + i] = 0;
    }
    for (i = 1; i < height - 1; i++) {
        data[i * width] = data[i * width + (width - 1)] = 0;
    }
};

/**
 * Inverts a binary image in place
 */
ImageWrapper.prototype.invert = function () {
    var data = this.data,
        length = data.length;

    while (length--) {
        data[length] = data[length] ? 0 : 1;
    }
};

ImageWrapper.prototype.convolve = function (kernel) {
    var x,
        y,
        kx,
        ky,
        kSize = kernel.length / 2 | 0,
        accu = 0;
    for (y = 0; y < this.size.y; y++) {
        for (x = 0; x < this.size.x; x++) {
            accu = 0;
            for (ky = -kSize; ky <= kSize; ky++) {
                for (kx = -kSize; kx <= kSize; kx++) {
                    accu += kernel[ky + kSize][kx + kSize] * this.getSafe(x + kx, y + ky);
                }
            }
            this.data[y * this.size.x + x] = accu;
        }
    }
};

ImageWrapper.prototype.moments = function (labelcount) {
    var data = this.data,
        x,
        y,
        height = this.size.y,
        width = this.size.x,
        val,
        ysq,
        labelsum = [],
        i,
        label,
        mu11,
        mu02,
        mu20,
        x_,
        y_,
        tmp,
        result = [],
        PI = Math.PI,
        PI_4 = PI / 4;

    if (labelcount <= 0) {
        return result;
    }

    for (i = 0; i < labelcount; i++) {
        labelsum[i] = {
            m00: 0,
            m01: 0,
            m10: 0,
            m11: 0,
            m02: 0,
            m20: 0,
            theta: 0,
            rad: 0
        };
    }

    for (y = 0; y < height; y++) {
        ysq = y * y;
        for (x = 0; x < width; x++) {
            val = data[y * width + x];
            if (val > 0) {
                label = labelsum[val - 1];
                label.m00 += 1;
                label.m01 += y;
                label.m10 += x;
                label.m11 += x * y;
                label.m02 += ysq;
                label.m20 += x * x;
            }
        }
    }

    for (i = 0; i < labelcount; i++) {
        label = labelsum[i];
        if (!isNaN(label.m00) && label.m00 !== 0) {
            x_ = label.m10 / label.m00;
            y_ = label.m01 / label.m00;
            mu11 = label.m11 / label.m00 - x_ * y_;
            mu02 = label.m02 / label.m00 - y_ * y_;
            mu20 = label.m20 / label.m00 - x_ * x_;
            tmp = (mu02 - mu20) / (2 * mu11);
            tmp = 0.5 * Math.atan(tmp) + (mu11 >= 0 ? PI_4 : -PI_4) + PI;
            label.theta = (tmp * 180 / PI + 90) % 180 - 90;
            if (label.theta < 0) {
                label.theta += 180;
            }
            label.rad = tmp > PI ? tmp - PI : tmp;
            label.vec = vec2.clone([Math.cos(tmp), Math.sin(tmp)]);
            result.push(label);
        }
    }

    return result;
};

/**
 * Displays the {ImageWrapper} in a given canvas
 * @param canvas {Canvas} The canvas element to write to
 * @param scale {Number} Scale which is applied to each pixel-value
 */
ImageWrapper.prototype.show = function (canvas, scale) {
    var ctx, frame, data, current, pixel, x, y;

    if (!scale) {
        scale = 1.0;
    }
    ctx = canvas.getContext('2d');
    canvas.width = this.size.x;
    canvas.height = this.size.y;
    frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
    data = frame.data;
    current = 0;
    for (y = 0; y < this.size.y; y++) {
        for (x = 0; x < this.size.x; x++) {
            pixel = y * this.size.x + x;
            current = this.get(x, y) * scale;
            data[pixel * 4 + 0] = current;
            data[pixel * 4 + 1] = current;
            data[pixel * 4 + 2] = current;
            data[pixel * 4 + 3] = 255;
        }
    }
    //frame.data = data;
    ctx.putImageData(frame, 0, 0);
};

/**
 * Displays the {SubImage} in a given canvas
 * @param canvas {Canvas} The canvas element to write to
 * @param scale {Number} Scale which is applied to each pixel-value
 */
ImageWrapper.prototype.overlay = function (canvas, scale, from) {
    if (!scale || scale < 0 || scale > 360) {
        scale = 360;
    }
    var hsv = [0, 1, 1];
    var rgb = [0, 0, 0];
    var whiteRgb = [255, 255, 255];
    var blackRgb = [0, 0, 0];
    var result = [];
    var ctx = canvas.getContext('2d');
    var frame = ctx.getImageData(from.x, from.y, this.size.x, this.size.y);
    var data = frame.data;
    var length = this.data.length;
    while (length--) {
        hsv[0] = this.data[length] * scale;
        result = hsv[0] <= 0 ? whiteRgb : hsv[0] >= 360 ? blackRgb : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_cv_utils__["a" /* hsv2rgb */])(hsv, rgb);
        data[length * 4 + 0] = result[0];
        data[length * 4 + 1] = result[1];
        data[length * 4 + 2] = result[2];
        data[length * 4 + 3] = 255;
    }
    ctx.putImageData(frame, from.x, from.y);
};

/* harmony default export */ __webpack_exports__["a"] = (ImageWrapper);

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(37);

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(98),
    getValue = __webpack_require__(121);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(27);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(25),
    isLength = __webpack_require__(26);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(8),
    isObject = __webpack_require__(0);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),
/* 26 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(8),
    isObjectLike = __webpack_require__(6);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var baseMerge = __webpack_require__(101),
    createAssigner = __webpack_require__(117);

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;


/***/ }),
/* 29 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
 */
var Tracer = {
    searchDirections: [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]],
    create: function create(imageWrapper, labelWrapper) {
        var imageData = imageWrapper.data,
            labelData = labelWrapper.data,
            searchDirections = this.searchDirections,
            width = imageWrapper.size.x,
            pos;

        function _trace(current, color, label, edgelabel) {
            var i, y, x;

            for (i = 0; i < 7; i++) {
                y = current.cy + searchDirections[current.dir][0];
                x = current.cx + searchDirections[current.dir][1];
                pos = y * width + x;
                if (imageData[pos] === color && (labelData[pos] === 0 || labelData[pos] === label)) {
                    labelData[pos] = label;
                    current.cy = y;
                    current.cx = x;
                    return true;
                } else {
                    if (labelData[pos] === 0) {
                        labelData[pos] = edgelabel;
                    }
                    current.dir = (current.dir + 1) % 8;
                }
            }
            return false;
        }

        function vertex2D(x, y, dir) {
            return {
                dir: dir,
                x: x,
                y: y,
                next: null,
                prev: null
            };
        }

        function _contourTracing(sy, sx, label, color, edgelabel) {
            var Fv = null,
                Cv,
                P,
                ldir,
                current = {
                cx: sx,
                cy: sy,
                dir: 0
            };

            if (_trace(current, color, label, edgelabel)) {
                Fv = vertex2D(sx, sy, current.dir);
                Cv = Fv;
                ldir = current.dir;
                P = vertex2D(current.cx, current.cy, 0);
                P.prev = Cv;
                Cv.next = P;
                P.next = null;
                Cv = P;
                do {
                    current.dir = (current.dir + 6) % 8;
                    _trace(current, color, label, edgelabel);
                    if (ldir !== current.dir) {
                        Cv.dir = current.dir;
                        P = vertex2D(current.cx, current.cy, 0);
                        P.prev = Cv;
                        Cv.next = P;
                        P.next = null;
                        Cv = P;
                    } else {
                        Cv.dir = ldir;
                        Cv.x = current.cx;
                        Cv.y = current.cy;
                    }
                    ldir = current.dir;
                } while (current.cx !== sx || current.cy !== sy);
                Fv.prev = Cv.prev;
                Cv.prev.next = Fv;
            }
            return Fv;
        }

        return {
            trace: function trace(current, color, label, edgelabel) {
                return _trace(current, color, label, edgelabel);
            },
            contourTracing: function contourTracing(sy, sx, label, color, edgelabel) {
                return _contourTracing(sy, sx, label, color, edgelabel);
            }
        };
    }
};

/* harmony default export */ __webpack_exports__["a"] = (Tracer);

/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__barcode_reader__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_array_helper__ = __webpack_require__(3);



function Code39Reader() {
    __WEBPACK_IMPORTED_MODULE_0__barcode_reader__["a" /* default */].call(this);
}

var properties = {
    ALPHABETH_STRING: { value: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. *$/+%" },
    ALPHABET: { value: [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 45, 46, 32, 42, 36, 47, 43, 37] },
    CHARACTER_ENCODINGS: { value: [0x034, 0x121, 0x061, 0x160, 0x031, 0x130, 0x070, 0x025, 0x124, 0x064, 0x109, 0x049, 0x148, 0x019, 0x118, 0x058, 0x00D, 0x10C, 0x04C, 0x01C, 0x103, 0x043, 0x142, 0x013, 0x112, 0x052, 0x007, 0x106, 0x046, 0x016, 0x181, 0x0C1, 0x1C0, 0x091, 0x190, 0x0D0, 0x085, 0x184, 0x0C4, 0x094, 0x0A8, 0x0A2, 0x08A, 0x02A] },
    ASTERISK: { value: 0x094 },
    FORMAT: { value: "code_39", writeable: false }
};

Code39Reader.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__barcode_reader__["a" /* default */].prototype, properties);
Code39Reader.prototype.constructor = Code39Reader;

Code39Reader.prototype._decode = function () {
    var self = this,
        counters = [0, 0, 0, 0, 0, 0, 0, 0, 0],
        result = [],
        start = self._findStart(),
        decodedChar,
        lastStart,
        pattern,
        nextStart;

    if (!start) {
        return null;
    }
    nextStart = self._nextSet(self._row, start.end);

    do {
        counters = self._toCounters(nextStart, counters);
        pattern = self._toPattern(counters);
        if (pattern < 0) {
            return null;
        }
        decodedChar = self._patternToChar(pattern);
        if (decodedChar < 0) {
            return null;
        }
        result.push(decodedChar);
        lastStart = nextStart;
        nextStart += __WEBPACK_IMPORTED_MODULE_1__common_array_helper__["a" /* default */].sum(counters);
        nextStart = self._nextSet(self._row, nextStart);
    } while (decodedChar !== '*');
    result.pop();

    if (!result.length) {
        return null;
    }

    if (!self._verifyTrailingWhitespace(lastStart, nextStart, counters)) {
        return null;
    }

    return {
        code: result.join(""),
        start: start.start,
        end: nextStart,
        startInfo: start,
        decodedCodes: result
    };
};

Code39Reader.prototype._verifyTrailingWhitespace = function (lastStart, nextStart, counters) {
    var trailingWhitespaceEnd,
        patternSize = __WEBPACK_IMPORTED_MODULE_1__common_array_helper__["a" /* default */].sum(counters);

    trailingWhitespaceEnd = nextStart - lastStart - patternSize;
    if (trailingWhitespaceEnd * 3 >= patternSize) {
        return true;
    }
    return false;
};

Code39Reader.prototype._patternToChar = function (pattern) {
    var i,
        self = this;

    for (i = 0; i < self.CHARACTER_ENCODINGS.length; i++) {
        if (self.CHARACTER_ENCODINGS[i] === pattern) {
            return String.fromCharCode(self.ALPHABET[i]);
        }
    }
    return -1;
};

Code39Reader.prototype._findNextWidth = function (counters, current) {
    var i,
        minWidth = Number.MAX_VALUE;

    for (i = 0; i < counters.length; i++) {
        if (counters[i] < minWidth && counters[i] > current) {
            minWidth = counters[i];
        }
    }

    return minWidth;
};

Code39Reader.prototype._toPattern = function (counters) {
    var numCounters = counters.length,
        maxNarrowWidth = 0,
        numWideBars = numCounters,
        wideBarWidth = 0,
        self = this,
        pattern,
        i;

    while (numWideBars > 3) {
        maxNarrowWidth = self._findNextWidth(counters, maxNarrowWidth);
        numWideBars = 0;
        pattern = 0;
        for (i = 0; i < numCounters; i++) {
            if (counters[i] > maxNarrowWidth) {
                pattern |= 1 << numCounters - 1 - i;
                numWideBars++;
                wideBarWidth += counters[i];
            }
        }

        if (numWideBars === 3) {
            for (i = 0; i < numCounters && numWideBars > 0; i++) {
                if (counters[i] > maxNarrowWidth) {
                    numWideBars--;
                    if (counters[i] * 2 >= wideBarWidth) {
                        return -1;
                    }
                }
            }
            return pattern;
        }
    }
    return -1;
};

Code39Reader.prototype._findStart = function () {
    var self = this,
        offset = self._nextSet(self._row),
        patternStart = offset,
        counter = [0, 0, 0, 0, 0, 0, 0, 0, 0],
        counterPos = 0,
        isWhite = false,
        i,
        j,
        whiteSpaceMustStart;

    for (i = offset; i < self._row.length; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            if (counterPos === counter.length - 1) {
                // find start pattern
                if (self._toPattern(counter) === self.ASTERISK) {
                    whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));
                    if (self._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                        return {
                            start: patternStart,
                            end: i
                        };
                    }
                }

                patternStart += counter[0] + counter[1];
                for (j = 0; j < 7; j++) {
                    counter[j] = counter[j + 2];
                }
                counter[7] = 0;
                counter[8] = 0;
                counterPos--;
            } else {
                counterPos++;
            }
            counter[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return null;
};

/* harmony default export */ __webpack_exports__["a"] = (Code39Reader);

/***/ }),
/* 32 */
/***/ (function(module, exports) {

module.exports = dot

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1]
}

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(22),
    root = __webpack_require__(5);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(139),
    mapCacheDelete = __webpack_require__(140),
    mapCacheGet = __webpack_require__(141),
    mapCacheHas = __webpack_require__(142),
    mapCacheSet = __webpack_require__(143);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(21),
    eq = __webpack_require__(17);

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(21),
    eq = __webpack_require__(17);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(22);

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(48)))

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(148);

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),
/* 40 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(88);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),
/* 42 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key`, unless `key` is "__proto__".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var baseSetToString = __webpack_require__(107),
    shortOut = __webpack_require__(149);

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),
/* 44 */
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(5),
    stubFalse = __webpack_require__(164);

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(29)(module)))

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(99),
    baseUnary = __webpack_require__(110),
    nodeUtil = __webpack_require__(146);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(89),
    baseKeysIn = __webpack_require__(100),
    isArrayLike = __webpack_require__(24);

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),
/* 48 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_merge__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_merge___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash_merge__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_typedefs__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_typedefs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__common_typedefs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_image_wrapper__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__locator_barcode_locator__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__decoder_barcode_decoder__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__common_events__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__input_camera_access__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__common_image_debug__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__analytics_result_collector__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__config_config__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_input_stream__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_frame_grabber__ = __webpack_require__(62);


var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

 // eslint-disable-line no-unused-vars











var vec2 = {
    clone: __webpack_require__(7)
};

var _inputStream,
    _framegrabber,
    _stopped,
    _canvasContainer = {
    ctx: {
        image: null,
        overlay: null
    },
    dom: {
        image: null,
        overlay: null
    }
},
    _inputImageWrapper,
    _boxSize,
    _decoder,
    _workerPool = [],
    _onUIThread = true,
    _resultCollector,
    _config = {};

function initializeData(imageWrapper) {
    initBuffers(imageWrapper);
    _decoder = __WEBPACK_IMPORTED_MODULE_4__decoder_barcode_decoder__["a" /* default */].create(_config.decoder, _inputImageWrapper);
}

function initInputStream(cb) {
    var video;
    if (_config.inputStream.type === "VideoStream") {
        video = document.createElement("video");
        _inputStream = __WEBPACK_IMPORTED_MODULE_10_input_stream__["a" /* default */].createVideoStream(video);
    } else if (_config.inputStream.type === "ImageStream") {
        _inputStream = __WEBPACK_IMPORTED_MODULE_10_input_stream__["a" /* default */].createImageStream();
    } else if (_config.inputStream.type === "LiveStream") {
        var $viewport = getViewPort();
        if ($viewport) {
            video = $viewport.querySelector("video");
            if (!video) {
                video = document.createElement("video");
                $viewport.appendChild(video);
            }
        }
        _inputStream = __WEBPACK_IMPORTED_MODULE_10_input_stream__["a" /* default */].createLiveStream(video);
        __WEBPACK_IMPORTED_MODULE_6__input_camera_access__["a" /* default */].request(video, _config.inputStream.constraints).then(function () {
            _inputStream.trigger("canrecord");
        }).catch(function (err) {
            return cb(err);
        });
    }

    _inputStream.setAttribute("preload", "auto");
    _inputStream.setInputStream(_config.inputStream);
    _inputStream.addEventListener("canrecord", canRecord.bind(undefined, cb));
}

function getViewPort() {
    var target = _config.inputStream.target;
    // Check if target is already a DOM element
    if (target && target.nodeName && target.nodeType === 1) {
        return target;
    } else {
        // Use '#interactive.viewport' as a fallback selector (backwards compatibility)
        var selector = typeof target === 'string' ? target : '#interactive.viewport';
        return document.querySelector(selector);
    }
}

function canRecord(cb) {
    __WEBPACK_IMPORTED_MODULE_3__locator_barcode_locator__["a" /* default */].checkImageConstraints(_inputStream, _config.locator);
    initCanvas(_config);
    _framegrabber = __WEBPACK_IMPORTED_MODULE_11_frame_grabber__["a" /* default */].create(_inputStream, _canvasContainer.dom.image);

    adjustWorkerPool(_config.numOfWorkers, function () {
        if (_config.numOfWorkers === 0) {
            initializeData();
        }
        ready(cb);
    });
}

function ready(cb) {
    _inputStream.play();
    cb();
}

function initCanvas() {
    if (typeof document !== "undefined") {
        var $viewport = getViewPort();
        _canvasContainer.dom.image = document.querySelector("canvas.imgBuffer");
        if (!_canvasContainer.dom.image) {
            _canvasContainer.dom.image = document.createElement("canvas");
            _canvasContainer.dom.image.className = "imgBuffer";
            if ($viewport && _config.inputStream.type === "ImageStream") {
                $viewport.appendChild(_canvasContainer.dom.image);
            }
        }
        _canvasContainer.ctx.image = _canvasContainer.dom.image.getContext("2d");
        _canvasContainer.dom.image.width = _inputStream.getCanvasSize().x;
        _canvasContainer.dom.image.height = _inputStream.getCanvasSize().y;

        _canvasContainer.dom.overlay = document.querySelector("canvas.drawingBuffer");
        if (!_canvasContainer.dom.overlay) {
            _canvasContainer.dom.overlay = document.createElement("canvas");
            _canvasContainer.dom.overlay.className = "drawingBuffer";
            if ($viewport) {
                $viewport.appendChild(_canvasContainer.dom.overlay);
            }
            var clearFix = document.createElement("br");
            clearFix.setAttribute("clear", "all");
            if ($viewport) {
                $viewport.appendChild(clearFix);
            }
        }
        _canvasContainer.ctx.overlay = _canvasContainer.dom.overlay.getContext("2d");
        _canvasContainer.dom.overlay.width = _inputStream.getCanvasSize().x;
        _canvasContainer.dom.overlay.height = _inputStream.getCanvasSize().y;
    }
}

function initBuffers(imageWrapper) {
    if (imageWrapper) {
        _inputImageWrapper = imageWrapper;
    } else {
        _inputImageWrapper = new __WEBPACK_IMPORTED_MODULE_2__common_image_wrapper__["a" /* default */]({
            x: _inputStream.getWidth(),
            y: _inputStream.getHeight()
        });
    }

    if (true) {
        console.log(_inputImageWrapper.size);
    }
    _boxSize = [vec2.clone([0, 0]), vec2.clone([0, _inputImageWrapper.size.y]), vec2.clone([_inputImageWrapper.size.x, _inputImageWrapper.size.y]), vec2.clone([_inputImageWrapper.size.x, 0])];
    __WEBPACK_IMPORTED_MODULE_3__locator_barcode_locator__["a" /* default */].init(_inputImageWrapper, _config.locator);
}

function getBoundingBoxes() {
    if (_config.locate) {
        return __WEBPACK_IMPORTED_MODULE_3__locator_barcode_locator__["a" /* default */].locate();
    } else {
        return [[vec2.clone(_boxSize[0]), vec2.clone(_boxSize[1]), vec2.clone(_boxSize[2]), vec2.clone(_boxSize[3])]];
    }
}

function transformResult(result) {
    var topRight = _inputStream.getTopRight(),
        xOffset = topRight.x,
        yOffset = topRight.y,
        i;

    if (xOffset === 0 && yOffset === 0) {
        return;
    }

    if (result.barcodes) {
        for (i = 0; i < result.barcodes.length; i++) {
            transformResult(result.barcodes[i]);
        }
    }

    if (result.line && result.line.length === 2) {
        moveLine(result.line);
    }

    if (result.box) {
        moveBox(result.box);
    }

    if (result.boxes && result.boxes.length > 0) {
        for (i = 0; i < result.boxes.length; i++) {
            moveBox(result.boxes[i]);
        }
    }

    function moveBox(box) {
        var corner = box.length;

        while (corner--) {
            box[corner][0] += xOffset;
            box[corner][1] += yOffset;
        }
    }

    function moveLine(line) {
        line[0].x += xOffset;
        line[0].y += yOffset;
        line[1].x += xOffset;
        line[1].y += yOffset;
    }
}

function addResult(result, imageData) {
    if (!imageData || !_resultCollector) {
        return;
    }

    if (result.barcodes) {
        result.barcodes.filter(function (barcode) {
            return barcode.codeResult;
        }).forEach(function (barcode) {
            return addResult(barcode, imageData);
        });
    } else if (result.codeResult) {
        _resultCollector.addResult(imageData, _inputStream.getCanvasSize(), result.codeResult);
    }
}

function hasCodeResult(result) {
    return result && (result.barcodes ? result.barcodes.some(function (barcode) {
        return barcode.codeResult;
    }) : result.codeResult);
}

function publishResult(result, imageData) {
    var resultToPublish = result;

    if (result && _onUIThread) {
        transformResult(result);
        addResult(result, imageData);
        resultToPublish = result.barcodes || result;
    }

    __WEBPACK_IMPORTED_MODULE_5__common_events__["a" /* default */].publish("processed", resultToPublish);
    if (hasCodeResult(result)) {
        __WEBPACK_IMPORTED_MODULE_5__common_events__["a" /* default */].publish("detected", resultToPublish);
    }
}

function locateAndDecode() {
    var result, boxes;

    boxes = getBoundingBoxes();
    if (boxes) {
        result = _decoder.decodeFromBoundingBoxes(boxes);
        result = result || {};
        result.boxes = boxes;
        publishResult(result, _inputImageWrapper.data);
    } else {
        publishResult();
    }
}

function update() {
    var availableWorker;

    if (_onUIThread) {
        if (_workerPool.length > 0) {
            availableWorker = _workerPool.filter(function (workerThread) {
                return !workerThread.busy;
            })[0];
            if (availableWorker) {
                _framegrabber.attachData(availableWorker.imageData);
            } else {
                return; // all workers are busy
            }
        } else {
            _framegrabber.attachData(_inputImageWrapper.data);
        }
        if (_framegrabber.grab()) {
            if (availableWorker) {
                availableWorker.busy = true;
                availableWorker.worker.postMessage({
                    cmd: 'process',
                    imageData: availableWorker.imageData
                }, [availableWorker.imageData.buffer]);
            } else {
                locateAndDecode();
            }
        }
    } else {
        locateAndDecode();
    }
}

function startContinuousUpdate() {
    var next = null,
        delay = 1000 / (_config.frequency || 60);

    _stopped = false;
    (function frame(timestamp) {
        next = next || timestamp;
        if (!_stopped) {
            if (timestamp >= next) {
                next += delay;
                update();
            }
            window.requestAnimFrame(frame);
        }
    })(performance.now());
}

function _start() {
    if (_onUIThread && _config.inputStream.type === "LiveStream") {
        startContinuousUpdate();
    } else {
        update();
    }
}

function initWorker(cb) {
    var blobURL,
        workerThread = {
        worker: undefined,
        imageData: new Uint8Array(_inputStream.getWidth() * _inputStream.getHeight()),
        busy: true
    };

    blobURL = generateWorkerBlob();
    workerThread.worker = new Worker(blobURL);

    workerThread.worker.onmessage = function (e) {
        if (e.data.event === 'initialized') {
            URL.revokeObjectURL(blobURL);
            workerThread.busy = false;
            workerThread.imageData = new Uint8Array(e.data.imageData);
            if (true) {
                console.log("Worker initialized");
            }
            return cb(workerThread);
        } else if (e.data.event === 'processed') {
            workerThread.imageData = new Uint8Array(e.data.imageData);
            workerThread.busy = false;
            publishResult(e.data.result, workerThread.imageData);
        } else if (e.data.event === 'error') {
            if (true) {
                console.log("Worker error: " + e.data.message);
            }
        }
    };

    workerThread.worker.postMessage({
        cmd: 'init',
        size: { x: _inputStream.getWidth(), y: _inputStream.getHeight() },
        imageData: workerThread.imageData,
        config: configForWorker(_config)
    }, [workerThread.imageData.buffer]);
}

function configForWorker(config) {
    return _extends({}, config, {
        inputStream: _extends({}, config.inputStream, {
            target: null
        })
    });
}

function workerInterface(factory) {
    /* eslint-disable no-undef*/
    if (factory) {
        var Quagga = factory().default;
        if (!Quagga) {
            self.postMessage({ 'event': 'error', message: 'Quagga could not be created' });
            return;
        }
    }
    var imageWrapper;

    self.onmessage = function (e) {
        if (e.data.cmd === 'init') {
            var config = e.data.config;
            config.numOfWorkers = 0;
            imageWrapper = new Quagga.ImageWrapper({
                x: e.data.size.x,
                y: e.data.size.y
            }, new Uint8Array(e.data.imageData));
            Quagga.init(config, ready, imageWrapper);
            Quagga.onProcessed(onProcessed);
        } else if (e.data.cmd === 'process') {
            imageWrapper.data = new Uint8Array(e.data.imageData);
            Quagga.start();
        } else if (e.data.cmd === 'setReaders') {
            Quagga.setReaders(e.data.readers);
        }
    };

    function onProcessed(result) {
        self.postMessage({
            'event': 'processed',
            imageData: imageWrapper.data,
            result: result
        }, [imageWrapper.data.buffer]);
    }

    function ready() {
        // eslint-disable-line
        self.postMessage({ 'event': 'initialized', imageData: imageWrapper.data }, [imageWrapper.data.buffer]);
    }

    /* eslint-enable */
}

function generateWorkerBlob() {
    var blob, factorySource;

    /* jshint ignore:start */
    if (typeof __factorySource__ !== 'undefined') {
        factorySource = __factorySource__; // eslint-disable-line no-undef
    }
    /* jshint ignore:end */

    blob = new Blob(['(' + workerInterface.toString() + ')(' + factorySource + ');'], { type: 'text/javascript' });

    return window.URL.createObjectURL(blob);
}

function _setReaders(readers) {
    if (_decoder) {
        _decoder.setReaders(readers);
    } else if (_onUIThread && _workerPool.length > 0) {
        _workerPool.forEach(function (workerThread) {
            workerThread.worker.postMessage({ cmd: 'setReaders', readers: readers });
        });
    }
}

function adjustWorkerPool(capacity, cb) {
    var increaseBy = capacity - _workerPool.length;
    if (increaseBy === 0) {
        return cb && cb();
    }
    if (increaseBy < 0) {
        var workersToTerminate = _workerPool.slice(increaseBy);
        workersToTerminate.forEach(function (workerThread) {
            workerThread.worker.terminate();
            if (true) {
                console.log("Worker terminated!");
            }
        });
        _workerPool = _workerPool.slice(0, increaseBy);
        return cb && cb();
    } else {
        var workerInitialized = function workerInitialized(workerThread) {
            _workerPool.push(workerThread);
            if (_workerPool.length >= capacity) {
                cb && cb();
            }
        };

        for (var i = 0; i < increaseBy; i++) {
            initWorker(workerInitialized);
        }
    }
}

/* harmony default export */ __webpack_exports__["default"] = ({
    init: function init(config, cb, imageWrapper) {
        _config = __WEBPACK_IMPORTED_MODULE_0_lodash_merge___default()({}, __WEBPACK_IMPORTED_MODULE_9__config_config__["a" /* default */], config);
        if (imageWrapper) {
            _onUIThread = false;
            initializeData(imageWrapper);
            return cb();
        } else {
            initInputStream(cb);
        }
    },
    start: function start() {
        _start();
    },
    stop: function stop() {
        _stopped = true;
        adjustWorkerPool(0);
        if (_config.inputStream.type === "LiveStream") {
            __WEBPACK_IMPORTED_MODULE_6__input_camera_access__["a" /* default */].release();
            _inputStream.clearEventHandlers();
        }
    },
    pause: function pause() {
        _stopped = true;
    },
    onDetected: function onDetected(callback) {
        __WEBPACK_IMPORTED_MODULE_5__common_events__["a" /* default */].subscribe("detected", callback);
    },
    offDetected: function offDetected(callback) {
        __WEBPACK_IMPORTED_MODULE_5__common_events__["a" /* default */].unsubscribe("detected", callback);
    },
    onProcessed: function onProcessed(callback) {
        __WEBPACK_IMPORTED_MODULE_5__common_events__["a" /* default */].subscribe("processed", callback);
    },
    offProcessed: function offProcessed(callback) {
        __WEBPACK_IMPORTED_MODULE_5__common_events__["a" /* default */].unsubscribe("processed", callback);
    },
    setReaders: function setReaders(readers) {
        _setReaders(readers);
    },
    registerResultCollector: function registerResultCollector(resultCollector) {
        if (resultCollector && typeof resultCollector.addResult === 'function') {
            _resultCollector = resultCollector;
        }
    },
    canvas: _canvasContainer,
    decodeSingle: function decodeSingle(config, resultCallback) {
        var _this = this;

        config = __WEBPACK_IMPORTED_MODULE_0_lodash_merge___default()({
            inputStream: {
                type: "ImageStream",
                sequence: false,
                size: 800,
                src: config.src
            },
            numOfWorkers: true && config.debug ? 0 : 1,
            locator: {
                halfSample: false
            }
        }, config);
        this.init(config, function () {
            __WEBPACK_IMPORTED_MODULE_5__common_events__["a" /* default */].once("processed", function (result) {
                _this.stop();
                resultCallback.call(null, result);
            }, true);
            _start();
        });
    },
    ImageWrapper: __WEBPACK_IMPORTED_MODULE_2__common_image_wrapper__["a" /* default */],
    ImageDebug: __WEBPACK_IMPORTED_MODULE_7__common_image_debug__["a" /* default */],
    ResultCollector: __WEBPACK_IMPORTED_MODULE_8__analytics_result_collector__["a" /* default */],
    CameraAccess: __WEBPACK_IMPORTED_MODULE_6__input_camera_access__["a" /* default */]
});

/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_image_debug__ = __webpack_require__(9);


function contains(codeResult, list) {
    if (list) {
        return list.some(function (item) {
            return Object.keys(item).every(function (key) {
                return item[key] === codeResult[key];
            });
        });
    }
    return false;
}

function passesFilter(codeResult, filter) {
    if (typeof filter === 'function') {
        return filter(codeResult);
    }
    return true;
}

/* harmony default export */ __webpack_exports__["a"] = ({
    create: function create(config) {
        var canvas = document.createElement("canvas"),
            ctx = canvas.getContext("2d"),
            results = [],
            capacity = config.capacity || 20,
            capture = config.capture === true;

        function matchesConstraints(codeResult) {
            return capacity && codeResult && !contains(codeResult, config.blacklist) && passesFilter(codeResult, config.filter);
        }

        return {
            addResult: function addResult(data, imageSize, codeResult) {
                var result = {};

                if (matchesConstraints(codeResult)) {
                    capacity--;
                    result.codeResult = codeResult;
                    if (capture) {
                        canvas.width = imageSize.x;
                        canvas.height = imageSize.y;
                        __WEBPACK_IMPORTED_MODULE_0__common_image_debug__["a" /* default */].drawImage(data, imageSize, ctx);
                        result.frame = canvas.toDataURL();
                    }
                    results.push(result);
                }
            },
            getResults: function getResults() {
                return results;
            }
        };
    }
});

/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var vec2 = {
    clone: __webpack_require__(7),
    dot: __webpack_require__(32)
    /**
     * Creates a cluster for grouping similar orientations of datapoints
     */
};/* harmony default export */ __webpack_exports__["a"] = ({
    create: function create(point, threshold) {
        var points = [],
            center = {
            rad: 0,
            vec: vec2.clone([0, 0])
        },
            pointMap = {};

        function init() {
            _add(point);
            updateCenter();
        }

        function _add(pointToAdd) {
            pointMap[pointToAdd.id] = pointToAdd;
            points.push(pointToAdd);
        }

        function updateCenter() {
            var i,
                sum = 0;
            for (i = 0; i < points.length; i++) {
                sum += points[i].rad;
            }
            center.rad = sum / points.length;
            center.vec = vec2.clone([Math.cos(center.rad), Math.sin(center.rad)]);
        }

        init();

        return {
            add: function add(pointToAdd) {
                if (!pointMap[pointToAdd.id]) {
                    _add(pointToAdd);
                    updateCenter();
                }
            },
            fits: function fits(otherPoint) {
                // check cosine similarity to center-angle
                var similarity = Math.abs(vec2.dot(otherPoint.point.vec, center.vec));
                if (similarity > threshold) {
                    return true;
                }
                return false;
            },
            getPoints: function getPoints() {
                return points;
            },
            getCenter: function getCenter() {
                return center;
            }
        };
    },
    createPoint: function createPoint(newPoint, id, property) {
        return {
            rad: newPoint[property],
            point: newPoint,
            id: id
        };
    }
});

/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ((function () {
    var events = {};

    function getEvent(eventName) {
        if (!events[eventName]) {
            events[eventName] = {
                subscribers: []
            };
        }
        return events[eventName];
    }

    function clearEvents() {
        events = {};
    }

    function publishSubscription(subscription, data) {
        if (subscription.async) {
            setTimeout(function () {
                subscription.callback(data);
            }, 4);
        } else {
            subscription.callback(data);
        }
    }

    function _subscribe(event, callback, async) {
        var subscription;

        if (typeof callback === "function") {
            subscription = {
                callback: callback,
                async: async
            };
        } else {
            subscription = callback;
            if (!subscription.callback) {
                throw "Callback was not specified on options";
            }
        }

        getEvent(event).subscribers.push(subscription);
    }

    return {
        subscribe: function subscribe(event, callback, async) {
            return _subscribe(event, callback, async);
        },
        publish: function publish(eventName, data) {
            var event = getEvent(eventName),
                subscribers = event.subscribers;

            // Publish one-time subscriptions
            subscribers.filter(function (subscriber) {
                return !!subscriber.once;
            }).forEach(function (subscriber) {
                publishSubscription(subscriber, data);
            });

            // remove them from the subscriber
            event.subscribers = subscribers.filter(function (subscriber) {
                return !subscriber.once;
            });

            // publish the rest
            event.subscribers.forEach(function (subscriber) {
                publishSubscription(subscriber, data);
            });
        },
        once: function once(event, callback, async) {
            _subscribe(event, {
                callback: callback,
                async: async,
                once: true
            });
        },
        unsubscribe: function unsubscribe(eventName, callback) {
            var event;

            if (eventName) {
                event = getEvent(eventName);
                if (event && callback) {
                    event.subscribers = event.subscribers.filter(function (subscriber) {
                        return subscriber.callback !== callback;
                    });
                } else {
                    event.subscribers = [];
                }
            } else {
                clearEvents();
            }
        }
    };
})());

/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = enumerateDevices;
/* harmony export (immutable) */ __webpack_exports__["a"] = getUserMedia;

function enumerateDevices() {
    if (navigator.mediaDevices && typeof navigator.mediaDevices.enumerateDevices === 'function') {
        return navigator.mediaDevices.enumerateDevices();
    }
    return Promise.reject(new Error('enumerateDevices is not defined'));
};

function getUserMedia(constraints) {
    if (navigator.mediaDevices && typeof navigator.mediaDevices.getUserMedia === 'function') {
        return navigator.mediaDevices.getUserMedia(constraints);
    }
    return Promise.reject(new Error('getUserMedia is not defined'));
}

/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Construct representing a part of another {ImageWrapper}. Shares data
 * between the parent and the child.
 * @param from {ImageRef} The position where to start the {SubImage} from. (top-left corner)
 * @param size {ImageRef} The size of the resulting image
 * @param I {ImageWrapper} The {ImageWrapper} to share from
 * @returns {SubImage} A shared part of the original image
 */
function SubImage(from, size, I) {
    if (!I) {
        I = {
            data: null,
            size: size
        };
    }
    this.data = I.data;
    this.originalSize = I.size;
    this.I = I;

    this.from = from;
    this.size = size;
}

/**
 * Displays the {SubImage} in a given canvas
 * @param canvas {Canvas} The canvas element to write to
 * @param scale {Number} Scale which is applied to each pixel-value
 */
SubImage.prototype.show = function (canvas, scale) {
    var ctx, frame, data, current, y, x, pixel;

    if (!scale) {
        scale = 1.0;
    }
    ctx = canvas.getContext('2d');
    canvas.width = this.size.x;
    canvas.height = this.size.y;
    frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
    data = frame.data;
    current = 0;
    for (y = 0; y < this.size.y; y++) {
        for (x = 0; x < this.size.x; x++) {
            pixel = y * this.size.x + x;
            current = this.get(x, y) * scale;
            data[pixel * 4 + 0] = current;
            data[pixel * 4 + 1] = current;
            data[pixel * 4 + 2] = current;
            data[pixel * 4 + 3] = 255;
        }
    }
    frame.data = data;
    ctx.putImageData(frame, 0, 0);
};

/**
 * Retrieves a given pixel position from the {SubImage}
 * @param x {Number} The x-position
 * @param y {Number} The y-position
 * @returns {Number} The grayscale value at the pixel-position
 */
SubImage.prototype.get = function (x, y) {
    return this.data[(this.from.y + y) * this.originalSize.x + this.from.x + x];
};

/**
 * Updates the underlying data from a given {ImageWrapper}
 * @param image {ImageWrapper} The updated image
 */
SubImage.prototype.updateData = function (image) {
    this.originalSize = image.size;
    this.data = image.data;
};

/**
 * Updates the position of the shared area
 * @param from {x,y} The new location
 * @returns {SubImage} returns {this} for possible chaining
 */
SubImage.prototype.updateFrom = function (from) {
    this.from = from;
    return this;
};

/* harmony default export */ __webpack_exports__["a"] = (SubImage);

/***/ }),
/* 55 */
/***/ (function(module, exports) {

/*
 * typedefs.js
 * Normalizes browser-specific prefixes
 */

if (typeof window !== 'undefined') {
    window.requestAnimFrame = function () {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function ( /* function FrameRequestCallback */callback) {
            window.setTimeout(callback, 1000 / 60);
        };
    }();
}
Math.imul = Math.imul || function (a, b) {
    var ah = a >>> 16 & 0xffff,
        al = a & 0xffff,
        bh = b >>> 16 & 0xffff,
        bl = b & 0xffff;
    // the shift by 0 fixes the sign on the high part
    // the final |0 converts the unsigned value into a signed value
    return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
};

if (typeof Object.assign !== 'function') {
    Object.assign = function (target) {
        // .length of function is 2
        'use strict';

        if (target === null) {
            // TypeError if undefined or null
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var to = Object(target);

        for (var index = 1; index < arguments.length; index++) {
            var nextSource = arguments[index];

            if (nextSource !== null) {
                // Skip over if undefined or null
                for (var nextKey in nextSource) {
                    // Avoid bugs when hasOwnProperty is shadowed
                    if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                        to[nextKey] = nextSource[nextKey];
                    }
                }
            }
        }
        return to;
    };
}

/***/ }),
/* 56 */
/***/ (function(module, exports) {

module.exports = {
    inputStream: {
        name: "Live",
        type: "LiveStream",
        constraints: {
            width: 640,
            height: 480,
            // aspectRatio: 640/480, // optional
            facingMode: "environment" // or user
            // deviceId: "38745983457387598375983759834"
        },
        area: {
            top: "0%",
            right: "0%",
            left: "0%",
            bottom: "0%"
        },
        singleChannel: false // true: only the red color-channel is read
    },
    locate: true,
    numOfWorkers: 0,
    decoder: {
        readers: ['code_128_reader'],
        debug: {
            drawBoundingBox: false,
            showFrequency: false,
            drawScanline: false,
            showPattern: false
        }
    },
    locator: {
        halfSample: true,
        patchSize: "medium", // x-small, small, medium, large, x-large
        debug: {
            showCanvas: false,
            showPatches: false,
            showFoundPatches: false,
            showSkeleton: false,
            showLabels: false,
            showPatchLabels: false,
            showRemainingPatchLabels: false,
            boxFromPatches: {
                showTransformed: false,
                showTransformedBox: false,
                showBB: false
            }
        }
    }
};

/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var config = void 0;

if (true) {
    config = __webpack_require__(56);
} else if (ENV.node) {
    config = require('./config.node.js');
} else {
    config = require('./config.prod.js');
}

/* harmony default export */ __webpack_exports__["a"] = (config);

/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bresenham__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_image_debug__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__reader_code_128_reader__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__reader_ean_reader__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__reader_code_39_reader__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__reader_code_39_vin_reader__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__reader_codabar_reader__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__reader_upc_reader__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__reader_ean_8_reader__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__reader_ean_2_reader__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__reader_ean_5_reader__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__reader_upc_e_reader__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__reader_i2of5_reader__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__reader_2of5_reader__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__reader_code_93_reader__ = __webpack_require__(72);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

















var READERS = {
    code_128_reader: __WEBPACK_IMPORTED_MODULE_2__reader_code_128_reader__["a" /* default */],
    ean_reader: __WEBPACK_IMPORTED_MODULE_3__reader_ean_reader__["a" /* default */],
    ean_5_reader: __WEBPACK_IMPORTED_MODULE_10__reader_ean_5_reader__["a" /* default */],
    ean_2_reader: __WEBPACK_IMPORTED_MODULE_9__reader_ean_2_reader__["a" /* default */],
    ean_8_reader: __WEBPACK_IMPORTED_MODULE_8__reader_ean_8_reader__["a" /* default */],
    code_39_reader: __WEBPACK_IMPORTED_MODULE_4__reader_code_39_reader__["a" /* default */],
    code_39_vin_reader: __WEBPACK_IMPORTED_MODULE_5__reader_code_39_vin_reader__["a" /* default */],
    codabar_reader: __WEBPACK_IMPORTED_MODULE_6__reader_codabar_reader__["a" /* default */],
    upc_reader: __WEBPACK_IMPORTED_MODULE_7__reader_upc_reader__["a" /* default */],
    upc_e_reader: __WEBPACK_IMPORTED_MODULE_11__reader_upc_e_reader__["a" /* default */],
    i2of5_reader: __WEBPACK_IMPORTED_MODULE_12__reader_i2of5_reader__["a" /* default */],
    '2of5_reader': __WEBPACK_IMPORTED_MODULE_13__reader_2of5_reader__["a" /* default */],
    code_93_reader: __WEBPACK_IMPORTED_MODULE_14__reader_code_93_reader__["a" /* default */]
};
/* harmony default export */ __webpack_exports__["a"] = ({
    create: function create(config, inputImageWrapper) {
        var _canvas = {
            ctx: {
                frequency: null,
                pattern: null,
                overlay: null
            },
            dom: {
                frequency: null,
                pattern: null,
                overlay: null
            }
        },
            _barcodeReaders = [];

        initCanvas();
        initReaders();
        initConfig();

        function initCanvas() {
            if (true && typeof document !== 'undefined') {
                var $debug = document.querySelector("#debug.detection");
                _canvas.dom.frequency = document.querySelector("canvas.frequency");
                if (!_canvas.dom.frequency) {
                    _canvas.dom.frequency = document.createElement("canvas");
                    _canvas.dom.frequency.className = "frequency";
                    if ($debug) {
                        $debug.appendChild(_canvas.dom.frequency);
                    }
                }
                _canvas.ctx.frequency = _canvas.dom.frequency.getContext("2d");

                _canvas.dom.pattern = document.querySelector("canvas.patternBuffer");
                if (!_canvas.dom.pattern) {
                    _canvas.dom.pattern = document.createElement("canvas");
                    _canvas.dom.pattern.className = "patternBuffer";
                    if ($debug) {
                        $debug.appendChild(_canvas.dom.pattern);
                    }
                }
                _canvas.ctx.pattern = _canvas.dom.pattern.getContext("2d");

                _canvas.dom.overlay = document.querySelector("canvas.drawingBuffer");
                if (_canvas.dom.overlay) {
                    _canvas.ctx.overlay = _canvas.dom.overlay.getContext("2d");
                }
            }
        }

        function initReaders() {
            config.readers.forEach(function (readerConfig) {
                var reader,
                    configuration = {},
                    supplements = [];

                if ((typeof readerConfig === 'undefined' ? 'undefined' : _typeof(readerConfig)) === 'object') {
                    reader = readerConfig.format;
                    configuration = readerConfig.config;
                } else if (typeof readerConfig === 'string') {
                    reader = readerConfig;
                }
                if (true) {
                    console.log("Before registering reader: ", reader);
                }
                if (configuration.supplements) {
                    supplements = configuration.supplements.map(function (supplement) {
                        return new READERS[supplement]();
                    });
                }
                _barcodeReaders.push(new READERS[reader](configuration, supplements));
            });
            if (true) {
                console.log("Registered Readers: " + _barcodeReaders.map(function (reader) {
                    return JSON.stringify({ format: reader.FORMAT, config: reader.config });
                }).join(', '));
            }
        }

        function initConfig() {
            if (true && typeof document !== 'undefined') {
                var i,
                    vis = [{
                    node: _canvas.dom.frequency,
                    prop: config.debug.showFrequency
                }, {
                    node: _canvas.dom.pattern,
                    prop: config.debug.showPattern
                }];

                for (i = 0; i < vis.length; i++) {
                    if (vis[i].prop === true) {
                        vis[i].node.style.display = "block";
                    } else {
                        vis[i].node.style.display = "none";
                    }
                }
            }
        }

        /**
         * extend the line on both ends
         * @param {Array} line
         * @param {Number} angle
         */
        function getExtendedLine(line, angle, ext) {
            function extendLine(amount) {
                var extension = {
                    y: amount * Math.sin(angle),
                    x: amount * Math.cos(angle)
                };

                line[0].y -= extension.y;
                line[0].x -= extension.x;
                line[1].y += extension.y;
                line[1].x += extension.x;
            }

            // check if inside image
            extendLine(ext);
            while (ext > 1 && (!inputImageWrapper.inImageWithBorder(line[0], 0) || !inputImageWrapper.inImageWithBorder(line[1], 0))) {
                ext -= Math.ceil(ext / 2);
                extendLine(-ext);
            }
            return line;
        }

        function getLine(box) {
            return [{
                x: (box[1][0] - box[0][0]) / 2 + box[0][0],
                y: (box[1][1] - box[0][1]) / 2 + box[0][1]
            }, {
                x: (box[3][0] - box[2][0]) / 2 + box[2][0],
                y: (box[3][1] - box[2][1]) / 2 + box[2][1]
            }];
        }

        function tryDecode(line) {
            var result = null,
                i,
                barcodeLine = __WEBPACK_IMPORTED_MODULE_0__bresenham__["a" /* default */].getBarcodeLine(inputImageWrapper, line[0], line[1]);

            if (true && config.debug.showFrequency) {
                __WEBPACK_IMPORTED_MODULE_1__common_image_debug__["a" /* default */].drawPath(line, { x: 'x', y: 'y' }, _canvas.ctx.overlay, { color: 'red', lineWidth: 3 });
                __WEBPACK_IMPORTED_MODULE_0__bresenham__["a" /* default */].debug.printFrequency(barcodeLine.line, _canvas.dom.frequency);
            }

            __WEBPACK_IMPORTED_MODULE_0__bresenham__["a" /* default */].toBinaryLine(barcodeLine);

            if (true && config.debug.showPattern) {
                __WEBPACK_IMPORTED_MODULE_0__bresenham__["a" /* default */].debug.printPattern(barcodeLine.line, _canvas.dom.pattern);
            }

            for (i = 0; i < _barcodeReaders.length && result === null; i++) {
                result = _barcodeReaders[i].decodePattern(barcodeLine.line);
            }
            if (result === null) {
                return null;
            }
            return {
                codeResult: result,
                barcodeLine: barcodeLine
            };
        }

        /**
         * This method slices the given area apart and tries to detect a barcode-pattern
         * for each slice. It returns the decoded barcode, or null if nothing was found
         * @param {Array} box
         * @param {Array} line
         * @param {Number} lineAngle
         */
        function tryDecodeBruteForce(box, line, lineAngle) {
            var sideLength = Math.sqrt(Math.pow(box[1][0] - box[0][0], 2) + Math.pow(box[1][1] - box[0][1], 2)),
                i,
                slices = 16,
                result = null,
                dir,
                extension,
                xdir = Math.sin(lineAngle),
                ydir = Math.cos(lineAngle);

            for (i = 1; i < slices && result === null; i++) {
                // move line perpendicular to angle
                dir = sideLength / slices * i * (i % 2 === 0 ? -1 : 1);
                extension = {
                    y: dir * xdir,
                    x: dir * ydir
                };
                line[0].y += extension.x;
                line[0].x -= extension.y;
                line[1].y += extension.x;
                line[1].x -= extension.y;

                result = tryDecode(line);
            }
            return result;
        }

        function getLineLength(line) {
            return Math.sqrt(Math.pow(Math.abs(line[1].y - line[0].y), 2) + Math.pow(Math.abs(line[1].x - line[0].x), 2));
        }

        /**
         * With the help of the configured readers (Code128 or EAN) this function tries to detect a
         * valid barcode pattern within the given area.
         * @param {Object} box The area to search in
         * @returns {Object} the result {codeResult, line, angle, pattern, threshold}
         */
        function _decodeFromBoundingBox(box) {
            var line,
                lineAngle,
                ctx = _canvas.ctx.overlay,
                result,
                lineLength;

            if (true) {
                if (config.debug.drawBoundingBox && ctx) {
                    __WEBPACK_IMPORTED_MODULE_1__common_image_debug__["a" /* default */].drawPath(box, { x: 0, y: 1 }, ctx, { color: "blue", lineWidth: 2 });
                }
            }

            line = getLine(box);
            lineLength = getLineLength(line);
            lineAngle = Math.atan2(line[1].y - line[0].y, line[1].x - line[0].x);
            line = getExtendedLine(line, lineAngle, Math.floor(lineLength * 0.1));
            if (line === null) {
                return null;
            }

            result = tryDecode(line);
            if (result === null) {
                result = tryDecodeBruteForce(box, line, lineAngle);
            }

            if (result === null) {
                return null;
            }

            if (true && result && config.debug.drawScanline && ctx) {
                __WEBPACK_IMPORTED_MODULE_1__common_image_debug__["a" /* default */].drawPath(line, { x: 'x', y: 'y' }, ctx, { color: 'red', lineWidth: 3 });
            }

            return {
                codeResult: result.codeResult,
                line: line,
                angle: lineAngle,
                pattern: result.barcodeLine.line,
                threshold: result.barcodeLine.threshold
            };
        }

        return {
            decodeFromBoundingBox: function decodeFromBoundingBox(box) {
                return _decodeFromBoundingBox(box);
            },
            decodeFromBoundingBoxes: function decodeFromBoundingBoxes(boxes) {
                var i,
                    result,
                    barcodes = [],
                    multiple = config.multiple;

                for (i = 0; i < boxes.length; i++) {
                    var box = boxes[i];
                    result = _decodeFromBoundingBox(box) || {};
                    result.box = box;

                    if (multiple) {
                        barcodes.push(result);
                    } else if (result.codeResult) {
                        return result;
                    }
                }

                if (multiple) {
                    return {
                        barcodes: barcodes
                    };
                }
            },
            setReaders: function setReaders(readers) {
                config.readers = readers;
                _barcodeReaders.length = 0;
                initReaders();
            }
        };
    }
});

/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_image_wrapper__ = __webpack_require__(20);


var Bresenham = {};

var Slope = {
    DIR: {
        UP: 1,
        DOWN: -1
    }
};
/**
 * Scans a line of the given image from point p1 to p2 and returns a result object containing
 * gray-scale values (0-255) of the underlying pixels in addition to the min
 * and max values.
 * @param {Object} imageWrapper
 * @param {Object} p1 The start point {x,y}
 * @param {Object} p2 The end point {x,y}
 * @returns {line, min, max}
 */
Bresenham.getBarcodeLine = function (imageWrapper, p1, p2) {
    var x0 = p1.x | 0,
        y0 = p1.y | 0,
        x1 = p2.x | 0,
        y1 = p2.y | 0,
        steep = Math.abs(y1 - y0) > Math.abs(x1 - x0),
        deltax,
        deltay,
        error,
        ystep,
        y,
        tmp,
        x,
        line = [],
        imageData = imageWrapper.data,
        width = imageWrapper.size.x,
        sum = 0,
        val,
        min = 255,
        max = 0;

    function read(a, b) {
        val = imageData[b * width + a];
        sum += val;
        min = val < min ? val : min;
        max = val > max ? val : max;
        line.push(val);
    }

    if (steep) {
        tmp = x0;
        x0 = y0;
        y0 = tmp;

        tmp = x1;
        x1 = y1;
        y1 = tmp;
    }
    if (x0 > x1) {
        tmp = x0;
        x0 = x1;
        x1 = tmp;

        tmp = y0;
        y0 = y1;
        y1 = tmp;
    }
    deltax = x1 - x0;
    deltay = Math.abs(y1 - y0);
    error = deltax / 2 | 0;
    y = y0;
    ystep = y0 < y1 ? 1 : -1;
    for (x = x0; x < x1; x++) {
        if (steep) {
            read(y, x);
        } else {
            read(x, y);
        }
        error = error - deltay;
        if (error < 0) {
            y = y + ystep;
            error = error + deltax;
        }
    }

    return {
        line: line,
        min: min,
        max: max
    };
};

/**
 * Converts the result from getBarcodeLine into a binary representation
 * also considering the frequency and slope of the signal for more robust results
 * @param {Object} result {line, min, max}
 */
Bresenham.toBinaryLine = function (result) {
    var min = result.min,
        max = result.max,
        line = result.line,
        slope,
        slope2,
        center = min + (max - min) / 2,
        extrema = [],
        currentDir,
        dir,
        threshold = (max - min) / 12,
        rThreshold = -threshold,
        i,
        j;

    // 1. find extrema
    currentDir = line[0] > center ? Slope.DIR.UP : Slope.DIR.DOWN;
    extrema.push({
        pos: 0,
        val: line[0]
    });
    for (i = 0; i < line.length - 2; i++) {
        slope = line[i + 1] - line[i];
        slope2 = line[i + 2] - line[i + 1];
        if (slope + slope2 < rThreshold && line[i + 1] < center * 1.5) {
            dir = Slope.DIR.DOWN;
        } else if (slope + slope2 > threshold && line[i + 1] > center * 0.5) {
            dir = Slope.DIR.UP;
        } else {
            dir = currentDir;
        }

        if (currentDir !== dir) {
            extrema.push({
                pos: i,
                val: line[i]
            });
            currentDir = dir;
        }
    }
    extrema.push({
        pos: line.length,
        val: line[line.length - 1]
    });

    for (j = extrema[0].pos; j < extrema[1].pos; j++) {
        line[j] = line[j] > center ? 0 : 1;
    }

    // iterate over extrema and convert to binary based on avg between minmax
    for (i = 1; i < extrema.length - 1; i++) {
        if (extrema[i + 1].val > extrema[i].val) {
            threshold = extrema[i].val + (extrema[i + 1].val - extrema[i].val) / 3 * 2 | 0;
        } else {
            threshold = extrema[i + 1].val + (extrema[i].val - extrema[i + 1].val) / 3 | 0;
        }

        for (j = extrema[i].pos; j < extrema[i + 1].pos; j++) {
            line[j] = line[j] > threshold ? 0 : 1;
        }
    }

    return {
        line: line,
        threshold: threshold
    };
};

/**
 * Used for development only
 */
Bresenham.debug = {
    printFrequency: function printFrequency(line, canvas) {
        var i,
            ctx = canvas.getContext("2d");
        canvas.width = line.length;
        canvas.height = 256;

        ctx.beginPath();
        ctx.strokeStyle = "blue";
        for (i = 0; i < line.length; i++) {
            ctx.moveTo(i, 255);
            ctx.lineTo(i, 255 - line[i]);
        }
        ctx.stroke();
        ctx.closePath();
    },

    printPattern: function printPattern(line, canvas) {
        var ctx = canvas.getContext("2d"),
            i;

        canvas.width = line.length;
        ctx.fillColor = "black";
        for (i = 0; i < line.length; i++) {
            if (line[i] === 1) {
                ctx.fillRect(i, 0, 1, 100);
            }
        }
    }
};

/* harmony default export */ __webpack_exports__["a"] = (Bresenham);

/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export pickConstraints */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_pick__ = __webpack_require__(163);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_pick___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash_pick__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_mediaDevices__ = __webpack_require__(53);




var facingMatching = {
    "user": /front/i,
    "environment": /back/i
};

var streamRef;

function waitForVideo(video) {
    return new Promise(function (resolve, reject) {
        var attempts = 10;

        function checkVideo() {
            if (attempts > 0) {
                if (video.videoWidth > 10 && video.videoHeight > 10) {
                    if (true) {
                        console.log(video.videoWidth + "px x " + video.videoHeight + "px");
                    }
                    resolve();
                } else {
                    window.setTimeout(checkVideo, 500);
                }
            } else {
                reject('Unable to play video stream. Is webcam working?');
            }
            attempts--;
        }
        checkVideo();
    });
}

/**
 * Tries to attach the camera-stream to a given video-element
 * and calls the callback function when the content is ready
 * @param {Object} constraints
 * @param {Object} video
 */
function initCamera(video, constraints) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_mediaDevices__["a" /* getUserMedia */])(constraints).then(function (stream) {
        return new Promise(function (resolve) {
            streamRef = stream;
            video.setAttribute("autoplay", true);
            video.setAttribute('muted', true);
            video.setAttribute('playsinline', true);
            video.srcObject = stream;
            video.addEventListener('loadedmetadata', function () {
                video.play();
                resolve();
            });
        });
    }).then(waitForVideo.bind(null, video));
}

function deprecatedConstraints(videoConstraints) {
    var normalized = __WEBPACK_IMPORTED_MODULE_0_lodash_pick___default()(videoConstraints, ["width", "height", "facingMode", "aspectRatio", "deviceId"]);

    if (typeof videoConstraints.minAspectRatio !== 'undefined' && videoConstraints.minAspectRatio > 0) {
        normalized.aspectRatio = videoConstraints.minAspectRatio;
        console.log("WARNING: Constraint 'minAspectRatio' is deprecated; Use 'aspectRatio' instead");
    }
    if (typeof videoConstraints.facing !== 'undefined') {
        normalized.facingMode = videoConstraints.facing;
        console.log("WARNING: Constraint 'facing' is deprecated. Use 'facingMode' instead'");
    }
    return normalized;
}

function pickConstraints(videoConstraints) {
    var normalizedConstraints = {
        audio: false,
        video: deprecatedConstraints(videoConstraints)
    };

    if (normalizedConstraints.video.deviceId && normalizedConstraints.video.facingMode) {
        delete normalizedConstraints.video.facingMode;
    }
    return Promise.resolve(normalizedConstraints);
}

function enumerateVideoDevices() {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_mediaDevices__["b" /* enumerateDevices */])().then(function (devices) {
        return devices.filter(function (device) {
            return device.kind === 'videoinput';
        });
    });
}

function getActiveTrack() {
    if (streamRef) {
        var tracks = streamRef.getVideoTracks();
        if (tracks && tracks.length) {
            return tracks[0];
        }
    }
}

/* harmony default export */ __webpack_exports__["a"] = ({
    request: function request(video, videoConstraints) {
        return pickConstraints(videoConstraints).then(initCamera.bind(null, video));
    },
    release: function release() {
        var tracks = streamRef && streamRef.getVideoTracks();
        if (tracks && tracks.length) {
            tracks[0].stop();
        }
        streamRef = null;
    },
    enumerateVideoDevices: enumerateVideoDevices,
    getActiveStreamLabel: function getActiveStreamLabel() {
        var track = getActiveTrack();
        return track ? track.label : '';
    },
    getActiveTrack: getActiveTrack
});

/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export AvailableTags */
/* harmony export (immutable) */ __webpack_exports__["a"] = findTagsInObjectURL;
/* unused harmony export base64ToArrayBuffer */
/* unused harmony export findTagsInBuffer */
// Scraped from https://github.com/exif-js/exif-js

var ExifTags = { 0x0112: "orientation" };
var AvailableTags = Object.keys(ExifTags).map(function (key) {
    return ExifTags[key];
});

function findTagsInObjectURL(src) {
    var tags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AvailableTags;

    if (/^blob\:/i.test(src)) {
        return objectURLToBlob(src).then(readToBuffer).then(function (buffer) {
            return findTagsInBuffer(buffer, tags);
        });
    }
    return Promise.resolve(null);
}

function base64ToArrayBuffer(dataUrl) {
    var base64 = dataUrl.replace(/^data\:([^\;]+)\;base64,/gmi, ''),
        binary = atob(base64),
        len = binary.length,
        buffer = new ArrayBuffer(len),
        view = new Uint8Array(buffer);

    for (var i = 0; i < len; i++) {
        view[i] = binary.charCodeAt(i);
    }
    return buffer;
}

function readToBuffer(blob) {
    return new Promise(function (resolve) {
        var fileReader = new FileReader();
        fileReader.onload = function (e) {
            return resolve(e.target.result);
        };
        fileReader.readAsArrayBuffer(blob);
    });
}

function objectURLToBlob(url) {
    return new Promise(function (resolve, reject) {
        var http = new XMLHttpRequest();
        http.open("GET", url, true);
        http.responseType = "blob";
        http.onreadystatechange = function () {
            if (http.readyState === XMLHttpRequest.DONE && (http.status === 200 || http.status === 0)) {
                resolve(this.response);
            }
        };
        http.onerror = reject;
        http.send();
    });
}

function findTagsInBuffer(file) {
    var selectedTags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AvailableTags;

    var dataView = new DataView(file),
        length = file.byteLength,
        exifTags = selectedTags.reduce(function (result, selectedTag) {
        var exifTag = Object.keys(ExifTags).filter(function (tag) {
            return ExifTags[tag] === selectedTag;
        })[0];
        if (exifTag) {
            result[exifTag] = selectedTag;
        }
        return result;
    }, {});
    var offset = 2,
        marker = void 0;

    if (dataView.getUint8(0) !== 0xFF || dataView.getUint8(1) !== 0xD8) {
        return false;
    }

    while (offset < length) {
        if (dataView.getUint8(offset) !== 0xFF) {
            return false;
        }

        marker = dataView.getUint8(offset + 1);
        if (marker === 0xE1) {
            return readEXIFData(dataView, offset + 4, exifTags);
        } else {
            offset += 2 + dataView.getUint16(offset + 2);
        }
    }
}

function readEXIFData(file, start, exifTags) {
    if (getStringFromBuffer(file, start, 4) !== "Exif") {
        return false;
    }

    var tiffOffset = start + 6;
    var bigEnd = void 0,
        tags = void 0;

    if (file.getUint16(tiffOffset) === 0x4949) {
        bigEnd = false;
    } else if (file.getUint16(tiffOffset) === 0x4D4D) {
        bigEnd = true;
    } else {
        return false;
    }

    if (file.getUint16(tiffOffset + 2, !bigEnd) !== 0x002A) {
        return false;
    }

    var firstIFDOffset = file.getUint32(tiffOffset + 4, !bigEnd);
    if (firstIFDOffset < 0x00000008) {
        return false;
    }

    tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, exifTags, bigEnd);
    return tags;
}

function readTags(file, tiffStart, dirStart, strings, bigEnd) {
    var entries = file.getUint16(dirStart, !bigEnd),
        tags = {};

    for (var i = 0; i < entries; i++) {
        var entryOffset = dirStart + i * 12 + 2,
            tag = strings[file.getUint16(entryOffset, !bigEnd)];
        if (tag) {
            tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);
        }
    }
    return tags;
}

function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {
    var type = file.getUint16(entryOffset + 2, !bigEnd),
        numValues = file.getUint32(entryOffset + 4, !bigEnd);

    switch (type) {
        case 3:
            if (numValues === 1) {
                return file.getUint16(entryOffset + 8, !bigEnd);
            }
    }
}

function getStringFromBuffer(buffer, start, length) {
    var outstr = "";
    for (var n = start; n < start + length; n++) {
        outstr += String.fromCharCode(buffer.getUint8(n));
    }
    return outstr;
}

/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_cv_utils__ = __webpack_require__(19);


var TO_RADIANS = Math.PI / 180;

function adjustCanvasSize(canvas, targetSize) {
    if (canvas.width !== targetSize.x) {
        if (true) {
            console.log("WARNING: canvas-size needs to be adjusted");
        }
        canvas.width = targetSize.x;
    }
    if (canvas.height !== targetSize.y) {
        if (true) {
            console.log("WARNING: canvas-size needs to be adjusted");
        }
        canvas.height = targetSize.y;
    }
}

var FrameGrabber = {};

FrameGrabber.create = function (inputStream, canvas) {
    var _that = {},
        _streamConfig = inputStream.getConfig(),
        _video_size = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_cv_utils__["b" /* imageRef */])(inputStream.getRealWidth(), inputStream.getRealHeight()),
        _canvasSize = inputStream.getCanvasSize(),
        _size = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_cv_utils__["b" /* imageRef */])(inputStream.getWidth(), inputStream.getHeight()),
        topRight = inputStream.getTopRight(),
        _sx = topRight.x,
        _sy = topRight.y,
        _canvas,
        _ctx = null,
        _data = null;

    _canvas = canvas ? canvas : document.createElement("canvas");
    _canvas.width = _canvasSize.x;
    _canvas.height = _canvasSize.y;
    _ctx = _canvas.getContext("2d");
    _data = new Uint8Array(_size.x * _size.y);
    if (true) {
        console.log("FrameGrabber", JSON.stringify({
            size: _size,
            topRight: topRight,
            videoSize: _video_size,
            canvasSize: _canvasSize
        }));
    }

    /**
     * Uses the given array as frame-buffer
     */
    _that.attachData = function (data) {
        _data = data;
    };

    /**
     * Returns the used frame-buffer
     */
    _that.getData = function () {
        return _data;
    };

    /**
     * Fetches a frame from the input-stream and puts into the frame-buffer.
     * The image-data is converted to gray-scale and then half-sampled if configured.
     */
    _that.grab = function () {
        var doHalfSample = _streamConfig.halfSample,
            frame = inputStream.getFrame(),
            drawable = frame,
            drawAngle = 0,
            ctxData;
        if (drawable) {
            adjustCanvasSize(_canvas, _canvasSize);
            if (_streamConfig.type === 'ImageStream') {
                drawable = frame.img;
                if (frame.tags && frame.tags.orientation) {
                    switch (frame.tags.orientation) {
                        case 6:
                            drawAngle = 90 * TO_RADIANS;
                            break;
                        case 8:
                            drawAngle = -90 * TO_RADIANS;
                            break;
                    }
                }
            }

            if (drawAngle !== 0) {
                _ctx.translate(_canvasSize.x / 2, _canvasSize.y / 2);
                _ctx.rotate(drawAngle);
                _ctx.drawImage(drawable, -_canvasSize.y / 2, -_canvasSize.x / 2, _canvasSize.y, _canvasSize.x);
                _ctx.rotate(-drawAngle);
                _ctx.translate(-_canvasSize.x / 2, -_canvasSize.y / 2);
            } else {
                _ctx.drawImage(drawable, 0, 0, _canvasSize.x, _canvasSize.y);
            }

            ctxData = _ctx.getImageData(_sx, _sy, _size.x, _size.y).data;
            if (doHalfSample) {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_cv_utils__["c" /* grayAndHalfSampleFromCanvasData */])(ctxData, _size, _data);
            } else {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_cv_utils__["d" /* computeGray */])(ctxData, _data, _streamConfig);
            }
            return true;
        } else {
            return false;
        }
    };

    _that.getSize = function () {
        return _size;
    };

    return _that;
};

/* harmony default export */ __webpack_exports__["a"] = (FrameGrabber);

/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__exif_helper__ = __webpack_require__(61);


var ImageLoader = {};
ImageLoader.load = function (directory, callback, offset, size, sequence) {
    var htmlImagesSrcArray = new Array(size),
        htmlImagesArray = new Array(htmlImagesSrcArray.length),
        i,
        img,
        num;

    if (sequence === false) {
        htmlImagesSrcArray[0] = directory;
    } else {
        for (i = 0; i < htmlImagesSrcArray.length; i++) {
            num = offset + i;
            htmlImagesSrcArray[i] = directory + "image-" + ("00" + num).slice(-3) + ".jpg";
        }
    }
    htmlImagesArray.notLoaded = [];
    htmlImagesArray.addImage = function (image) {
        htmlImagesArray.notLoaded.push(image);
    };
    htmlImagesArray.loaded = function (loadedImg) {
        var notloadedImgs = htmlImagesArray.notLoaded;
        for (var x = 0; x < notloadedImgs.length; x++) {
            if (notloadedImgs[x] === loadedImg) {
                notloadedImgs.splice(x, 1);
                for (var y = 0; y < htmlImagesSrcArray.length; y++) {
                    var imgName = htmlImagesSrcArray[y].substr(htmlImagesSrcArray[y].lastIndexOf("/"));
                    if (loadedImg.src.lastIndexOf(imgName) !== -1) {
                        htmlImagesArray[y] = { img: loadedImg };
                        break;
                    }
                }
                break;
            }
        }
        if (notloadedImgs.length === 0) {
            if (true) {
                console.log("Images loaded");
            }
            if (sequence === false) {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__exif_helper__["a" /* findTagsInObjectURL */])(directory, ['orientation']).then(function (tags) {
                    htmlImagesArray[0].tags = tags;
                    callback(htmlImagesArray);
                }).catch(function (e) {
                    console.log(e);
                    callback(htmlImagesArray);
                });
            } else {
                callback(htmlImagesArray);
            }
        }
    };

    for (i = 0; i < htmlImagesSrcArray.length; i++) {
        img = new Image();
        htmlImagesArray.addImage(img);
        addOnloadHandler(img, htmlImagesArray);
        img.src = htmlImagesSrcArray[i];
    }
};

function addOnloadHandler(img, htmlImagesArray) {
    img.onload = function () {
        htmlImagesArray.loaded(this);
    };
}

/* harmony default export */ __webpack_exports__["a"] = (ImageLoader);

/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__image_loader__ = __webpack_require__(63);


var InputStream = {};
InputStream.createVideoStream = function (video) {
    var that = {},
        _config = null,
        _eventNames = ['canrecord', 'ended'],
        _eventHandlers = {},
        _calculatedWidth,
        _calculatedHeight,
        _topRight = { x: 0, y: 0 },
        _canvasSize = { x: 0, y: 0 };

    function initSize() {
        var width = video.videoWidth,
            height = video.videoHeight;

        _calculatedWidth = _config.size ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width;
        _calculatedHeight = _config.size ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;

        _canvasSize.x = _calculatedWidth;
        _canvasSize.y = _calculatedHeight;
    }

    that.getRealWidth = function () {
        return video.videoWidth;
    };

    that.getRealHeight = function () {
        return video.videoHeight;
    };

    that.getWidth = function () {
        return _calculatedWidth;
    };

    that.getHeight = function () {
        return _calculatedHeight;
    };

    that.setWidth = function (width) {
        _calculatedWidth = width;
    };

    that.setHeight = function (height) {
        _calculatedHeight = height;
    };

    that.setInputStream = function (config) {
        _config = config;
        video.src = typeof config.src !== 'undefined' ? config.src : '';
    };

    that.ended = function () {
        return video.ended;
    };

    that.getConfig = function () {
        return _config;
    };

    that.setAttribute = function (name, value) {
        video.setAttribute(name, value);
    };

    that.pause = function () {
        video.pause();
    };

    that.play = function () {
        video.play();
    };

    that.setCurrentTime = function (time) {
        if (_config.type !== "LiveStream") {
            video.currentTime = time;
        }
    };

    that.addEventListener = function (event, f, bool) {
        if (_eventNames.indexOf(event) !== -1) {
            if (!_eventHandlers[event]) {
                _eventHandlers[event] = [];
            }
            _eventHandlers[event].push(f);
        } else {
            video.addEventListener(event, f, bool);
        }
    };

    that.clearEventHandlers = function () {
        _eventNames.forEach(function (eventName) {
            var handlers = _eventHandlers[eventName];
            if (handlers && handlers.length > 0) {
                handlers.forEach(function (handler) {
                    video.removeEventListener(eventName, handler);
                });
            }
        });
    };

    that.trigger = function (eventName, args) {
        var j,
            handlers = _eventHandlers[eventName];

        if (eventName === 'canrecord') {
            initSize();
        }
        if (handlers && handlers.length > 0) {
            for (j = 0; j < handlers.length; j++) {
                handlers[j].apply(that, args);
            }
        }
    };

    that.setTopRight = function (topRight) {
        _topRight.x = topRight.x;
        _topRight.y = topRight.y;
    };

    that.getTopRight = function () {
        return _topRight;
    };

    that.setCanvasSize = function (size) {
        _canvasSize.x = size.x;
        _canvasSize.y = size.y;
    };

    that.getCanvasSize = function () {
        return _canvasSize;
    };

    that.getFrame = function () {
        return video;
    };

    return that;
};

InputStream.createLiveStream = function (video) {
    video.setAttribute("autoplay", true);
    var that = InputStream.createVideoStream(video);

    that.ended = function () {
        return false;
    };

    return that;
};

InputStream.createImageStream = function () {
    var that = {};
    var _config = null;

    var width = 0,
        height = 0,
        frameIdx = 0,
        paused = true,
        loaded = false,
        imgArray = null,
        size = 0,
        offset = 1,
        baseUrl = null,
        ended = false,
        calculatedWidth,
        calculatedHeight,
        _eventNames = ['canrecord', 'ended'],
        _eventHandlers = {},
        _topRight = { x: 0, y: 0 },
        _canvasSize = { x: 0, y: 0 };

    function loadImages() {
        loaded = false;
        __WEBPACK_IMPORTED_MODULE_0__image_loader__["a" /* default */].load(baseUrl, function (imgs) {
            imgArray = imgs;
            if (imgs[0].tags && imgs[0].tags.orientation) {
                switch (imgs[0].tags.orientation) {
                    case 6:
                    case 8:
                        width = imgs[0].img.height;
                        height = imgs[0].img.width;
                        break;
                    default:
                        width = imgs[0].img.width;
                        height = imgs[0].img.height;
                }
            } else {
                width = imgs[0].img.width;
                height = imgs[0].img.height;
            }
            calculatedWidth = _config.size ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width;
            calculatedHeight = _config.size ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;
            _canvasSize.x = calculatedWidth;
            _canvasSize.y = calculatedHeight;
            loaded = true;
            frameIdx = 0;
            setTimeout(function () {
                publishEvent("canrecord", []);
            }, 0);
        }, offset, size, _config.sequence);
    }

    function publishEvent(eventName, args) {
        var j,
            handlers = _eventHandlers[eventName];

        if (handlers && handlers.length > 0) {
            for (j = 0; j < handlers.length; j++) {
                handlers[j].apply(that, args);
            }
        }
    }

    that.trigger = publishEvent;

    that.getWidth = function () {
        return calculatedWidth;
    };

    that.getHeight = function () {
        return calculatedHeight;
    };

    that.setWidth = function (newWidth) {
        calculatedWidth = newWidth;
    };

    that.setHeight = function (newHeight) {
        calculatedHeight = newHeight;
    };

    that.getRealWidth = function () {
        return width;
    };

    that.getRealHeight = function () {
        return height;
    };

    that.setInputStream = function (stream) {
        _config = stream;
        if (stream.sequence === false) {
            baseUrl = stream.src;
            size = 1;
        } else {
            baseUrl = stream.src;
            size = stream.length;
        }
        loadImages();
    };

    that.ended = function () {
        return ended;
    };

    that.setAttribute = function () {};

    that.getConfig = function () {
        return _config;
    };

    that.pause = function () {
        paused = true;
    };

    that.play = function () {
        paused = false;
    };

    that.setCurrentTime = function (time) {
        frameIdx = time;
    };

    that.addEventListener = function (event, f) {
        if (_eventNames.indexOf(event) !== -1) {
            if (!_eventHandlers[event]) {
                _eventHandlers[event] = [];
            }
            _eventHandlers[event].push(f);
        }
    };

    that.setTopRight = function (topRight) {
        _topRight.x = topRight.x;
        _topRight.y = topRight.y;
    };

    that.getTopRight = function () {
        return _topRight;
    };

    that.setCanvasSize = function (canvasSize) {
        _canvasSize.x = canvasSize.x;
        _canvasSize.y = canvasSize.y;
    };

    that.getCanvasSize = function () {
        return _canvasSize;
    };

    that.getFrame = function () {
        var frame;

        if (!loaded) {
            return null;
        }
        if (!paused) {
            frame = imgArray[frameIdx];
            if (frameIdx < size - 1) {
                frameIdx++;
            } else {
                setTimeout(function () {
                    ended = true;
                    publishEvent("ended", []);
                }, 0);
            }
        }
        return frame;
    };

    return that;
};

/* harmony default export */ __webpack_exports__["a"] = (InputStream);

/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_image_wrapper__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_cv_utils__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_array_helper__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__common_image_debug__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__rasterizer__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__tracer__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__skeletonizer__ = __webpack_require__(67);







var vec2 = {
    clone: __webpack_require__(7),
    dot: __webpack_require__(32),
    scale: __webpack_require__(82),
    transformMat2: __webpack_require__(83)
};
var mat2 = {
    copy: __webpack_require__(79),
    create: __webpack_require__(80),
    invert: __webpack_require__(81)
};

var _config,
    _currentImageWrapper,
    _skelImageWrapper,
    _subImageWrapper,
    _labelImageWrapper,
    _patchGrid,
    _patchLabelGrid,
    _imageToPatchGrid,
    _binaryImageWrapper,
    _patchSize,
    _canvasContainer = {
    ctx: {
        binary: null
    },
    dom: {
        binary: null
    }
},
    _numPatches = { x: 0, y: 0 },
    _inputImageWrapper,
    _skeletonizer;

function initBuffers() {
    var skeletonImageData;

    if (_config.halfSample) {
        _currentImageWrapper = new __WEBPACK_IMPORTED_MODULE_0__common_image_wrapper__["a" /* default */]({
            x: _inputImageWrapper.size.x / 2 | 0,
            y: _inputImageWrapper.size.y / 2 | 0
        });
    } else {
        _currentImageWrapper = _inputImageWrapper;
    }

    _patchSize = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_cv_utils__["e" /* calculatePatchSize */])(_config.patchSize, _currentImageWrapper.size);

    _numPatches.x = _currentImageWrapper.size.x / _patchSize.x | 0;
    _numPatches.y = _currentImageWrapper.size.y / _patchSize.y | 0;

    _binaryImageWrapper = new __WEBPACK_IMPORTED_MODULE_0__common_image_wrapper__["a" /* default */](_currentImageWrapper.size, undefined, Uint8Array, false);

    _labelImageWrapper = new __WEBPACK_IMPORTED_MODULE_0__common_image_wrapper__["a" /* default */](_patchSize, undefined, Array, true);

    skeletonImageData = new ArrayBuffer(64 * 1024);
    _subImageWrapper = new __WEBPACK_IMPORTED_MODULE_0__common_image_wrapper__["a" /* default */](_patchSize, new Uint8Array(skeletonImageData, 0, _patchSize.x * _patchSize.y));
    _skelImageWrapper = new __WEBPACK_IMPORTED_MODULE_0__common_image_wrapper__["a" /* default */](_patchSize, new Uint8Array(skeletonImageData, _patchSize.x * _patchSize.y * 3, _patchSize.x * _patchSize.y), undefined, true);
    _skeletonizer = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__skeletonizer__["a" /* default */])(typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : global, {
        size: _patchSize.x
    }, skeletonImageData);

    _imageToPatchGrid = new __WEBPACK_IMPORTED_MODULE_0__common_image_wrapper__["a" /* default */]({
        x: _currentImageWrapper.size.x / _subImageWrapper.size.x | 0,
        y: _currentImageWrapper.size.y / _subImageWrapper.size.y | 0
    }, undefined, Array, true);
    _patchGrid = new __WEBPACK_IMPORTED_MODULE_0__common_image_wrapper__["a" /* default */](_imageToPatchGrid.size, undefined, undefined, true);
    _patchLabelGrid = new __WEBPACK_IMPORTED_MODULE_0__common_image_wrapper__["a" /* default */](_imageToPatchGrid.size, undefined, Int32Array, true);
}

function initCanvas() {
    if (_config.useWorker || typeof document === 'undefined') {
        return;
    }
    _canvasContainer.dom.binary = document.createElement("canvas");
    _canvasContainer.dom.binary.className = "binaryBuffer";
    if (true && _config.debug.showCanvas === true) {
        document.querySelector("#debug").appendChild(_canvasContainer.dom.binary);
    }
    _canvasContainer.ctx.binary = _canvasContainer.dom.binary.getContext("2d");
    _canvasContainer.dom.binary.width = _binaryImageWrapper.size.x;
    _canvasContainer.dom.binary.height = _binaryImageWrapper.size.y;
}

/**
 * Creates a bounding box which encloses all the given patches
 * @returns {Array} The minimal bounding box
 */
function boxFromPatches(patches) {
    var overAvg,
        i,
        j,
        patch,
        transMat,
        minx = _binaryImageWrapper.size.x,
        miny = _binaryImageWrapper.size.y,
        maxx = -_binaryImageWrapper.size.x,
        maxy = -_binaryImageWrapper.size.y,
        box,
        scale;

    // draw all patches which are to be taken into consideration
    overAvg = 0;
    for (i = 0; i < patches.length; i++) {
        patch = patches[i];
        overAvg += patch.rad;
        if (true && _config.debug.showPatches) {
            __WEBPACK_IMPORTED_MODULE_3__common_image_debug__["a" /* default */].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, { color: "red" });
        }
    }

    overAvg /= patches.length;
    overAvg = (overAvg * 180 / Math.PI + 90) % 180 - 90;
    if (overAvg < 0) {
        overAvg += 180;
    }

    overAvg = (180 - overAvg) * Math.PI / 180;
    transMat = mat2.copy(mat2.create(), [Math.cos(overAvg), Math.sin(overAvg), -Math.sin(overAvg), Math.cos(overAvg)]);

    // iterate over patches and rotate by angle
    for (i = 0; i < patches.length; i++) {
        patch = patches[i];
        for (j = 0; j < 4; j++) {
            vec2.transformMat2(patch.box[j], patch.box[j], transMat);
        }

        if (true && _config.debug.boxFromPatches.showTransformed) {
            __WEBPACK_IMPORTED_MODULE_3__common_image_debug__["a" /* default */].drawPath(patch.box, { x: 0, y: 1 }, _canvasContainer.ctx.binary, { color: '#99ff00', lineWidth: 2 });
        }
    }

    // find bounding box
    for (i = 0; i < patches.length; i++) {
        patch = patches[i];
        for (j = 0; j < 4; j++) {
            if (patch.box[j][0] < minx) {
                minx = patch.box[j][0];
            }
            if (patch.box[j][0] > maxx) {
                maxx = patch.box[j][0];
            }
            if (patch.box[j][1] < miny) {
                miny = patch.box[j][1];
            }
            if (patch.box[j][1] > maxy) {
                maxy = patch.box[j][1];
            }
        }
    }

    box = [[minx, miny], [maxx, miny], [maxx, maxy], [minx, maxy]];

    if (true && _config.debug.boxFromPatches.showTransformedBox) {
        __WEBPACK_IMPORTED_MODULE_3__common_image_debug__["a" /* default */].drawPath(box, { x: 0, y: 1 }, _canvasContainer.ctx.binary, { color: '#ff0000', lineWidth: 2 });
    }

    scale = _config.halfSample ? 2 : 1;
    // reverse rotation;
    transMat = mat2.invert(transMat, transMat);
    for (j = 0; j < 4; j++) {
        vec2.transformMat2(box[j], box[j], transMat);
    }

    if (true && _config.debug.boxFromPatches.showBB) {
        __WEBPACK_IMPORTED_MODULE_3__common_image_debug__["a" /* default */].drawPath(box, { x: 0, y: 1 }, _canvasContainer.ctx.binary, { color: '#ff0000', lineWidth: 2 });
    }

    for (j = 0; j < 4; j++) {
        vec2.scale(box[j], box[j], scale);
    }

    return box;
}

/**
 * Creates a binary image of the current image
 */
function binarizeImage() {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_cv_utils__["f" /* otsuThreshold */])(_currentImageWrapper, _binaryImageWrapper);
    _binaryImageWrapper.zeroBorder();
    if (true && _config.debug.showCanvas) {
        _binaryImageWrapper.show(_canvasContainer.dom.binary, 255);
    }
}

/**
 * Iterate over the entire image
 * extract patches
 */
function findPatches() {
    var i,
        j,
        x,
        y,
        moments,
        patchesFound = [],
        rasterizer,
        rasterResult,
        patch;
    for (i = 0; i < _numPatches.x; i++) {
        for (j = 0; j < _numPatches.y; j++) {
            x = _subImageWrapper.size.x * i;
            y = _subImageWrapper.size.y * j;

            // seperate parts
            skeletonize(x, y);

            // Rasterize, find individual bars
            _skelImageWrapper.zeroBorder();
            __WEBPACK_IMPORTED_MODULE_2__common_array_helper__["a" /* default */].init(_labelImageWrapper.data, 0);
            rasterizer = __WEBPACK_IMPORTED_MODULE_4__rasterizer__["a" /* default */].create(_skelImageWrapper, _labelImageWrapper);
            rasterResult = rasterizer.rasterize(0);

            if (true && _config.debug.showLabels) {
                _labelImageWrapper.overlay(_canvasContainer.dom.binary, Math.floor(360 / rasterResult.count), { x: x, y: y });
            }

            // calculate moments from the skeletonized patch
            moments = _labelImageWrapper.moments(rasterResult.count);

            // extract eligible patches
            patchesFound = patchesFound.concat(describePatch(moments, [i, j], x, y));
        }
    }

    if (true && _config.debug.showFoundPatches) {
        for (i = 0; i < patchesFound.length; i++) {
            patch = patchesFound[i];
            __WEBPACK_IMPORTED_MODULE_3__common_image_debug__["a" /* default */].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, { color: "#99ff00", lineWidth: 2 });
        }
    }

    return patchesFound;
}

/**
 * Finds those connected areas which contain at least 6 patches
 * and returns them ordered DESC by the number of contained patches
 * @param {Number} maxLabel
 */
function findBiggestConnectedAreas(maxLabel) {
    var i,
        sum,
        labelHist = [],
        topLabels = [];

    for (i = 0; i < maxLabel; i++) {
        labelHist.push(0);
    }
    sum = _patchLabelGrid.data.length;
    while (sum--) {
        if (_patchLabelGrid.data[sum] > 0) {
            labelHist[_patchLabelGrid.data[sum] - 1]++;
        }
    }

    labelHist = labelHist.map(function (val, idx) {
        return {
            val: val,
            label: idx + 1
        };
    });

    labelHist.sort(function (a, b) {
        return b.val - a.val;
    });

    // extract top areas with at least 6 patches present
    topLabels = labelHist.filter(function (el) {
        return el.val >= 5;
    });

    return topLabels;
}

/**
 *
 */
function findBoxes(topLabels, maxLabel) {
    var i,
        j,
        sum,
        patches = [],
        patch,
        box,
        boxes = [],
        hsv = [0, 1, 1],
        rgb = [0, 0, 0];

    for (i = 0; i < topLabels.length; i++) {
        sum = _patchLabelGrid.data.length;
        patches.length = 0;
        while (sum--) {
            if (_patchLabelGrid.data[sum] === topLabels[i].label) {
                patch = _imageToPatchGrid.data[sum];
                patches.push(patch);
            }
        }
        box = boxFromPatches(patches);
        if (box) {
            boxes.push(box);

            // draw patch-labels if requested
            if (true && _config.debug.showRemainingPatchLabels) {
                for (j = 0; j < patches.length; j++) {
                    patch = patches[j];
                    hsv[0] = topLabels[i].label / (maxLabel + 1) * 360;
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_cv_utils__["a" /* hsv2rgb */])(hsv, rgb);
                    __WEBPACK_IMPORTED_MODULE_3__common_image_debug__["a" /* default */].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, { color: "rgb(" + rgb.join(",") + ")", lineWidth: 2 });
                }
            }
        }
    }
    return boxes;
}

/**
 * Find similar moments (via cluster)
 * @param {Object} moments
 */
function similarMoments(moments) {
    var clusters = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_cv_utils__["g" /* cluster */])(moments, 0.90);
    var topCluster = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_cv_utils__["h" /* topGeneric */])(clusters, 1, function (e) {
        return e.getPoints().length;
    });
    var points = [],
        result = [];
    if (topCluster.length === 1) {
        points = topCluster[0].item.getPoints();
        for (var i = 0; i < points.length; i++) {
            result.push(points[i].point);
        }
    }
    return result;
}

function skeletonize(x, y) {
    _binaryImageWrapper.subImageAsCopy(_subImageWrapper, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_cv_utils__["b" /* imageRef */])(x, y));
    _skeletonizer.skeletonize();

    // Show skeleton if requested
    if (true && _config.debug.showSkeleton) {
        _skelImageWrapper.overlay(_canvasContainer.dom.binary, 360, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_cv_utils__["b" /* imageRef */])(x, y));
    }
}

/**
 * Extracts and describes those patches which seem to contain a barcode pattern
 * @param {Array} moments
 * @param {Object} patchPos,
 * @param {Number} x
 * @param {Number} y
 * @returns {Array} list of patches
 */
function describePatch(moments, patchPos, x, y) {
    var k,
        avg,
        eligibleMoments = [],
        matchingMoments,
        patch,
        patchesFound = [],
        minComponentWeight = Math.ceil(_patchSize.x / 3);

    if (moments.length >= 2) {
        // only collect moments which's area covers at least minComponentWeight pixels.
        for (k = 0; k < moments.length; k++) {
            if (moments[k].m00 > minComponentWeight) {
                eligibleMoments.push(moments[k]);
            }
        }

        // if at least 2 moments are found which have at least minComponentWeights covered
        if (eligibleMoments.length >= 2) {
            matchingMoments = similarMoments(eligibleMoments);
            avg = 0;
            // determine the similarity of the moments
            for (k = 0; k < matchingMoments.length; k++) {
                avg += matchingMoments[k].rad;
            }

            // Only two of the moments are allowed not to fit into the equation
            // add the patch to the set
            if (matchingMoments.length > 1 && matchingMoments.length >= eligibleMoments.length / 4 * 3 && matchingMoments.length > moments.length / 4) {
                avg /= matchingMoments.length;
                patch = {
                    index: patchPos[1] * _numPatches.x + patchPos[0],
                    pos: {
                        x: x,
                        y: y
                    },
                    box: [vec2.clone([x, y]), vec2.clone([x + _subImageWrapper.size.x, y]), vec2.clone([x + _subImageWrapper.size.x, y + _subImageWrapper.size.y]), vec2.clone([x, y + _subImageWrapper.size.y])],
                    moments: matchingMoments,
                    rad: avg,
                    vec: vec2.clone([Math.cos(avg), Math.sin(avg)])
                };
                patchesFound.push(patch);
            }
        }
    }
    return patchesFound;
}

/**
 * finds patches which are connected and share the same orientation
 * @param {Object} patchesFound
 */
function rasterizeAngularSimilarity(patchesFound) {
    var label = 0,
        threshold = 0.95,
        currIdx = 0,
        j,
        patch,
        hsv = [0, 1, 1],
        rgb = [0, 0, 0];

    function notYetProcessed() {
        var i;
        for (i = 0; i < _patchLabelGrid.data.length; i++) {
            if (_patchLabelGrid.data[i] === 0 && _patchGrid.data[i] === 1) {
                return i;
            }
        }
        return _patchLabelGrid.length;
    }

    function trace(currentIdx) {
        var x,
            y,
            currentPatch,
            idx,
            dir,
            current = {
            x: currentIdx % _patchLabelGrid.size.x,
            y: currentIdx / _patchLabelGrid.size.x | 0
        },
            similarity;

        if (currentIdx < _patchLabelGrid.data.length) {
            currentPatch = _imageToPatchGrid.data[currentIdx];
            // assign label
            _patchLabelGrid.data[currentIdx] = label;
            for (dir = 0; dir < __WEBPACK_IMPORTED_MODULE_5__tracer__["a" /* default */].searchDirections.length; dir++) {
                y = current.y + __WEBPACK_IMPORTED_MODULE_5__tracer__["a" /* default */].searchDirections[dir][0];
                x = current.x + __WEBPACK_IMPORTED_MODULE_5__tracer__["a" /* default */].searchDirections[dir][1];
                idx = y * _patchLabelGrid.size.x + x;

                // continue if patch empty
                if (_patchGrid.data[idx] === 0) {
                    _patchLabelGrid.data[idx] = Number.MAX_VALUE;
                    continue;
                }

                if (_patchLabelGrid.data[idx] === 0) {
                    similarity = Math.abs(vec2.dot(_imageToPatchGrid.data[idx].vec, currentPatch.vec));
                    if (similarity > threshold) {
                        trace(idx);
                    }
                }
            }
        }
    }

    // prepare for finding the right patches
    __WEBPACK_IMPORTED_MODULE_2__common_array_helper__["a" /* default */].init(_patchGrid.data, 0);
    __WEBPACK_IMPORTED_MODULE_2__common_array_helper__["a" /* default */].init(_patchLabelGrid.data, 0);
    __WEBPACK_IMPORTED_MODULE_2__common_array_helper__["a" /* default */].init(_imageToPatchGrid.data, null);

    for (j = 0; j < patchesFound.length; j++) {
        patch = patchesFound[j];
        _imageToPatchGrid.data[patch.index] = patch;
        _patchGrid.data[patch.index] = 1;
    }

    // rasterize the patches found to determine area
    _patchGrid.zeroBorder();

    while ((currIdx = notYetProcessed()) < _patchLabelGrid.data.length) {
        label++;
        trace(currIdx);
    }

    // draw patch-labels if requested
    if (true && _config.debug.showPatchLabels) {
        for (j = 0; j < _patchLabelGrid.data.length; j++) {
            if (_patchLabelGrid.data[j] > 0 && _patchLabelGrid.data[j] <= label) {
                patch = _imageToPatchGrid.data[j];
                hsv[0] = _patchLabelGrid.data[j] / (label + 1) * 360;
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_cv_utils__["a" /* hsv2rgb */])(hsv, rgb);
                __WEBPACK_IMPORTED_MODULE_3__common_image_debug__["a" /* default */].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, { color: "rgb(" + rgb.join(",") + ")", lineWidth: 2 });
            }
        }
    }

    return label;
}

/* harmony default export */ __webpack_exports__["a"] = ({
    init: function init(inputImageWrapper, config) {
        _config = config;
        _inputImageWrapper = inputImageWrapper;

        initBuffers();
        initCanvas();
    },

    locate: function locate() {
        var patchesFound, topLabels, boxes;

        if (_config.halfSample) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_cv_utils__["i" /* halfSample */])(_inputImageWrapper, _currentImageWrapper);
        }

        binarizeImage();
        patchesFound = findPatches();
        // return unless 5% or more patches are found
        if (patchesFound.length < _numPatches.x * _numPatches.y * 0.05) {
            return null;
        }

        // rasterrize area by comparing angular similarity;
        var maxLabel = rasterizeAngularSimilarity(patchesFound);
        if (maxLabel < 1) {
            return null;
        }

        // search for area with the most patches (biggest connected area)
        topLabels = findBiggestConnectedAreas(maxLabel);
        if (topLabels.length === 0) {
            return null;
        }

        boxes = findBoxes(topLabels, maxLabel);
        return boxes;
    },

    checkImageConstraints: function checkImageConstraints(inputStream, config) {
        var patchSize,
            width = inputStream.getWidth(),
            height = inputStream.getHeight(),
            halfSample = config.halfSample ? 0.5 : 1,
            size,
            area;

        // calculate width and height based on area
        if (inputStream.getConfig().area) {
            area = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_cv_utils__["j" /* computeImageArea */])(width, height, inputStream.getConfig().area);
            inputStream.setTopRight({ x: area.sx, y: area.sy });
            inputStream.setCanvasSize({ x: width, y: height });
            width = area.sw;
            height = area.sh;
        }

        size = {
            x: Math.floor(width * halfSample),
            y: Math.floor(height * halfSample)
        };

        patchSize = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_cv_utils__["e" /* calculatePatchSize */])(config.patchSize, size);
        if (true) {
            console.log("Patch-Size: " + JSON.stringify(patchSize));
        }

        inputStream.setWidth(Math.floor(Math.floor(size.x / patchSize.x) * (1 / halfSample) * patchSize.x));
        inputStream.setHeight(Math.floor(Math.floor(size.y / patchSize.y) * (1 / halfSample) * patchSize.y));

        if (inputStream.getWidth() % patchSize.x === 0 && inputStream.getHeight() % patchSize.y === 0) {
            return true;
        }

        throw new Error("Image dimensions do not comply with the current settings: Width (" + width + " )and height (" + height + ") must a multiple of " + patchSize.x);
    }
});
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(48)))

/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__tracer__ = __webpack_require__(30);


/**
 * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
 */
var Rasterizer = {
    createContour2D: function createContour2D() {
        return {
            dir: null,
            index: null,
            firstVertex: null,
            insideContours: null,
            nextpeer: null,
            prevpeer: null
        };
    },
    CONTOUR_DIR: {
        CW_DIR: 0,
        CCW_DIR: 1,
        UNKNOWN_DIR: 2
    },
    DIR: {
        OUTSIDE_EDGE: -32767,
        INSIDE_EDGE: -32766
    },
    create: function create(imageWrapper, labelWrapper) {
        var imageData = imageWrapper.data,
            labelData = labelWrapper.data,
            width = imageWrapper.size.x,
            height = imageWrapper.size.y,
            tracer = __WEBPACK_IMPORTED_MODULE_0__tracer__["a" /* default */].create(imageWrapper, labelWrapper);

        return {
            rasterize: function rasterize(depthlabel) {
                var color,
                    bc,
                    lc,
                    labelindex,
                    cx,
                    cy,
                    colorMap = [],
                    vertex,
                    p,
                    cc,
                    sc,
                    pos,
                    connectedCount = 0,
                    i;

                for (i = 0; i < 400; i++) {
                    colorMap[i] = 0;
                }

                colorMap[0] = imageData[0];
                cc = null;
                for (cy = 1; cy < height - 1; cy++) {
                    labelindex = 0;
                    bc = colorMap[0];
                    for (cx = 1; cx < width - 1; cx++) {
                        pos = cy * width + cx;
                        if (labelData[pos] === 0) {
                            color = imageData[pos];
                            if (color !== bc) {
                                if (labelindex === 0) {
                                    lc = connectedCount + 1;
                                    colorMap[lc] = color;
                                    bc = color;
                                    vertex = tracer.contourTracing(cy, cx, lc, color, Rasterizer.DIR.OUTSIDE_EDGE);
                                    if (vertex !== null) {
                                        connectedCount++;
                                        labelindex = lc;
                                        p = Rasterizer.createContour2D();
                                        p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                                        p.index = labelindex;
                                        p.firstVertex = vertex;
                                        p.nextpeer = cc;
                                        p.insideContours = null;
                                        if (cc !== null) {
                                            cc.prevpeer = p;
                                        }
                                        cc = p;
                                    }
                                } else {
                                    vertex = tracer.contourTracing(cy, cx, Rasterizer.DIR.INSIDE_EDGE, color, labelindex);
                                    if (vertex !== null) {
                                        p = Rasterizer.createContour2D();
                                        p.firstVertex = vertex;
                                        p.insideContours = null;
                                        if (depthlabel === 0) {
                                            p.dir = Rasterizer.CONTOUR_DIR.CCW_DIR;
                                        } else {
                                            p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                                        }
                                        p.index = depthlabel;
                                        sc = cc;
                                        while (sc !== null && sc.index !== labelindex) {
                                            sc = sc.nextpeer;
                                        }
                                        if (sc !== null) {
                                            p.nextpeer = sc.insideContours;
                                            if (sc.insideContours !== null) {
                                                sc.insideContours.prevpeer = p;
                                            }
                                            sc.insideContours = p;
                                        }
                                    }
                                }
                            } else {
                                labelData[pos] = labelindex;
                            }
                        } else if (labelData[pos] === Rasterizer.DIR.OUTSIDE_EDGE || labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
                            labelindex = 0;
                            if (labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
                                bc = imageData[pos];
                            } else {
                                bc = colorMap[0];
                            }
                        } else {
                            labelindex = labelData[pos];
                            bc = colorMap[labelindex];
                        }
                    }
                }
                sc = cc;
                while (sc !== null) {
                    sc.index = depthlabel;
                    sc = sc.nextpeer;
                }
                return {
                    cc: cc,
                    count: connectedCount
                };
            },
            debug: {
                drawContour: function drawContour(canvas, firstContour) {
                    var ctx = canvas.getContext("2d"),
                        pq = firstContour,
                        iq,
                        q,
                        p;

                    ctx.strokeStyle = "red";
                    ctx.fillStyle = "red";
                    ctx.lineWidth = 1;

                    if (pq !== null) {
                        iq = pq.insideContours;
                    } else {
                        iq = null;
                    }

                    while (pq !== null) {
                        if (iq !== null) {
                            q = iq;
                            iq = iq.nextpeer;
                        } else {
                            q = pq;
                            pq = pq.nextpeer;
                            if (pq !== null) {
                                iq = pq.insideContours;
                            } else {
                                iq = null;
                            }
                        }

                        switch (q.dir) {
                            case Rasterizer.CONTOUR_DIR.CW_DIR:
                                ctx.strokeStyle = "red";
                                break;
                            case Rasterizer.CONTOUR_DIR.CCW_DIR:
                                ctx.strokeStyle = "blue";
                                break;
                            case Rasterizer.CONTOUR_DIR.UNKNOWN_DIR:
                                ctx.strokeStyle = "green";
                                break;
                        }

                        p = q.firstVertex;
                        ctx.beginPath();
                        ctx.moveTo(p.x, p.y);
                        do {
                            p = p.next;
                            ctx.lineTo(p.x, p.y);
                        } while (p !== q.firstVertex);
                        ctx.stroke();
                    }
                }
            }
        };
    }
};

/* harmony default export */ __webpack_exports__["a"] = (Rasterizer);

/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* @preserve ASM BEGIN */
/* eslint-disable eqeqeq*/
function Skeletonizer(stdlib, foreign, buffer) {
    "use asm";

    var images = new stdlib.Uint8Array(buffer),
        size = foreign.size | 0,
        imul = stdlib.Math.imul;

    function erode(inImagePtr, outImagePtr) {
        inImagePtr = inImagePtr | 0;
        outImagePtr = outImagePtr | 0;

        var v = 0,
            u = 0,
            sum = 0,
            yStart1 = 0,
            yStart2 = 0,
            xStart1 = 0,
            xStart2 = 0,
            offset = 0;

        for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
            offset = offset + size | 0;
            for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
                yStart1 = offset - size | 0;
                yStart2 = offset + size | 0;
                xStart1 = u - 1 | 0;
                xStart2 = u + 1 | 0;
                sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;
                if ((sum | 0) == (5 | 0)) {
                    images[outImagePtr + offset + u | 0] = 1;
                } else {
                    images[outImagePtr + offset + u | 0] = 0;
                }
            }
        }
        return;
    }

    function subtract(aImagePtr, bImagePtr, outImagePtr) {
        aImagePtr = aImagePtr | 0;
        bImagePtr = bImagePtr | 0;
        outImagePtr = outImagePtr | 0;

        var length = 0;

        length = imul(size, size) | 0;

        while ((length | 0) > 0) {
            length = length - 1 | 0;
            images[outImagePtr + length | 0] = (images[aImagePtr + length | 0] | 0) - (images[bImagePtr + length | 0] | 0) | 0;
        }
    }

    function bitwiseOr(aImagePtr, bImagePtr, outImagePtr) {
        aImagePtr = aImagePtr | 0;
        bImagePtr = bImagePtr | 0;
        outImagePtr = outImagePtr | 0;

        var length = 0;

        length = imul(size, size) | 0;

        while ((length | 0) > 0) {
            length = length - 1 | 0;
            images[outImagePtr + length | 0] = images[aImagePtr + length | 0] | 0 | (images[bImagePtr + length | 0] | 0) | 0;
        }
    }

    function countNonZero(imagePtr) {
        imagePtr = imagePtr | 0;

        var sum = 0,
            length = 0;

        length = imul(size, size) | 0;

        while ((length | 0) > 0) {
            length = length - 1 | 0;
            sum = (sum | 0) + (images[imagePtr + length | 0] | 0) | 0;
        }

        return sum | 0;
    }

    function init(imagePtr, value) {
        imagePtr = imagePtr | 0;
        value = value | 0;

        var length = 0;

        length = imul(size, size) | 0;

        while ((length | 0) > 0) {
            length = length - 1 | 0;
            images[imagePtr + length | 0] = value;
        }
    }

    function dilate(inImagePtr, outImagePtr) {
        inImagePtr = inImagePtr | 0;
        outImagePtr = outImagePtr | 0;

        var v = 0,
            u = 0,
            sum = 0,
            yStart1 = 0,
            yStart2 = 0,
            xStart1 = 0,
            xStart2 = 0,
            offset = 0;

        for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
            offset = offset + size | 0;
            for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
                yStart1 = offset - size | 0;
                yStart2 = offset + size | 0;
                xStart1 = u - 1 | 0;
                xStart2 = u + 1 | 0;
                sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;
                if ((sum | 0) > (0 | 0)) {
                    images[outImagePtr + offset + u | 0] = 1;
                } else {
                    images[outImagePtr + offset + u | 0] = 0;
                }
            }
        }
        return;
    }

    function memcpy(srcImagePtr, dstImagePtr) {
        srcImagePtr = srcImagePtr | 0;
        dstImagePtr = dstImagePtr | 0;

        var length = 0;

        length = imul(size, size) | 0;

        while ((length | 0) > 0) {
            length = length - 1 | 0;
            images[dstImagePtr + length | 0] = images[srcImagePtr + length | 0] | 0;
        }
    }

    function zeroBorder(imagePtr) {
        imagePtr = imagePtr | 0;

        var x = 0,
            y = 0;

        for (x = 0; (x | 0) < (size - 1 | 0); x = x + 1 | 0) {
            images[imagePtr + x | 0] = 0;
            images[imagePtr + y | 0] = 0;
            y = y + size - 1 | 0;
            images[imagePtr + y | 0] = 0;
            y = y + 1 | 0;
        }
        for (x = 0; (x | 0) < (size | 0); x = x + 1 | 0) {
            images[imagePtr + y | 0] = 0;
            y = y + 1 | 0;
        }
    }

    function skeletonize() {
        var subImagePtr = 0,
            erodedImagePtr = 0,
            tempImagePtr = 0,
            skelImagePtr = 0,
            sum = 0,
            done = 0;

        erodedImagePtr = imul(size, size) | 0;
        tempImagePtr = erodedImagePtr + erodedImagePtr | 0;
        skelImagePtr = tempImagePtr + erodedImagePtr | 0;

        // init skel-image
        init(skelImagePtr, 0);
        zeroBorder(subImagePtr);

        do {
            erode(subImagePtr, erodedImagePtr);
            dilate(erodedImagePtr, tempImagePtr);
            subtract(subImagePtr, tempImagePtr, tempImagePtr);
            bitwiseOr(skelImagePtr, tempImagePtr, skelImagePtr);
            memcpy(erodedImagePtr, subImagePtr);
            sum = countNonZero(subImagePtr) | 0;
            done = (sum | 0) == 0 | 0;
        } while (!done);
    }
    return {
        skeletonize: skeletonize
    };
}
/* @preserve ASM END */
/* harmony default export */ __webpack_exports__["a"] = (Skeletonizer);
/* eslint-enable eqeqeq*/

/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__barcode_reader__ = __webpack_require__(1);


function TwoOfFiveReader(opts) {
    __WEBPACK_IMPORTED_MODULE_0__barcode_reader__["a" /* default */].call(this, opts);
    this.barSpaceRatio = [1, 1];
}

var N = 1,
    W = 3,
    properties = {
    START_PATTERN: { value: [W, N, W, N, N, N] },
    STOP_PATTERN: { value: [W, N, N, N, W] },
    CODE_PATTERN: { value: [[N, N, W, W, N], [W, N, N, N, W], [N, W, N, N, W], [W, W, N, N, N], [N, N, W, N, W], [W, N, W, N, N], [N, W, W, N, N], [N, N, N, W, W], [W, N, N, W, N], [N, W, N, W, N]] },
    SINGLE_CODE_ERROR: { value: 0.78, writable: true },
    AVG_CODE_ERROR: { value: 0.30, writable: true },
    FORMAT: { value: "2of5" }
};

var startPatternLength = properties.START_PATTERN.value.reduce(function (sum, val) {
    return sum + val;
}, 0);

TwoOfFiveReader.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__barcode_reader__["a" /* default */].prototype, properties);
TwoOfFiveReader.prototype.constructor = TwoOfFiveReader;

TwoOfFiveReader.prototype._findPattern = function (pattern, offset, isWhite, tryHarder) {
    var counter = [],
        self = this,
        i,
        counterPos = 0,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
    },
        error,
        j,
        sum,
        epsilon = self.AVG_CODE_ERROR;

    isWhite = isWhite || false;
    tryHarder = tryHarder || false;

    if (!offset) {
        offset = self._nextSet(self._row);
    }

    for (i = 0; i < pattern.length; i++) {
        counter[i] = 0;
    }

    for (i = offset; i < self._row.length; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            if (counterPos === counter.length - 1) {
                sum = 0;
                for (j = 0; j < counter.length; j++) {
                    sum += counter[j];
                }
                error = self._matchPattern(counter, pattern);
                if (error < epsilon) {
                    bestMatch.error = error;
                    bestMatch.start = i - sum;
                    bestMatch.end = i;
                    return bestMatch;
                }
                if (tryHarder) {
                    for (j = 0; j < counter.length - 2; j++) {
                        counter[j] = counter[j + 2];
                    }
                    counter[counter.length - 2] = 0;
                    counter[counter.length - 1] = 0;
                    counterPos--;
                } else {
                    return null;
                }
            } else {
                counterPos++;
            }
            counter[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return null;
};

TwoOfFiveReader.prototype._findStart = function () {
    var self = this,
        leadingWhitespaceStart,
        offset = self._nextSet(self._row),
        startInfo,
        narrowBarWidth = 1;

    while (!startInfo) {
        startInfo = self._findPattern(self.START_PATTERN, offset, false, true);
        if (!startInfo) {
            return null;
        }
        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / startPatternLength);
        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 5;
        if (leadingWhitespaceStart >= 0) {
            if (self._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
                return startInfo;
            }
        }
        offset = startInfo.end;
        startInfo = null;
    }
};

TwoOfFiveReader.prototype._verifyTrailingWhitespace = function (endInfo) {
    var self = this,
        trailingWhitespaceEnd;

    trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;
    if (trailingWhitespaceEnd < self._row.length) {
        if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
            return endInfo;
        }
    }
    return null;
};

TwoOfFiveReader.prototype._findEnd = function () {
    var self = this,
        endInfo,
        tmp,
        offset;

    self._row.reverse();
    offset = self._nextSet(self._row);
    endInfo = self._findPattern(self.STOP_PATTERN, offset, false, true);
    self._row.reverse();

    if (endInfo === null) {
        return null;
    }

    // reverse numbers
    tmp = endInfo.start;
    endInfo.start = self._row.length - endInfo.end;
    endInfo.end = self._row.length - tmp;

    return endInfo !== null ? self._verifyTrailingWhitespace(endInfo) : null;
};

TwoOfFiveReader.prototype._decodeCode = function (counter) {
    var j,
        self = this,
        sum = 0,
        normalized,
        error,
        epsilon = self.AVG_CODE_ERROR,
        code,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
    };

    for (j = 0; j < counter.length; j++) {
        sum += counter[j];
    }
    for (code = 0; code < self.CODE_PATTERN.length; code++) {
        error = self._matchPattern(counter, self.CODE_PATTERN[code]);
        if (error < bestMatch.error) {
            bestMatch.code = code;
            bestMatch.error = error;
        }
    }
    if (bestMatch.error < epsilon) {
        return bestMatch;
    }
};

TwoOfFiveReader.prototype._decodePayload = function (counters, result, decodedCodes) {
    var i,
        self = this,
        pos = 0,
        counterLength = counters.length,
        counter = [0, 0, 0, 0, 0],
        code;

    while (pos < counterLength) {
        for (i = 0; i < 5; i++) {
            counter[i] = counters[pos] * this.barSpaceRatio[0];
            pos += 2;
        }
        code = self._decodeCode(counter);
        if (!code) {
            return null;
        }
        result.push(code.code + "");
        decodedCodes.push(code);
    }
    return code;
};

TwoOfFiveReader.prototype._verifyCounterLength = function (counters) {
    return counters.length % 10 === 0;
};

TwoOfFiveReader.prototype._decode = function () {
    var startInfo,
        endInfo,
        self = this,
        code,
        result = [],
        decodedCodes = [],
        counters;

    startInfo = self._findStart();
    if (!startInfo) {
        return null;
    }
    decodedCodes.push(startInfo);

    endInfo = self._findEnd();
    if (!endInfo) {
        return null;
    }

    counters = self._fillCounters(startInfo.end, endInfo.start, false);
    if (!self._verifyCounterLength(counters)) {
        return null;
    }
    code = self._decodePayload(counters, result, decodedCodes);
    if (!code) {
        return null;
    }
    if (result.length < 5) {
        return null;
    }

    decodedCodes.push(endInfo);
    return {
        code: result.join(""),
        start: startInfo.start,
        end: endInfo.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes
    };
};

/* harmony default export */ __webpack_exports__["a"] = (TwoOfFiveReader);

/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__barcode_reader__ = __webpack_require__(1);


function CodabarReader() {
    __WEBPACK_IMPORTED_MODULE_0__barcode_reader__["a" /* default */].call(this);
    this._counters = [];
}

var properties = {
    ALPHABETH_STRING: { value: "0123456789-$:/.+ABCD" },
    ALPHABET: { value: [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 45, 36, 58, 47, 46, 43, 65, 66, 67, 68] },
    CHARACTER_ENCODINGS: { value: [0x003, 0x006, 0x009, 0x060, 0x012, 0x042, 0x021, 0x024, 0x030, 0x048, 0x00c, 0x018, 0x045, 0x051, 0x054, 0x015, 0x01A, 0x029, 0x00B, 0x00E] },
    START_END: { value: [0x01A, 0x029, 0x00B, 0x00E] },
    MIN_ENCODED_CHARS: { value: 4 },
    MAX_ACCEPTABLE: { value: 2.0 },
    PADDING: { value: 1.5 },
    FORMAT: { value: "codabar", writeable: false }
};

CodabarReader.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__barcode_reader__["a" /* default */].prototype, properties);
CodabarReader.prototype.constructor = CodabarReader;

CodabarReader.prototype._decode = function () {
    var self = this,
        result = [],
        start,
        decodedChar,
        pattern,
        nextStart,
        end;

    this._counters = self._fillCounters();
    start = self._findStart();
    if (!start) {
        return null;
    }
    nextStart = start.startCounter;

    do {
        pattern = self._toPattern(nextStart);
        if (pattern < 0) {
            return null;
        }
        decodedChar = self._patternToChar(pattern);
        if (decodedChar < 0) {
            return null;
        }
        result.push(decodedChar);
        nextStart += 8;
        if (result.length > 1 && self._isStartEnd(pattern)) {
            break;
        }
    } while (nextStart < self._counters.length);

    // verify end
    if (result.length - 2 < self.MIN_ENCODED_CHARS || !self._isStartEnd(pattern)) {
        return null;
    }

    // verify end white space
    if (!self._verifyWhitespace(start.startCounter, nextStart - 8)) {
        return null;
    }

    if (!self._validateResult(result, start.startCounter)) {
        return null;
    }

    nextStart = nextStart > self._counters.length ? self._counters.length : nextStart;
    end = start.start + self._sumCounters(start.startCounter, nextStart - 8);

    return {
        code: result.join(""),
        start: start.start,
        end: end,
        startInfo: start,
        decodedCodes: result
    };
};

CodabarReader.prototype._verifyWhitespace = function (startCounter, endCounter) {
    if (startCounter - 1 <= 0 || this._counters[startCounter - 1] >= this._calculatePatternLength(startCounter) / 2.0) {
        if (endCounter + 8 >= this._counters.length || this._counters[endCounter + 7] >= this._calculatePatternLength(endCounter) / 2.0) {
            return true;
        }
    }
    return false;
};

CodabarReader.prototype._calculatePatternLength = function (offset) {
    var i,
        sum = 0;

    for (i = offset; i < offset + 7; i++) {
        sum += this._counters[i];
    }

    return sum;
};

CodabarReader.prototype._thresholdResultPattern = function (result, startCounter) {
    var self = this,
        categorization = {
        space: {
            narrow: { size: 0, counts: 0, min: 0, max: Number.MAX_VALUE },
            wide: { size: 0, counts: 0, min: 0, max: Number.MAX_VALUE }
        },
        bar: {
            narrow: { size: 0, counts: 0, min: 0, max: Number.MAX_VALUE },
            wide: { size: 0, counts: 0, min: 0, max: Number.MAX_VALUE }
        }
    },
        kind,
        cat,
        i,
        j,
        pos = startCounter,
        pattern;

    for (i = 0; i < result.length; i++) {
        pattern = self._charToPattern(result[i]);
        for (j = 6; j >= 0; j--) {
            kind = (j & 1) === 2 ? categorization.bar : categorization.space;
            cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
            cat.size += self._counters[pos + j];
            cat.counts++;
            pattern >>= 1;
        }
        pos += 8;
    }

    ["space", "bar"].forEach(function (key) {
        var newkind = categorization[key];
        newkind.wide.min = Math.floor((newkind.narrow.size / newkind.narrow.counts + newkind.wide.size / newkind.wide.counts) / 2);
        newkind.narrow.max = Math.ceil(newkind.wide.min);
        newkind.wide.max = Math.ceil((newkind.wide.size * self.MAX_ACCEPTABLE + self.PADDING) / newkind.wide.counts);
    });

    return categorization;
};

CodabarReader.prototype._charToPattern = function (char) {
    var self = this,
        charCode = char.charCodeAt(0),
        i;

    for (i = 0; i < self.ALPHABET.length; i++) {
        if (self.ALPHABET[i] === charCode) {
            return self.CHARACTER_ENCODINGS[i];
        }
    }
    return 0x0;
};

CodabarReader.prototype._validateResult = function (result, startCounter) {
    var self = this,
        thresholds = self._thresholdResultPattern(result, startCounter),
        i,
        j,
        kind,
        cat,
        size,
        pos = startCounter,
        pattern;

    for (i = 0; i < result.length; i++) {
        pattern = self._charToPattern(result[i]);
        for (j = 6; j >= 0; j--) {
            kind = (j & 1) === 0 ? thresholds.bar : thresholds.space;
            cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
            size = self._counters[pos + j];
            if (size < cat.min || size > cat.max) {
                return false;
            }
            pattern >>= 1;
        }
        pos += 8;
    }
    return true;
};

CodabarReader.prototype._patternToChar = function (pattern) {
    var i,
        self = this;

    for (i = 0; i < self.CHARACTER_ENCODINGS.length; i++) {
        if (self.CHARACTER_ENCODINGS[i] === pattern) {
            return String.fromCharCode(self.ALPHABET[i]);
        }
    }
    return -1;
};

CodabarReader.prototype._computeAlternatingThreshold = function (offset, end) {
    var i,
        min = Number.MAX_VALUE,
        max = 0,
        counter;

    for (i = offset; i < end; i += 2) {
        counter = this._counters[i];
        if (counter > max) {
            max = counter;
        }
        if (counter < min) {
            min = counter;
        }
    }

    return (min + max) / 2.0 | 0;
};

CodabarReader.prototype._toPattern = function (offset) {
    var numCounters = 7,
        end = offset + numCounters,
        barThreshold,
        spaceThreshold,
        bitmask = 1 << numCounters - 1,
        pattern = 0,
        i,
        threshold;

    if (end > this._counters.length) {
        return -1;
    }

    barThreshold = this._computeAlternatingThreshold(offset, end);
    spaceThreshold = this._computeAlternatingThreshold(offset + 1, end);

    for (i = 0; i < numCounters; i++) {
        threshold = (i & 1) === 0 ? barThreshold : spaceThreshold;
        if (this._counters[offset + i] > threshold) {
            pattern |= bitmask;
        }
        bitmask >>= 1;
    }

    return pattern;
};

CodabarReader.prototype._isStartEnd = function (pattern) {
    var i;

    for (i = 0; i < this.START_END.length; i++) {
        if (this.START_END[i] === pattern) {
            return true;
        }
    }
    return false;
};

CodabarReader.prototype._sumCounters = function (start, end) {
    var i,
        sum = 0;

    for (i = start; i < end; i++) {
        sum += this._counters[i];
    }
    return sum;
};

CodabarReader.prototype._findStart = function () {
    var self = this,
        i,
        pattern,
        start = self._nextUnset(self._row),
        end;

    for (i = 1; i < this._counters.length; i++) {
        pattern = self._toPattern(i);
        if (pattern !== -1 && self._isStartEnd(pattern)) {
            // TODO: Look for whitespace ahead
            start += self._sumCounters(0, i);
            end = start + self._sumCounters(i, i + 8);
            return {
                start: start,
                end: end,
                startCounter: i,
                endCounter: i + 8
            };
        }
    }
};

/* harmony default export */ __webpack_exports__["a"] = (CodabarReader);

/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__barcode_reader__ = __webpack_require__(1);


function Code128Reader() {
    __WEBPACK_IMPORTED_MODULE_0__barcode_reader__["a" /* default */].call(this);
}

var properties = {
    CODE_SHIFT: { value: 98 },
    CODE_C: { value: 99 },
    CODE_B: { value: 100 },
    CODE_A: { value: 101 },
    START_CODE_A: { value: 103 },
    START_CODE_B: { value: 104 },
    START_CODE_C: { value: 105 },
    STOP_CODE: { value: 106 },
    CODE_PATTERN: { value: [[2, 1, 2, 2, 2, 2], [2, 2, 2, 1, 2, 2], [2, 2, 2, 2, 2, 1], [1, 2, 1, 2, 2, 3], [1, 2, 1, 3, 2, 2], [1, 3, 1, 2, 2, 2], [1, 2, 2, 2, 1, 3], [1, 2, 2, 3, 1, 2], [1, 3, 2, 2, 1, 2], [2, 2, 1, 2, 1, 3], [2, 2, 1, 3, 1, 2], [2, 3, 1, 2, 1, 2], [1, 1, 2, 2, 3, 2], [1, 2, 2, 1, 3, 2], [1, 2, 2, 2, 3, 1], [1, 1, 3, 2, 2, 2], [1, 2, 3, 1, 2, 2], [1, 2, 3, 2, 2, 1], [2, 2, 3, 2, 1, 1], [2, 2, 1, 1, 3, 2], [2, 2, 1, 2, 3, 1], [2, 1, 3, 2, 1, 2], [2, 2, 3, 1, 1, 2], [3, 1, 2, 1, 3, 1], [3, 1, 1, 2, 2, 2], [3, 2, 1, 1, 2, 2], [3, 2, 1, 2, 2, 1], [3, 1, 2, 2, 1, 2], [3, 2, 2, 1, 1, 2], [3, 2, 2, 2, 1, 1], [2, 1, 2, 1, 2, 3], [2, 1, 2, 3, 2, 1], [2, 3, 2, 1, 2, 1], [1, 1, 1, 3, 2, 3], [1, 3, 1, 1, 2, 3], [1, 3, 1, 3, 2, 1], [1, 1, 2, 3, 1, 3], [1, 3, 2, 1, 1, 3], [1, 3, 2, 3, 1, 1], [2, 1, 1, 3, 1, 3], [2, 3, 1, 1, 1, 3], [2, 3, 1, 3, 1, 1], [1, 1, 2, 1, 3, 3], [1, 1, 2, 3, 3, 1], [1, 3, 2, 1, 3, 1], [1, 1, 3, 1, 2, 3], [1, 1, 3, 3, 2, 1], [1, 3, 3, 1, 2, 1], [3, 1, 3, 1, 2, 1], [2, 1, 1, 3, 3, 1], [2, 3, 1, 1, 3, 1], [2, 1, 3, 1, 1, 3], [2, 1, 3, 3, 1, 1], [2, 1, 3, 1, 3, 1], [3, 1, 1, 1, 2, 3], [3, 1, 1, 3, 2, 1], [3, 3, 1, 1, 2, 1], [3, 1, 2, 1, 1, 3], [3, 1, 2, 3, 1, 1], [3, 3, 2, 1, 1, 1], [3, 1, 4, 1, 1, 1], [2, 2, 1, 4, 1, 1], [4, 3, 1, 1, 1, 1], [1, 1, 1, 2, 2, 4], [1, 1, 1, 4, 2, 2], [1, 2, 1, 1, 2, 4], [1, 2, 1, 4, 2, 1], [1, 4, 1, 1, 2, 2], [1, 4, 1, 2, 2, 1], [1, 1, 2, 2, 1, 4], [1, 1, 2, 4, 1, 2], [1, 2, 2, 1, 1, 4], [1, 2, 2, 4, 1, 1], [1, 4, 2, 1, 1, 2], [1, 4, 2, 2, 1, 1], [2, 4, 1, 2, 1, 1], [2, 2, 1, 1, 1, 4], [4, 1, 3, 1, 1, 1], [2, 4, 1, 1, 1, 2], [1, 3, 4, 1, 1, 1], [1, 1, 1, 2, 4, 2], [1, 2, 1, 1, 4, 2], [1, 2, 1, 2, 4, 1], [1, 1, 4, 2, 1, 2], [1, 2, 4, 1, 1, 2], [1, 2, 4, 2, 1, 1], [4, 1, 1, 2, 1, 2], [4, 2, 1, 1, 1, 2], [4, 2, 1, 2, 1, 1], [2, 1, 2, 1, 4, 1], [2, 1, 4, 1, 2, 1], [4, 1, 2, 1, 2, 1], [1, 1, 1, 1, 4, 3], [1, 1, 1, 3, 4, 1], [1, 3, 1, 1, 4, 1], [1, 1, 4, 1, 1, 3], [1, 1, 4, 3, 1, 1], [4, 1, 1, 1, 1, 3], [4, 1, 1, 3, 1, 1], [1, 1, 3, 1, 4, 1], [1, 1, 4, 1, 3, 1], [3, 1, 1, 1, 4, 1], [4, 1, 1, 1, 3, 1], [2, 1, 1, 4, 1, 2], [2, 1, 1, 2, 1, 4], [2, 1, 1, 2, 3, 2], [2, 3, 3, 1, 1, 1, 2]] },
    SINGLE_CODE_ERROR: { value: 0.64 },
    AVG_CODE_ERROR: { value: 0.30 },
    FORMAT: { value: "code_128", writeable: false },
    MODULE_INDICES: { value: { bar: [0, 2, 4], space: [1, 3, 5] } }
};

Code128Reader.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__barcode_reader__["a" /* default */].prototype, properties);
Code128Reader.prototype.constructor = Code128Reader;

Code128Reader.prototype._decodeCode = function (start, correction) {
    var counter = [0, 0, 0, 0, 0, 0],
        i,
        self = this,
        offset = start,
        isWhite = !self._row[offset],
        counterPos = 0,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: start,
        end: start,
        correction: {
            bar: 1,
            space: 1
        }
    },
        code,
        error;

    for (i = offset; i < self._row.length; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            if (counterPos === counter.length - 1) {
                if (correction) {
                    self._correct(counter, correction);
                }
                for (code = 0; code < self.CODE_PATTERN.length; code++) {
                    error = self._matchPattern(counter, self.CODE_PATTERN[code]);
                    if (error < bestMatch.error) {
                        bestMatch.code = code;
                        bestMatch.error = error;
                    }
                }
                bestMatch.end = i;
                if (bestMatch.code === -1 || bestMatch.error > self.AVG_CODE_ERROR) {
                    return null;
                }
                if (self.CODE_PATTERN[bestMatch.code]) {
                    bestMatch.correction.bar = calculateCorrection(self.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
                    bestMatch.correction.space = calculateCorrection(self.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
                }
                return bestMatch;
            } else {
                counterPos++;
            }
            counter[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return null;
};

Code128Reader.prototype._correct = function (counter, correction) {
    this._correctBars(counter, correction.bar, this.MODULE_INDICES.bar);
    this._correctBars(counter, correction.space, this.MODULE_INDICES.space);
};

Code128Reader.prototype._findStart = function () {
    var counter = [0, 0, 0, 0, 0, 0],
        i,
        self = this,
        offset = self._nextSet(self._row),
        isWhite = false,
        counterPos = 0,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0,
        correction: {
            bar: 1,
            space: 1
        }
    },
        code,
        error,
        j,
        sum;

    for (i = offset; i < self._row.length; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            if (counterPos === counter.length - 1) {
                sum = 0;
                for (j = 0; j < counter.length; j++) {
                    sum += counter[j];
                }
                for (code = self.START_CODE_A; code <= self.START_CODE_C; code++) {
                    error = self._matchPattern(counter, self.CODE_PATTERN[code]);
                    if (error < bestMatch.error) {
                        bestMatch.code = code;
                        bestMatch.error = error;
                    }
                }
                if (bestMatch.error < self.AVG_CODE_ERROR) {
                    bestMatch.start = i - sum;
                    bestMatch.end = i;
                    bestMatch.correction.bar = calculateCorrection(self.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
                    bestMatch.correction.space = calculateCorrection(self.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
                    return bestMatch;
                }

                for (j = 0; j < 4; j++) {
                    counter[j] = counter[j + 2];
                }
                counter[4] = 0;
                counter[5] = 0;
                counterPos--;
            } else {
                counterPos++;
            }
            counter[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return null;
};

Code128Reader.prototype._decode = function () {
    var self = this,
        startInfo = self._findStart(),
        code = null,
        done = false,
        result = [],
        multiplier = 0,
        checksum = 0,
        codeset,
        rawResult = [],
        decodedCodes = [],
        shiftNext = false,
        unshift,
        removeLastCharacter = true;

    if (startInfo === null) {
        return null;
    }
    code = {
        code: startInfo.code,
        start: startInfo.start,
        end: startInfo.end,
        correction: {
            bar: startInfo.correction.bar,
            space: startInfo.correction.space
        }
    };
    decodedCodes.push(code);
    checksum = code.code;
    switch (code.code) {
        case self.START_CODE_A:
            codeset = self.CODE_A;
            break;
        case self.START_CODE_B:
            codeset = self.CODE_B;
            break;
        case self.START_CODE_C:
            codeset = self.CODE_C;
            break;
        default:
            return null;
    }

    while (!done) {
        unshift = shiftNext;
        shiftNext = false;
        code = self._decodeCode(code.end, code.correction);
        if (code !== null) {
            if (code.code !== self.STOP_CODE) {
                removeLastCharacter = true;
            }

            if (code.code !== self.STOP_CODE) {
                rawResult.push(code.code);
                multiplier++;
                checksum += multiplier * code.code;
            }
            decodedCodes.push(code);

            switch (codeset) {
                case self.CODE_A:
                    if (code.code < 64) {
                        result.push(String.fromCharCode(32 + code.code));
                    } else if (code.code < 96) {
                        result.push(String.fromCharCode(code.code - 64));
                    } else {
                        if (code.code !== self.STOP_CODE) {
                            removeLastCharacter = false;
                        }
                        switch (code.code) {
                            case self.CODE_SHIFT:
                                shiftNext = true;
                                codeset = self.CODE_B;
                                break;
                            case self.CODE_B:
                                codeset = self.CODE_B;
                                break;
                            case self.CODE_C:
                                codeset = self.CODE_C;
                                break;
                            case self.STOP_CODE:
                                done = true;
                                break;
                        }
                    }
                    break;
                case self.CODE_B:
                    if (code.code < 96) {
                        result.push(String.fromCharCode(32 + code.code));
                    } else {
                        if (code.code !== self.STOP_CODE) {
                            removeLastCharacter = false;
                        }
                        switch (code.code) {
                            case self.CODE_SHIFT:
                                shiftNext = true;
                                codeset = self.CODE_A;
                                break;
                            case self.CODE_A:
                                codeset = self.CODE_A;
                                break;
                            case self.CODE_C:
                                codeset = self.CODE_C;
                                break;
                            case self.STOP_CODE:
                                done = true;
                                break;
                        }
                    }
                    break;
                case self.CODE_C:
                    if (code.code < 100) {
                        result.push(code.code < 10 ? "0" + code.code : code.code);
                    } else {
                        if (code.code !== self.STOP_CODE) {
                            removeLastCharacter = false;
                        }
                        switch (code.code) {
                            case self.CODE_A:
                                codeset = self.CODE_A;
                                break;
                            case self.CODE_B:
                                codeset = self.CODE_B;
                                break;
                            case self.STOP_CODE:
                                done = true;
                                break;
                        }
                    }
                    break;
            }
        } else {
            done = true;
        }
        if (unshift) {
            codeset = codeset === self.CODE_A ? self.CODE_B : self.CODE_A;
        }
    }

    if (code === null) {
        return null;
    }

    code.end = self._nextUnset(self._row, code.end);
    if (!self._verifyTrailingWhitespace(code)) {
        return null;
    }

    checksum -= multiplier * rawResult[rawResult.length - 1];
    if (checksum % 103 !== rawResult[rawResult.length - 1]) {
        return null;
    }

    if (!result.length) {
        return null;
    }

    // remove last code from result (checksum)
    if (removeLastCharacter) {
        result.splice(result.length - 1, 1);
    }

    return {
        code: result.join(""),
        start: startInfo.start,
        end: code.end,
        codeset: codeset,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        endInfo: code
    };
};

__WEBPACK_IMPORTED_MODULE_0__barcode_reader__["a" /* default */].prototype._verifyTrailingWhitespace = function (endInfo) {
    var self = this,
        trailingWhitespaceEnd;

    trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;
    if (trailingWhitespaceEnd < self._row.length) {
        if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
            return endInfo;
        }
    }
    return null;
};

function calculateCorrection(expected, normalized, indices) {
    var length = indices.length,
        sumNormalized = 0,
        sumExpected = 0;

    while (length--) {
        sumExpected += expected[indices[length]];
        sumNormalized += normalized[indices[length]];
    }
    return sumExpected / sumNormalized;
}

/* harmony default export */ __webpack_exports__["a"] = (Code128Reader);

/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__code_39_reader__ = __webpack_require__(31);


function Code39VINReader() {
    __WEBPACK_IMPORTED_MODULE_0__code_39_reader__["a" /* default */].call(this);
}

var patterns = {
    IOQ: /[IOQ]/g,
    AZ09: /[A-Z0-9]{17}/
};

Code39VINReader.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__code_39_reader__["a" /* default */].prototype);
Code39VINReader.prototype.constructor = Code39VINReader;

// Cribbed from:
// https://github.com/zxing/zxing/blob/master/core/src/main/java/com/google/zxing/client/result/VINResultParser.java
Code39VINReader.prototype._decode = function () {
    var result = __WEBPACK_IMPORTED_MODULE_0__code_39_reader__["a" /* default */].prototype._decode.apply(this);
    if (!result) {
        return null;
    }

    var code = result.code;

    if (!code) {
        return null;
    }

    code = code.replace(patterns.IOQ, '');

    if (!code.match(patterns.AZ09)) {
        if (true) {
            console.log('Failed AZ09 pattern code:', code);
        }
        return null;
    }

    if (!this._checkChecksum(code)) {
        return null;
    }

    result.code = code;
    return result;
};

Code39VINReader.prototype._checkChecksum = function (code) {
    // TODO
    return !!code;
};

/* harmony default export */ __webpack_exports__["a"] = (Code39VINReader);

/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__barcode_reader__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_array_helper__ = __webpack_require__(3);



function Code93Reader() {
    __WEBPACK_IMPORTED_MODULE_0__barcode_reader__["a" /* default */].call(this);
}

var ALPHABETH_STRING = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%abcd*";

var properties = {
    ALPHABETH_STRING: { value: ALPHABETH_STRING },
    ALPHABET: { value: ALPHABETH_STRING.split('').map(function (char) {
            return char.charCodeAt(0);
        }) },
    CHARACTER_ENCODINGS: { value: [0x114, 0x148, 0x144, 0x142, 0x128, 0x124, 0x122, 0x150, 0x112, 0x10A, 0x1A8, 0x1A4, 0x1A2, 0x194, 0x192, 0x18A, 0x168, 0x164, 0x162, 0x134, 0x11A, 0x158, 0x14C, 0x146, 0x12C, 0x116, 0x1B4, 0x1B2, 0x1AC, 0x1A6, 0x196, 0x19A, 0x16C, 0x166, 0x136, 0x13A, 0x12E, 0x1D4, 0x1D2, 0x1CA, 0x16E, 0x176, 0x1AE, 0x126, 0x1DA, 0x1D6, 0x132, 0x15E] },
    ASTERISK: { value: 0x15E },
    FORMAT: { value: "code_93", writeable: false }
};

Code93Reader.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__barcode_reader__["a" /* default */].prototype, properties);
Code93Reader.prototype.constructor = Code93Reader;

Code93Reader.prototype._decode = function () {
    var self = this,
        counters = [0, 0, 0, 0, 0, 0],
        result = [],
        start = self._findStart(),
        decodedChar,
        lastStart,
        pattern,
        nextStart;

    if (!start) {
        return null;
    }
    nextStart = self._nextSet(self._row, start.end);

    do {
        counters = self._toCounters(nextStart, counters);
        pattern = self._toPattern(counters);
        if (pattern < 0) {
            return null;
        }
        decodedChar = self._patternToChar(pattern);
        if (decodedChar < 0) {
            return null;
        }
        result.push(decodedChar);
        lastStart = nextStart;
        nextStart += __WEBPACK_IMPORTED_MODULE_1__common_array_helper__["a" /* default */].sum(counters);
        nextStart = self._nextSet(self._row, nextStart);
    } while (decodedChar !== '*');
    result.pop();

    if (!result.length) {
        return null;
    }

    if (!self._verifyEnd(lastStart, nextStart, counters)) {
        return null;
    }

    if (!self._verifyChecksums(result)) {
        return null;
    }

    result = result.slice(0, result.length - 2);
    if ((result = self._decodeExtended(result)) === null) {
        return null;
    };

    return {
        code: result.join(""),
        start: start.start,
        end: nextStart,
        startInfo: start,
        decodedCodes: result
    };
};

Code93Reader.prototype._verifyEnd = function (lastStart, nextStart) {
    if (lastStart === nextStart || !this._row[nextStart]) {
        return false;
    }
    return true;
};

Code93Reader.prototype._patternToChar = function (pattern) {
    var i,
        self = this;

    for (i = 0; i < self.CHARACTER_ENCODINGS.length; i++) {
        if (self.CHARACTER_ENCODINGS[i] === pattern) {
            return String.fromCharCode(self.ALPHABET[i]);
        }
    }
    return -1;
};

Code93Reader.prototype._toPattern = function (counters) {
    var numCounters = counters.length;
    var pattern = 0;
    var sum = 0;
    for (var i = 0; i < numCounters; i++) {
        sum += counters[i];
    }

    for (var _i = 0; _i < numCounters; _i++) {
        var normalized = Math.round(counters[_i] * 9 / sum);
        if (normalized < 1 || normalized > 4) {
            return -1;
        }
        if ((_i & 1) === 0) {
            for (var j = 0; j < normalized; j++) {
                pattern = pattern << 1 | 1;
            }
        } else {
            pattern <<= normalized;
        }
    }

    return pattern;
};

Code93Reader.prototype._findStart = function () {
    var self = this,
        offset = self._nextSet(self._row),
        patternStart = offset,
        counter = [0, 0, 0, 0, 0, 0],
        counterPos = 0,
        isWhite = false,
        i,
        j,
        whiteSpaceMustStart;

    for (i = offset; i < self._row.length; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            if (counterPos === counter.length - 1) {
                // find start pattern
                if (self._toPattern(counter) === self.ASTERISK) {
                    whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));
                    if (self._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                        return {
                            start: patternStart,
                            end: i
                        };
                    }
                }

                patternStart += counter[0] + counter[1];
                for (j = 0; j < 4; j++) {
                    counter[j] = counter[j + 2];
                }
                counter[4] = 0;
                counter[5] = 0;
                counterPos--;
            } else {
                counterPos++;
            }
            counter[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return null;
};

Code93Reader.prototype._decodeExtended = function (charArray) {
    var length = charArray.length;
    var result = [];
    for (var i = 0; i < length; i++) {
        var char = charArray[i];
        if (char >= 'a' && char <= 'd') {
            if (i > length - 2) {
                return null;
            }
            var nextChar = charArray[++i];
            var nextCharCode = nextChar.charCodeAt(0);
            var decodedChar = void 0;
            switch (char) {
                case 'a':
                    if (nextChar >= 'A' && nextChar <= 'Z') {
                        decodedChar = String.fromCharCode(nextCharCode - 64);
                    } else {
                        return null;
                    }
                    break;
                case 'b':
                    if (nextChar >= 'A' && nextChar <= 'E') {
                        decodedChar = String.fromCharCode(nextCharCode - 38);
                    } else if (nextChar >= 'F' && nextChar <= 'J') {
                        decodedChar = String.fromCharCode(nextCharCode - 11);
                    } else if (nextChar >= 'K' && nextChar <= 'O') {
                        decodedChar = String.fromCharCode(nextCharCode + 16);
                    } else if (nextChar >= 'P' && nextChar <= 'S') {
                        decodedChar = String.fromCharCode(nextCharCode + 43);
                    } else if (nextChar >= 'T' && nextChar <= 'Z') {
                        decodedChar = String.fromCharCode(127);
                    } else {
                        return null;
                    }
                    break;
                case 'c':
                    if (nextChar >= 'A' && nextChar <= 'O') {
                        decodedChar = String.fromCharCode(nextCharCode - 32);
                    } else if (nextChar === 'Z') {
                        decodedChar = ':';
                    } else {
                        return null;
                    }
                    break;
                case 'd':
                    if (nextChar >= 'A' && nextChar <= 'Z') {
                        decodedChar = String.fromCharCode(nextCharCode + 32);
                    } else {
                        return null;
                    }
                    break;
            }
            result.push(decodedChar);
        } else {
            result.push(char);
        }
    }
    return result;
};

Code93Reader.prototype._verifyChecksums = function (charArray) {
    return this._matchCheckChar(charArray, charArray.length - 2, 20) && this._matchCheckChar(charArray, charArray.length - 1, 15);
};

Code93Reader.prototype._matchCheckChar = function (charArray, index, maxWeight) {
    var _this = this;

    var arrayToCheck = charArray.slice(0, index);
    var length = arrayToCheck.length;
    var weightedSums = arrayToCheck.reduce(function (sum, char, i) {
        var weight = (i * -1 + (length - 1)) % maxWeight + 1;
        var value = _this.ALPHABET.indexOf(char.charCodeAt(0));
        return sum + weight * value;
    }, 0);

    var checkChar = this.ALPHABET[weightedSums % 47];
    return checkChar === charArray[index].charCodeAt(0);
};

/* harmony default export */ __webpack_exports__["a"] = (Code93Reader);

/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ean_reader__ = __webpack_require__(4);


function EAN2Reader() {
    __WEBPACK_IMPORTED_MODULE_0__ean_reader__["a" /* default */].call(this);
}

var properties = {
    FORMAT: { value: "ean_2", writeable: false }
};

EAN2Reader.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__ean_reader__["a" /* default */].prototype, properties);
EAN2Reader.prototype.constructor = EAN2Reader;

EAN2Reader.prototype.decode = function (row, start) {
    this._row = row;
    var counters = [0, 0, 0, 0],
        codeFrequency = 0,
        i = 0,
        offset = start,
        end = this._row.length,
        code,
        result = [],
        decodedCodes = [];

    for (i = 0; i < 2 && offset < end; i++) {
        code = this._decodeCode(offset);
        if (!code) {
            return null;
        }
        decodedCodes.push(code);
        result.push(code.code % 10);
        if (code.code >= this.CODE_G_START) {
            codeFrequency |= 1 << 1 - i;
        }
        if (i != 1) {
            offset = this._nextSet(this._row, code.end);
            offset = this._nextUnset(this._row, offset);
        }
    }

    if (result.length != 2 || parseInt(result.join("")) % 4 !== codeFrequency) {
        return null;
    }
    return {
        code: result.join(""),
        decodedCodes: decodedCodes,
        end: code.end
    };
};

/* harmony default export */ __webpack_exports__["a"] = (EAN2Reader);

/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ean_reader__ = __webpack_require__(4);


function EAN5Reader() {
    __WEBPACK_IMPORTED_MODULE_0__ean_reader__["a" /* default */].call(this);
}

var properties = {
    FORMAT: { value: "ean_5", writeable: false }
};

var CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5];

EAN5Reader.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__ean_reader__["a" /* default */].prototype, properties);
EAN5Reader.prototype.constructor = EAN5Reader;

EAN5Reader.prototype.decode = function (row, start) {
    this._row = row;
    var counters = [0, 0, 0, 0],
        codeFrequency = 0,
        i = 0,
        offset = start,
        end = this._row.length,
        code,
        result = [],
        decodedCodes = [];

    for (i = 0; i < 5 && offset < end; i++) {
        code = this._decodeCode(offset);
        if (!code) {
            return null;
        }
        decodedCodes.push(code);
        result.push(code.code % 10);
        if (code.code >= this.CODE_G_START) {
            codeFrequency |= 1 << 4 - i;
        }
        if (i != 4) {
            offset = this._nextSet(this._row, code.end);
            offset = this._nextUnset(this._row, offset);
        }
    }

    if (result.length != 5) {
        return null;
    }

    if (extensionChecksum(result) !== determineCheckDigit(codeFrequency)) {
        return null;
    }
    return {
        code: result.join(""),
        decodedCodes: decodedCodes,
        end: code.end
    };
};

function determineCheckDigit(codeFrequency) {
    var i;
    for (i = 0; i < 10; i++) {
        if (codeFrequency === CHECK_DIGIT_ENCODINGS[i]) {
            return i;
        }
    }
    return null;
}

function extensionChecksum(result) {
    var length = result.length,
        sum = 0,
        i;

    for (i = length - 2; i >= 0; i -= 2) {
        sum += result[i];
    }
    sum *= 3;
    for (i = length - 1; i >= 0; i -= 2) {
        sum += result[i];
    }
    sum *= 3;
    return sum % 10;
}

/* harmony default export */ __webpack_exports__["a"] = (EAN5Reader);

/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ean_reader__ = __webpack_require__(4);


function EAN8Reader(opts, supplements) {
    __WEBPACK_IMPORTED_MODULE_0__ean_reader__["a" /* default */].call(this, opts, supplements);
}

var properties = {
    FORMAT: { value: "ean_8", writeable: false }
};

EAN8Reader.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__ean_reader__["a" /* default */].prototype, properties);
EAN8Reader.prototype.constructor = EAN8Reader;

EAN8Reader.prototype._decodePayload = function (code, result, decodedCodes) {
    var i,
        self = this;

    for (i = 0; i < 4; i++) {
        code = self._decodeCode(code.end, self.CODE_G_START);
        if (!code) {
            return null;
        }
        result.push(code.code);
        decodedCodes.push(code);
    }

    code = self._findPattern(self.MIDDLE_PATTERN, code.end, true, false);
    if (code === null) {
        return null;
    }
    decodedCodes.push(code);

    for (i = 0; i < 4; i++) {
        code = self._decodeCode(code.end, self.CODE_G_START);
        if (!code) {
            return null;
        }
        decodedCodes.push(code);
        result.push(code.code);
    }

    return code;
};

/* harmony default export */ __webpack_exports__["a"] = (EAN8Reader);

/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_merge__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_merge___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash_merge__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__barcode_reader__ = __webpack_require__(1);




function I2of5Reader(opts) {
    opts = __WEBPACK_IMPORTED_MODULE_0_lodash_merge___default()(getDefaulConfig(), opts);
    __WEBPACK_IMPORTED_MODULE_1__barcode_reader__["a" /* default */].call(this, opts);
    this.barSpaceRatio = [1, 1];
    if (opts.normalizeBarSpaceWidth) {
        this.SINGLE_CODE_ERROR = 0.38;
        this.AVG_CODE_ERROR = 0.09;
    }
}

function getDefaulConfig() {
    var config = {};

    Object.keys(I2of5Reader.CONFIG_KEYS).forEach(function (key) {
        config[key] = I2of5Reader.CONFIG_KEYS[key].default;
    });
    return config;
}

var N = 1,
    W = 3,
    properties = {
    START_PATTERN: { value: [N, N, N, N] },
    STOP_PATTERN: { value: [N, N, W] },
    CODE_PATTERN: { value: [[N, N, W, W, N], [W, N, N, N, W], [N, W, N, N, W], [W, W, N, N, N], [N, N, W, N, W], [W, N, W, N, N], [N, W, W, N, N], [N, N, N, W, W], [W, N, N, W, N], [N, W, N, W, N]] },
    SINGLE_CODE_ERROR: { value: 0.78, writable: true },
    AVG_CODE_ERROR: { value: 0.38, writable: true },
    MAX_CORRECTION_FACTOR: { value: 5 },
    FORMAT: { value: "i2of5" }
};

I2of5Reader.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_1__barcode_reader__["a" /* default */].prototype, properties);
I2of5Reader.prototype.constructor = I2of5Reader;

I2of5Reader.prototype._matchPattern = function (counter, code) {
    if (this.config.normalizeBarSpaceWidth) {
        var i,
            counterSum = [0, 0],
            codeSum = [0, 0],
            correction = [0, 0],
            correctionRatio = this.MAX_CORRECTION_FACTOR,
            correctionRatioInverse = 1 / correctionRatio;

        for (i = 0; i < counter.length; i++) {
            counterSum[i % 2] += counter[i];
            codeSum[i % 2] += code[i];
        }
        correction[0] = codeSum[0] / counterSum[0];
        correction[1] = codeSum[1] / counterSum[1];

        correction[0] = Math.max(Math.min(correction[0], correctionRatio), correctionRatioInverse);
        correction[1] = Math.max(Math.min(correction[1], correctionRatio), correctionRatioInverse);
        this.barSpaceRatio = correction;
        for (i = 0; i < counter.length; i++) {
            counter[i] *= this.barSpaceRatio[i % 2];
        }
    }
    return __WEBPACK_IMPORTED_MODULE_1__barcode_reader__["a" /* default */].prototype._matchPattern.call(this, counter, code);
};

I2of5Reader.prototype._findPattern = function (pattern, offset, isWhite, tryHarder) {
    var counter = [],
        self = this,
        i,
        counterPos = 0,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
    },
        error,
        j,
        sum,
        normalized,
        epsilon = self.AVG_CODE_ERROR;

    isWhite = isWhite || false;
    tryHarder = tryHarder || false;

    if (!offset) {
        offset = self._nextSet(self._row);
    }

    for (i = 0; i < pattern.length; i++) {
        counter[i] = 0;
    }

    for (i = offset; i < self._row.length; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            if (counterPos === counter.length - 1) {
                sum = 0;
                for (j = 0; j < counter.length; j++) {
                    sum += counter[j];
                }
                error = self._matchPattern(counter, pattern);
                if (error < epsilon) {
                    bestMatch.error = error;
                    bestMatch.start = i - sum;
                    bestMatch.end = i;
                    return bestMatch;
                }
                if (tryHarder) {
                    for (j = 0; j < counter.length - 2; j++) {
                        counter[j] = counter[j + 2];
                    }
                    counter[counter.length - 2] = 0;
                    counter[counter.length - 1] = 0;
                    counterPos--;
                } else {
                    return null;
                }
            } else {
                counterPos++;
            }
            counter[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return null;
};

I2of5Reader.prototype._findStart = function () {
    var self = this,
        leadingWhitespaceStart,
        offset = self._nextSet(self._row),
        startInfo,
        narrowBarWidth = 1;

    while (!startInfo) {
        startInfo = self._findPattern(self.START_PATTERN, offset, false, true);
        if (!startInfo) {
            return null;
        }
        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / 4);
        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 10;
        if (leadingWhitespaceStart >= 0) {
            if (self._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
                return startInfo;
            }
        }
        offset = startInfo.end;
        startInfo = null;
    }
};

I2of5Reader.prototype._verifyTrailingWhitespace = function (endInfo) {
    var self = this,
        trailingWhitespaceEnd;

    trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;
    if (trailingWhitespaceEnd < self._row.length) {
        if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
            return endInfo;
        }
    }
    return null;
};

I2of5Reader.prototype._findEnd = function () {
    var self = this,
        endInfo,
        tmp;

    self._row.reverse();
    endInfo = self._findPattern(self.STOP_PATTERN);
    self._row.reverse();

    if (endInfo === null) {
        return null;
    }

    // reverse numbers
    tmp = endInfo.start;
    endInfo.start = self._row.length - endInfo.end;
    endInfo.end = self._row.length - tmp;

    return endInfo !== null ? self._verifyTrailingWhitespace(endInfo) : null;
};

I2of5Reader.prototype._decodePair = function (counterPair) {
    var i,
        code,
        codes = [],
        self = this;

    for (i = 0; i < counterPair.length; i++) {
        code = self._decodeCode(counterPair[i]);
        if (!code) {
            return null;
        }
        codes.push(code);
    }
    return codes;
};

I2of5Reader.prototype._decodeCode = function (counter) {
    var j,
        self = this,
        sum = 0,
        normalized,
        error,
        epsilon = self.AVG_CODE_ERROR,
        code,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
    };

    for (j = 0; j < counter.length; j++) {
        sum += counter[j];
    }
    for (code = 0; code < self.CODE_PATTERN.length; code++) {
        error = self._matchPattern(counter, self.CODE_PATTERN[code]);
        if (error < bestMatch.error) {
            bestMatch.code = code;
            bestMatch.error = error;
        }
    }
    if (bestMatch.error < epsilon) {
        return bestMatch;
    }
};

I2of5Reader.prototype._decodePayload = function (counters, result, decodedCodes) {
    var i,
        self = this,
        pos = 0,
        counterLength = counters.length,
        counterPair = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]],
        codes;

    while (pos < counterLength) {
        for (i = 0; i < 5; i++) {
            counterPair[0][i] = counters[pos] * this.barSpaceRatio[0];
            counterPair[1][i] = counters[pos + 1] * this.barSpaceRatio[1];
            pos += 2;
        }
        codes = self._decodePair(counterPair);
        if (!codes) {
            return null;
        }
        for (i = 0; i < codes.length; i++) {
            result.push(codes[i].code + "");
            decodedCodes.push(codes[i]);
        }
    }
    return codes;
};

I2of5Reader.prototype._verifyCounterLength = function (counters) {
    return counters.length % 10 === 0;
};

I2of5Reader.prototype._decode = function () {
    var startInfo,
        endInfo,
        self = this,
        code,
        result = [],
        decodedCodes = [],
        counters;

    startInfo = self._findStart();
    if (!startInfo) {
        return null;
    }
    decodedCodes.push(startInfo);

    endInfo = self._findEnd();
    if (!endInfo) {
        return null;
    }

    counters = self._fillCounters(startInfo.end, endInfo.start, false);
    if (!self._verifyCounterLength(counters)) {
        return null;
    }
    code = self._decodePayload(counters, result, decodedCodes);
    if (!code) {
        return null;
    }
    if (result.length % 2 !== 0 || result.length < 6) {
        return null;
    }

    decodedCodes.push(endInfo);
    return {
        code: result.join(""),
        start: startInfo.start,
        end: endInfo.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes
    };
};

I2of5Reader.CONFIG_KEYS = {
    normalizeBarSpaceWidth: {
        'type': 'boolean',
        'default': false,
        'description': 'If true, the reader tries to normalize the' + 'width-difference between bars and spaces'
    }
};

/* harmony default export */ __webpack_exports__["a"] = (I2of5Reader);

/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ean_reader__ = __webpack_require__(4);


function UPCEReader(opts, supplements) {
    __WEBPACK_IMPORTED_MODULE_0__ean_reader__["a" /* default */].call(this, opts, supplements);
}

var properties = {
    CODE_FREQUENCY: { value: [[56, 52, 50, 49, 44, 38, 35, 42, 41, 37], [7, 11, 13, 14, 19, 25, 28, 21, 22, 26]] },
    STOP_PATTERN: { value: [1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7] },
    FORMAT: { value: "upc_e", writeable: false }
};

UPCEReader.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__ean_reader__["a" /* default */].prototype, properties);
UPCEReader.prototype.constructor = UPCEReader;

UPCEReader.prototype._decodePayload = function (code, result, decodedCodes) {
    var i,
        self = this,
        codeFrequency = 0x0;

    for (i = 0; i < 6; i++) {
        code = self._decodeCode(code.end);
        if (!code) {
            return null;
        }
        if (code.code >= self.CODE_G_START) {
            code.code = code.code - self.CODE_G_START;
            codeFrequency |= 1 << 5 - i;
        }
        result.push(code.code);
        decodedCodes.push(code);
    }
    if (!self._determineParity(codeFrequency, result)) {
        return null;
    }

    return code;
};

UPCEReader.prototype._determineParity = function (codeFrequency, result) {
    var i, nrSystem;

    for (nrSystem = 0; nrSystem < this.CODE_FREQUENCY.length; nrSystem++) {
        for (i = 0; i < this.CODE_FREQUENCY[nrSystem].length; i++) {
            if (codeFrequency === this.CODE_FREQUENCY[nrSystem][i]) {
                result.unshift(nrSystem);
                result.push(i);
                return true;
            }
        }
    }
    return false;
};

UPCEReader.prototype._convertToUPCA = function (result) {
    var upca = [result[0]],
        lastDigit = result[result.length - 2];

    if (lastDigit <= 2) {
        upca = upca.concat(result.slice(1, 3)).concat([lastDigit, 0, 0, 0, 0]).concat(result.slice(3, 6));
    } else if (lastDigit === 3) {
        upca = upca.concat(result.slice(1, 4)).concat([0, 0, 0, 0, 0]).concat(result.slice(4, 6));
    } else if (lastDigit === 4) {
        upca = upca.concat(result.slice(1, 5)).concat([0, 0, 0, 0, 0, result[5]]);
    } else {
        upca = upca.concat(result.slice(1, 6)).concat([0, 0, 0, 0, lastDigit]);
    }

    upca.push(result[result.length - 1]);
    return upca;
};

UPCEReader.prototype._checksum = function (result) {
    return __WEBPACK_IMPORTED_MODULE_0__ean_reader__["a" /* default */].prototype._checksum.call(this, this._convertToUPCA(result));
};

UPCEReader.prototype._findEnd = function (offset, isWhite) {
    isWhite = true;
    return __WEBPACK_IMPORTED_MODULE_0__ean_reader__["a" /* default */].prototype._findEnd.call(this, offset, isWhite);
};

UPCEReader.prototype._verifyTrailingWhitespace = function (endInfo) {
    var self = this,
        trailingWhitespaceEnd;

    trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;
    if (trailingWhitespaceEnd < self._row.length) {
        if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
            return endInfo;
        }
    }
};

/* harmony default export */ __webpack_exports__["a"] = (UPCEReader);

/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ean_reader__ = __webpack_require__(4);


function UPCReader(opts, supplements) {
    __WEBPACK_IMPORTED_MODULE_0__ean_reader__["a" /* default */].call(this, opts, supplements);
}

var properties = {
    FORMAT: { value: "upc_a", writeable: false }
};

UPCReader.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__ean_reader__["a" /* default */].prototype, properties);
UPCReader.prototype.constructor = UPCReader;

UPCReader.prototype._decode = function () {
    var result = __WEBPACK_IMPORTED_MODULE_0__ean_reader__["a" /* default */].prototype._decode.call(this);

    if (result && result.code && result.code.length === 13 && result.code.charAt(0) === "0") {
        result.code = result.code.substring(1);
        return result;
    }
    return null;
};

/* harmony default export */ __webpack_exports__["a"] = (UPCReader);

/***/ }),
/* 79 */
/***/ (function(module, exports) {

module.exports = copy

/**
 * Copy the values from one mat2 to another
 *
 * @alias mat2.copy
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function copy(out, a) {
  out[0] = a[0]
  out[1] = a[1]
  out[2] = a[2]
  out[3] = a[3]
  return out
}


/***/ }),
/* 80 */
/***/ (function(module, exports) {

module.exports = create

/**
 * Creates a new identity mat2
 *
 * @alias mat2.create
 * @returns {mat2} a new 2x2 matrix
 */
function create() {
  var out = new Float32Array(4)
  out[0] = 1
  out[1] = 0
  out[2] = 0
  out[3] = 1
  return out
}


/***/ }),
/* 81 */
/***/ (function(module, exports) {

module.exports = invert

/**
 * Inverts a mat2
 *
 * @alias mat2.invert
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function invert(out, a) {
  var a0 = a[0]
  var a1 = a[1]
  var a2 = a[2]
  var a3 = a[3]
  var det = a0 * a3 - a2 * a1

  if (!det) return null
  det = 1.0 / det

  out[0] =  a3 * det
  out[1] = -a1 * det
  out[2] = -a2 * det
  out[3] =  a0 * det

  return out
}


/***/ }),
/* 82 */
/***/ (function(module, exports) {

module.exports = scale

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
function scale(out, a, b) {
    out[0] = a[0] * b
    out[1] = a[1] * b
    return out
}

/***/ }),
/* 83 */
/***/ (function(module, exports) {

module.exports = transformMat2

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2(out, a, m) {
    var x = a[0],
        y = a[1]
    out[0] = m[0] * x + m[2] * y
    out[1] = m[1] * x + m[3] * y
    return out
}

/***/ }),
/* 84 */
/***/ (function(module, exports) {

module.exports = clone;

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
function clone(a) {
    var out = new Float32Array(3)
    out[0] = a[0]
    out[1] = a[1]
    out[2] = a[2]
    return out
}

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(123),
    hashDelete = __webpack_require__(124),
    hashGet = __webpack_require__(125),
    hashHas = __webpack_require__(126),
    hashSet = __webpack_require__(127);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(10),
    stackClear = __webpack_require__(150),
    stackDelete = __webpack_require__(151),
    stackGet = __webpack_require__(152),
    stackHas = __webpack_require__(153),
    stackSet = __webpack_require__(154);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(5);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),
/* 88 */
/***/ (function(module, exports) {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(108),
    isArguments = __webpack_require__(18),
    isArray = __webpack_require__(2),
    isBuffer = __webpack_require__(45),
    isIndex = __webpack_require__(15),
    isTypedArray = __webpack_require__(46);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),
/* 90 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),
/* 91 */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(0);

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(91),
    isFlattenable = __webpack_require__(129);

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var createBaseFor = __webpack_require__(118);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(13),
    toKey = __webpack_require__(23);

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),
/* 96 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(8),
    isObjectLike = __webpack_require__(6);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(25),
    isMasked = __webpack_require__(133),
    isObject = __webpack_require__(0),
    toSource = __webpack_require__(156);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(8),
    isLength = __webpack_require__(26),
    isObjectLike = __webpack_require__(6);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(0),
    isPrototype = __webpack_require__(40),
    nativeKeysIn = __webpack_require__(145);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(86),
    assignMergeValue = __webpack_require__(35),
    baseFor = __webpack_require__(94),
    baseMergeDeep = __webpack_require__(102),
    isObject = __webpack_require__(0),
    keysIn = __webpack_require__(47),
    safeGet = __webpack_require__(42);

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    if (isObject(srcValue)) {
      stack || (stack = new Stack);
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var assignMergeValue = __webpack_require__(35),
    cloneBuffer = __webpack_require__(112),
    cloneTypedArray = __webpack_require__(113),
    copyArray = __webpack_require__(114),
    initCloneObject = __webpack_require__(128),
    isArguments = __webpack_require__(18),
    isArray = __webpack_require__(2),
    isArrayLikeObject = __webpack_require__(160),
    isBuffer = __webpack_require__(45),
    isFunction = __webpack_require__(25),
    isObject = __webpack_require__(0),
    isPlainObject = __webpack_require__(161),
    isTypedArray = __webpack_require__(46),
    safeGet = __webpack_require__(42),
    toPlainObject = __webpack_require__(165);

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

var basePickBy = __webpack_require__(104),
    hasIn = __webpack_require__(159);

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}

module.exports = basePick;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(95),
    baseSet = __webpack_require__(106),
    castPath = __webpack_require__(13);

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}

module.exports = basePickBy;


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(44),
    overRest = __webpack_require__(41),
    setToString = __webpack_require__(43);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(36),
    castPath = __webpack_require__(13),
    isIndex = __webpack_require__(15),
    isObject = __webpack_require__(0),
    toKey = __webpack_require__(23);

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

var constant = __webpack_require__(157),
    defineProperty = __webpack_require__(37),
    identity = __webpack_require__(44);

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),
/* 108 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(11),
    arrayMap = __webpack_require__(90),
    isArray = __webpack_require__(2),
    isSymbol = __webpack_require__(27);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),
/* 110 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(87);

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(5);

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(29)(module)))

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(111);

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),
/* 114 */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(36),
    baseAssignValue = __webpack_require__(21);

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(5);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest = __webpack_require__(105),
    isIterateeCall = __webpack_require__(130);

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


/***/ }),
/* 118 */
/***/ (function(module, exports) {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

var flatten = __webpack_require__(158),
    overRest = __webpack_require__(41),
    setToString = __webpack_require__(43);

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(11);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),
/* 121 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(13),
    isArguments = __webpack_require__(18),
    isArray = __webpack_require__(2),
    isIndex = __webpack_require__(15),
    isLength = __webpack_require__(26),
    toKey = __webpack_require__(23);

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(16);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),
/* 124 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(16);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(16);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(16);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(92),
    getPrototype = __webpack_require__(39),
    isPrototype = __webpack_require__(40);

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(11),
    isArguments = __webpack_require__(18),
    isArray = __webpack_require__(2);

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(17),
    isArrayLike = __webpack_require__(24),
    isIndex = __webpack_require__(15),
    isObject = __webpack_require__(0);

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(2),
    isSymbol = __webpack_require__(27);

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),
/* 132 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(116);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),
/* 134 */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(12);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(12);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(12);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(12);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(85),
    ListCache = __webpack_require__(10),
    Map = __webpack_require__(33);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(14);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(14);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(14);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(14);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

var memoize = __webpack_require__(162);

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),
/* 145 */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(38);

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(29)(module)))

/***/ }),
/* 147 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),
/* 148 */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),
/* 149 */
/***/ (function(module, exports) {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(10);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),
/* 151 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),
/* 152 */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),
/* 153 */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(10),
    Map = __webpack_require__(33),
    MapCache = __webpack_require__(34);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

var memoizeCapped = __webpack_require__(144);

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),
/* 156 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),
/* 157 */
/***/ (function(module, exports) {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten = __webpack_require__(93);

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

var baseHasIn = __webpack_require__(96),
    hasPath = __webpack_require__(122);

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(24),
    isObjectLike = __webpack_require__(6);

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(8),
    getPrototype = __webpack_require__(39),
    isObjectLike = __webpack_require__(6);

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(34);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

var basePick = __webpack_require__(103),
    flatRest = __webpack_require__(119);

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});

module.exports = pick;


/***/ }),
/* 164 */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(115),
    keysIn = __webpack_require__(47);

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(109);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(49);


/***/ })
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9teU1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vL3dlYnBhY2svYm9vdHN0cmFwIGMwNmJkYjc4ZWNjYTFlNmM3MTYwIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzT2JqZWN0LmpzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvYmFyY29kZV9yZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL2FycmF5X2hlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVhZGVyL2Vhbl9yZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovLy8uL34vZ2wtdmVjMi9jbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUdldFRhZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL2ltYWdlX2RlYnVnLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19MaXN0Q2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYXNzb2NJbmRleE9mLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jYXN0UGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZ2V0TWFwRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faXNJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2VxLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzQXJndW1lbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21tb24vY3ZfdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9pbWFnZV93cmFwcGVyLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2dldE5hdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fdG9LZXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNBcnJheUxpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc0xlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9tZXJnZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NyYy9sb2NhdG9yL3RyYWNlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVhZGVyL2NvZGVfMzlfcmVhZGVyLmpzIiwid2VicGFjazovLy8uL34vZ2wtdmVjMi9kb3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX01hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fTWFwQ2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Fzc2lnbk1lcmdlVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Fzc2lnblZhbHVlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fb3ZlclJlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3NhZmVHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3NldFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lkZW50aXR5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzQnVmZmVyLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9rZXlzSW4uanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcXVhZ2dhLmpzIiwid2VicGFjazovLy8uL3NyYy9hbmFseXRpY3MvcmVzdWx0X2NvbGxlY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL2NsdXN0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9tZWRpYURldmljZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9zdWJJbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL3R5cGVkZWZzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvY29uZmlnLmRldi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZGVjb2Rlci9iYXJjb2RlX2RlY29kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RlY29kZXIvYnJlc2VuaGFtLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnB1dC9jYW1lcmFfYWNjZXNzLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnB1dC9leGlmX2hlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5wdXQvZnJhbWVfZ3JhYmJlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5wdXQvaW1hZ2VfbG9hZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnB1dC9pbnB1dF9zdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yLmpzIiwid2VicGFjazovLy8uL3NyYy9sb2NhdG9yL3Jhc3Rlcml6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvY2F0b3Ivc2tlbGV0b25pemVyLmpzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvMm9mNV9yZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlYWRlci9jb2RhYmFyX3JlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVhZGVyL2NvZGVfMTI4X3JlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVhZGVyL2NvZGVfMzlfdmluX3JlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVhZGVyL2NvZGVfOTNfcmVhZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvZWFuXzJfcmVhZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvZWFuXzVfcmVhZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvZWFuXzhfcmVhZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvaTJvZjVfcmVhZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvdXBjX2VfcmVhZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvdXBjX3JlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2dsLW1hdDIvY29weS5qcyIsIndlYnBhY2s6Ly8vLi9+L2dsLW1hdDIvY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vZ2wtbWF0Mi9pbnZlcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9nbC12ZWMyL3NjYWxlLmpzIiwid2VicGFjazovLy8uL34vZ2wtdmVjMi90cmFuc2Zvcm1NYXQyLmpzIiwid2VicGFjazovLy8uL34vZ2wtdmVjMy9jbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fSGFzaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fU3RhY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX1VpbnQ4QXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2FwcGx5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19hcnJheU1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYXJyYXlQdXNoLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlQ3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlRmxhdHRlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUZvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUhhc0luLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUtleXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZU1lcmdlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlTWVyZ2VEZWVwLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlUGljay5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZVBpY2tCeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZVJlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VTZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlVG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VVbmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fY2xvbmVCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Nsb25lVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fY29weUFycmF5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jb3B5T2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jb3JlSnNEYXRhLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jcmVhdGVBc3NpZ25lci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fY3JlYXRlQmFzZUZvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZmxhdFJlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZ2V0VmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2hhc1BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faGFzaERlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faGFzaEdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faGFzaEhhcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faGFzaFNldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faW5pdENsb25lT2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19pc0ZsYXR0ZW5hYmxlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faXNLZXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faXNNYXNrZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19saXN0Q2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19tZW1vaXplQ2FwcGVkLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX25vZGVVdGlsLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fb3ZlckFyZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fc2hvcnRPdXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3N0YWNrQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19zdGFja0dldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fc3RhY2tIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19zdHJpbmdUb1BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3RvU291cmNlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2NvbnN0YW50LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2ZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaGFzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNBcnJheUxpa2VPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9tZW1vaXplLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL3BpY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvc3R1YkZhbHNlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL3RvUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvdG9TdHJpbmcuanMiXSwibmFtZXMiOlsiQmFyY29kZVJlYWRlciIsImNvbmZpZyIsInN1cHBsZW1lbnRzIiwiX3JvdyIsInByb3RvdHlwZSIsIl9uZXh0VW5zZXQiLCJsaW5lIiwic3RhcnQiLCJpIiwidW5kZWZpbmVkIiwibGVuZ3RoIiwiX21hdGNoUGF0dGVybiIsImNvdW50ZXIiLCJjb2RlIiwibWF4U2luZ2xlRXJyb3IiLCJlcnJvciIsInNpbmdsZUVycm9yIiwic3VtIiwibW9kdWxvIiwiYmFyV2lkdGgiLCJjb3VudCIsInNjYWxlZCIsIlNJTkdMRV9DT0RFX0VSUk9SIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwiTWF0aCIsImFicyIsIl9uZXh0U2V0Iiwib2Zmc2V0IiwiX2NvcnJlY3RCYXJzIiwiY29ycmVjdGlvbiIsImluZGljZXMiLCJ0bXAiLCJfbWF0Y2hUcmFjZSIsImNtcENvdW50ZXIiLCJlcHNpbG9uIiwic2VsZiIsImlzV2hpdGUiLCJjb3VudGVyUG9zIiwiYmVzdE1hdGNoIiwicHVzaCIsImVuZCIsImRlY29kZVBhdHRlcm4iLCJwYXR0ZXJuIiwicmVzdWx0IiwiX2RlY29kZSIsInJldmVyc2UiLCJkaXJlY3Rpb24iLCJESVJFQ1RJT04iLCJSRVZFUlNFIiwiRk9SV0FSRCIsImZvcm1hdCIsIkZPUk1BVCIsIl9tYXRjaFJhbmdlIiwidmFsdWUiLCJfZmlsbENvdW50ZXJzIiwiY291bnRlcnMiLCJfdG9Db3VudGVycyIsIm51bUNvdW50ZXJzIiwiQXJyYXlIZWxwZXIiLCJpbml0IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ3cml0ZWFibGUiLCJFeGNlcHRpb24iLCJTdGFydE5vdEZvdW5kRXhjZXB0aW9uIiwiQ29kZU5vdEZvdW5kRXhjZXB0aW9uIiwiUGF0dGVybk5vdEZvdW5kRXhjZXB0aW9uIiwiQ09ORklHX0tFWVMiLCJhcnIiLCJ2YWwiLCJsIiwic2h1ZmZsZSIsImoiLCJ4IiwiZmxvb3IiLCJyYW5kb20iLCJ0b1BvaW50TGlzdCIsInJvdyIsInJvd3MiLCJqb2luIiwidGhyZXNob2xkIiwic2NvcmVGdW5jIiwicXVldWUiLCJhcHBseSIsIm1heEluZGV4IiwibWF4IiwiRUFOUmVhZGVyIiwib3B0cyIsImdldERlZmF1bENvbmZpZyIsImNhbGwiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImRlZmF1bHQiLCJwcm9wZXJ0aWVzIiwiQ09ERV9MX1NUQVJUIiwiQ09ERV9HX1NUQVJUIiwiU1RBUlRfUEFUVEVSTiIsIlNUT1BfUEFUVEVSTiIsIk1JRERMRV9QQVRURVJOIiwiRVhURU5TSU9OX1NUQVJUX1BBVFRFUk4iLCJDT0RFX1BBVFRFUk4iLCJDT0RFX0ZSRVFVRU5DWSIsIkFWR19DT0RFX0VSUk9SIiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJfZGVjb2RlQ29kZSIsImNvZGVyYW5nZSIsIl9maW5kUGF0dGVybiIsInRyeUhhcmRlciIsIl9maW5kU3RhcnQiLCJsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0Iiwic3RhcnRJbmZvIiwiX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZSIsImVuZEluZm8iLCJ0cmFpbGluZ1doaXRlc3BhY2VFbmQiLCJfZmluZEVuZCIsIl9jYWxjdWxhdGVGaXJzdERpZ2l0IiwiY29kZUZyZXF1ZW5jeSIsIl9kZWNvZGVQYXlsb2FkIiwiZGVjb2RlZENvZGVzIiwiZmlyc3REaWdpdCIsInVuc2hpZnQiLCJyZXN1bHRJbmZvIiwiX2NoZWNrc3VtIiwiZXh0IiwiX2RlY29kZUV4dGVuc2lvbnMiLCJsYXN0Q29kZSIsInN1cHBsZW1lbnQiLCJjb2Rlc2V0IiwiZGVjb2RlIiwiZHJhd1JlY3QiLCJwb3MiLCJzaXplIiwiY3R4Iiwic3R5bGUiLCJzdHJva2VTdHlsZSIsImNvbG9yIiwiZmlsbFN0eWxlIiwibGluZVdpZHRoIiwiYmVnaW5QYXRoIiwic3Ryb2tlUmVjdCIsInkiLCJkcmF3UGF0aCIsInBhdGgiLCJkZWYiLCJtb3ZlVG8iLCJsaW5lVG8iLCJjbG9zZVBhdGgiLCJzdHJva2UiLCJkcmF3SW1hZ2UiLCJpbWFnZURhdGEiLCJjYW52YXNEYXRhIiwiZ2V0SW1hZ2VEYXRhIiwiZGF0YSIsImltYWdlRGF0YVBvcyIsImNhbnZhc0RhdGFQb3MiLCJwdXRJbWFnZURhdGEiLCJ2ZWMyIiwiY2xvbmUiLCJyZXF1aXJlIiwidmVjMyIsImltYWdlUmVmIiwidGhhdCIsInRvVmVjMiIsInRvVmVjMyIsInJvdW5kIiwiY29tcHV0ZUludGVncmFsSW1hZ2UyIiwiaW1hZ2VXcmFwcGVyIiwiaW50ZWdyYWxXcmFwcGVyIiwid2lkdGgiLCJoZWlnaHQiLCJpbnRlZ3JhbEltYWdlRGF0YSIsInBvc0EiLCJwb3NCIiwicG9zQyIsInBvc0QiLCJjb21wdXRlSW50ZWdyYWxJbWFnZSIsInYiLCJ1IiwidGhyZXNob2xkSW1hZ2UiLCJ0YXJnZXRXcmFwcGVyIiwidGFyZ2V0RGF0YSIsImNvbXB1dGVIaXN0b2dyYW0iLCJiaXRzUGVyUGl4ZWwiLCJiaXRTaGlmdCIsImJ1Y2tldENudCIsImhpc3QiLCJJbnQzMkFycmF5Iiwic2hhcnBlbkxpbmUiLCJsZWZ0IiwiY2VudGVyIiwicmlnaHQiLCJkZXRlcm1pbmVPdHN1VGhyZXNob2xkIiwicHgiLCJteCIsImRldGVybWluZVRocmVzaG9sZCIsInZldCIsInAxIiwicDIiLCJwMTIiLCJrIiwibTEiLCJtMiIsIm0xMiIsIm90c3VUaHJlc2hvbGQiLCJjb21wdXRlQmluYXJ5SW1hZ2UiLCJrZXJuZWwiLCJBIiwiQiIsIkMiLCJEIiwiYXZnIiwiY2x1c3RlciIsInBvaW50cyIsInByb3BlcnR5IiwicG9pbnQiLCJjbHVzdGVycyIsImFkZFRvQ2x1c3RlciIsIm5ld1BvaW50IiwiZm91bmQiLCJmaXRzIiwiYWRkIiwiQ2x1c3RlcjIiLCJjcmVhdGVQb2ludCIsIlRyYWNlciIsInRyYWNlIiwidmVjIiwiaXRlcmF0aW9uIiwibWF4SXRlcmF0aW9ucyIsInRvcCIsImNlbnRlclBvcyIsImN1cnJlbnRQb3MiLCJpZHgiLCJmb3J3YXJkIiwiZnJvbSIsInRvIiwidG9JZHgiLCJwcmVkaWN0ZWRQb3MiLCJ0aHJlc2hvbGRYIiwidGhyZXNob2xkWSIsIm1hdGNoIiwicHJlZGljdGVkIiwiRElMQVRFIiwiRVJPREUiLCJkaWxhdGUiLCJpbkltYWdlV3JhcHBlciIsIm91dEltYWdlV3JhcHBlciIsImluSW1hZ2VEYXRhIiwib3V0SW1hZ2VEYXRhIiwieVN0YXJ0MSIsInlTdGFydDIiLCJ4U3RhcnQxIiwieFN0YXJ0MiIsImVyb2RlIiwic3VidHJhY3QiLCJhSW1hZ2VXcmFwcGVyIiwiYkltYWdlV3JhcHBlciIsInJlc3VsdEltYWdlV3JhcHBlciIsImFJbWFnZURhdGEiLCJiSW1hZ2VEYXRhIiwiY0ltYWdlRGF0YSIsImJpdHdpc2VPciIsImNvdW50Tm9uWmVybyIsInRvcEdlbmVyaWMiLCJsaXN0IiwibWluSWR4IiwibWluIiwic2NvcmUiLCJoaXQiLCJpdGVtIiwiZ3JheUFycmF5RnJvbUltYWdlIiwiaHRtbEltYWdlIiwib2Zmc2V0WCIsImFycmF5IiwiY3R4RGF0YSIsImNvbXB1dGVHcmF5IiwiZ3JheUFycmF5RnJvbUNvbnRleHQiLCJncmF5QW5kSGFsZlNhbXBsZUZyb21DYW52YXNEYXRhIiwib3V0QXJyYXkiLCJ0b3BSb3dJZHgiLCJib3R0b21Sb3dJZHgiLCJlbmRJZHgiLCJvdXRXaWR0aCIsIm91dEltZ0lkeCIsImluV2lkdGgiLCJzaW5nbGVDaGFubmVsIiwibG9hZEltYWdlQXJyYXkiLCJzcmMiLCJjYWxsYmFjayIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImltZyIsIkltYWdlIiwib25sb2FkIiwiZ2V0Q29udGV4dCIsIlVpbnQ4QXJyYXkiLCJoYWxmU2FtcGxlIiwiaW5JbWdXcmFwcGVyIiwib3V0SW1nV3JhcHBlciIsImluSW1nIiwib3V0SW1nIiwiaHN2MnJnYiIsImhzdiIsInJnYiIsImgiLCJzIiwiYyIsIm0iLCJyIiwiZyIsImIiLCJfY29tcHV0ZURpdmlzb3JzIiwibiIsImxhcmdlRGl2aXNvcnMiLCJkaXZpc29ycyIsInNxcnQiLCJjb25jYXQiLCJfY29tcHV0ZUludGVyc2VjdGlvbiIsImFycjEiLCJhcnIyIiwiY2FsY3VsYXRlUGF0Y2hTaXplIiwicGF0Y2hTaXplIiwiaW1nU2l6ZSIsImRpdmlzb3JzWCIsImRpdmlzb3JzWSIsIndpZGVTaWRlIiwiY29tbW9uIiwibnJPZlBhdGNoZXNMaXN0IiwibnJPZlBhdGNoZXNNYXAiLCJuck9mUGF0Y2hlc0lkeCIsIm1lZGl1bSIsIm5yT2ZQYXRjaGVzIiwiZGVzaXJlZFBhdGNoU2l6ZSIsIm9wdGltYWxQYXRjaFNpemUiLCJmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMiLCJfcGFyc2VDU1NEaW1lbnNpb25WYWx1ZXMiLCJkaW1lbnNpb24iLCJwYXJzZUZsb2F0IiwidW5pdCIsImluZGV4T2YiLCJfZGltZW5zaW9uc0NvbnZlcnRlcnMiLCJjb250ZXh0IiwiYm90dG9tIiwiY29tcHV0ZUltYWdlQXJlYSIsImlucHV0V2lkdGgiLCJpbnB1dEhlaWdodCIsImFyZWEiLCJwYXJzZWRBcmVhIiwicmVkdWNlIiwicGFyc2VkIiwiY2FsY3VsYXRlZCIsInN4Iiwic3kiLCJzdyIsInNoIiwiSW1hZ2VXcmFwcGVyIiwiQXJyYXlUeXBlIiwiaW5pdGlhbGl6ZSIsIkFycmF5IiwiaW5JbWFnZVdpdGhCb3JkZXIiLCJpbWdSZWYiLCJib3JkZXIiLCJzYW1wbGUiLCJseCIsImx5IiwidyIsImJhc2UiLCJhIiwiZCIsImUiLCJjbGVhckFycmF5Iiwic3ViSW1hZ2UiLCJTdWJJbWFnZSIsInN1YkltYWdlQXNDb3B5Iiwic2l6ZVkiLCJzaXplWCIsImNvcHlUbyIsInNyY0RhdGEiLCJkc3REYXRhIiwiZ2V0IiwiZ2V0U2FmZSIsImluZGV4TWFwcGluZyIsInNldCIsInplcm9Cb3JkZXIiLCJpbnZlcnQiLCJjb252b2x2ZSIsImt4Iiwia3kiLCJrU2l6ZSIsImFjY3UiLCJtb21lbnRzIiwibGFiZWxjb3VudCIsInlzcSIsImxhYmVsc3VtIiwibGFiZWwiLCJtdTExIiwibXUwMiIsIm11MjAiLCJ4XyIsInlfIiwiUEkiLCJQSV80IiwibTAwIiwibTAxIiwibTEwIiwibTExIiwibTAyIiwibTIwIiwidGhldGEiLCJyYWQiLCJpc05hTiIsImF0YW4iLCJjb3MiLCJzaW4iLCJzaG93Iiwic2NhbGUiLCJmcmFtZSIsImN1cnJlbnQiLCJwaXhlbCIsIm92ZXJsYXkiLCJ3aGl0ZVJnYiIsImJsYWNrUmdiIiwic2VhcmNoRGlyZWN0aW9ucyIsImxhYmVsV3JhcHBlciIsImxhYmVsRGF0YSIsImVkZ2VsYWJlbCIsImN5IiwiZGlyIiwiY3giLCJ2ZXJ0ZXgyRCIsIm5leHQiLCJwcmV2IiwiY29udG91clRyYWNpbmciLCJGdiIsIkN2IiwiUCIsImxkaXIiLCJDb2RlMzlSZWFkZXIiLCJBTFBIQUJFVEhfU1RSSU5HIiwiQUxQSEFCRVQiLCJDSEFSQUNURVJfRU5DT0RJTkdTIiwiQVNURVJJU0siLCJkZWNvZGVkQ2hhciIsImxhc3RTdGFydCIsIm5leHRTdGFydCIsIl90b1BhdHRlcm4iLCJfcGF0dGVyblRvQ2hhciIsInBvcCIsInBhdHRlcm5TaXplIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiX2ZpbmROZXh0V2lkdGgiLCJtaW5XaWR0aCIsIm1heE5hcnJvd1dpZHRoIiwibnVtV2lkZUJhcnMiLCJ3aWRlQmFyV2lkdGgiLCJwYXR0ZXJuU3RhcnQiLCJ3aGl0ZVNwYWNlTXVzdFN0YXJ0IiwiX2lucHV0U3RyZWFtIiwiX2ZyYW1lZ3JhYmJlciIsIl9zdG9wcGVkIiwiX2NhbnZhc0NvbnRhaW5lciIsImltYWdlIiwiZG9tIiwiX2lucHV0SW1hZ2VXcmFwcGVyIiwiX2JveFNpemUiLCJfZGVjb2RlciIsIl93b3JrZXJQb29sIiwiX29uVUlUaHJlYWQiLCJfcmVzdWx0Q29sbGVjdG9yIiwiX2NvbmZpZyIsImluaXRpYWxpemVEYXRhIiwiaW5pdEJ1ZmZlcnMiLCJCYXJjb2RlRGVjb2RlciIsImRlY29kZXIiLCJpbml0SW5wdXRTdHJlYW0iLCJjYiIsInZpZGVvIiwiaW5wdXRTdHJlYW0iLCJ0eXBlIiwiSW5wdXRTdHJlYW0iLCJjcmVhdGVWaWRlb1N0cmVhbSIsImNyZWF0ZUltYWdlU3RyZWFtIiwiJHZpZXdwb3J0IiwiZ2V0Vmlld1BvcnQiLCJxdWVyeVNlbGVjdG9yIiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVMaXZlU3RyZWFtIiwiQ2FtZXJhQWNjZXNzIiwicmVxdWVzdCIsImNvbnN0cmFpbnRzIiwidGhlbiIsInRyaWdnZXIiLCJjYXRjaCIsImVyciIsInNldEF0dHJpYnV0ZSIsInNldElucHV0U3RyZWFtIiwiYWRkRXZlbnRMaXN0ZW5lciIsImNhblJlY29yZCIsImJpbmQiLCJ0YXJnZXQiLCJub2RlTmFtZSIsIm5vZGVUeXBlIiwic2VsZWN0b3IiLCJCYXJjb2RlTG9jYXRvciIsImNoZWNrSW1hZ2VDb25zdHJhaW50cyIsImxvY2F0b3IiLCJpbml0Q2FudmFzIiwiRnJhbWVHcmFiYmVyIiwiYWRqdXN0V29ya2VyUG9vbCIsIm51bU9mV29ya2VycyIsInJlYWR5IiwicGxheSIsImNsYXNzTmFtZSIsImdldENhbnZhc1NpemUiLCJjbGVhckZpeCIsImdldFdpZHRoIiwiZ2V0SGVpZ2h0IiwiRU5WIiwiY29uc29sZSIsImxvZyIsImdldEJvdW5kaW5nQm94ZXMiLCJsb2NhdGUiLCJ0cmFuc2Zvcm1SZXN1bHQiLCJ0b3BSaWdodCIsImdldFRvcFJpZ2h0IiwieE9mZnNldCIsInlPZmZzZXQiLCJiYXJjb2RlcyIsIm1vdmVMaW5lIiwiYm94IiwibW92ZUJveCIsImJveGVzIiwiY29ybmVyIiwiYWRkUmVzdWx0IiwiZmlsdGVyIiwiYmFyY29kZSIsImNvZGVSZXN1bHQiLCJoYXNDb2RlUmVzdWx0Iiwic29tZSIsInB1Ymxpc2hSZXN1bHQiLCJyZXN1bHRUb1B1Ymxpc2giLCJFdmVudHMiLCJwdWJsaXNoIiwibG9jYXRlQW5kRGVjb2RlIiwiZGVjb2RlRnJvbUJvdW5kaW5nQm94ZXMiLCJ1cGRhdGUiLCJhdmFpbGFibGVXb3JrZXIiLCJ3b3JrZXJUaHJlYWQiLCJidXN5IiwiYXR0YWNoRGF0YSIsImdyYWIiLCJ3b3JrZXIiLCJwb3N0TWVzc2FnZSIsImNtZCIsImJ1ZmZlciIsInN0YXJ0Q29udGludW91c1VwZGF0ZSIsImRlbGF5IiwiZnJlcXVlbmN5IiwidGltZXN0YW1wIiwid2luZG93IiwicmVxdWVzdEFuaW1GcmFtZSIsInBlcmZvcm1hbmNlIiwibm93IiwiaW5pdFdvcmtlciIsImJsb2JVUkwiLCJnZW5lcmF0ZVdvcmtlckJsb2IiLCJXb3JrZXIiLCJvbm1lc3NhZ2UiLCJldmVudCIsIlVSTCIsInJldm9rZU9iamVjdFVSTCIsIm1lc3NhZ2UiLCJjb25maWdGb3JXb3JrZXIiLCJ3b3JrZXJJbnRlcmZhY2UiLCJmYWN0b3J5IiwiUXVhZ2dhIiwib25Qcm9jZXNzZWQiLCJzZXRSZWFkZXJzIiwicmVhZGVycyIsImJsb2IiLCJmYWN0b3J5U291cmNlIiwiX19mYWN0b3J5U291cmNlX18iLCJCbG9iIiwidG9TdHJpbmciLCJjcmVhdGVPYmplY3RVUkwiLCJjYXBhY2l0eSIsImluY3JlYXNlQnkiLCJ3b3JrZXJzVG9UZXJtaW5hdGUiLCJzbGljZSIsInRlcm1pbmF0ZSIsIndvcmtlckluaXRpYWxpemVkIiwiQ29uZmlnIiwic3RvcCIsInJlbGVhc2UiLCJjbGVhckV2ZW50SGFuZGxlcnMiLCJwYXVzZSIsIm9uRGV0ZWN0ZWQiLCJzdWJzY3JpYmUiLCJvZmZEZXRlY3RlZCIsInVuc3Vic2NyaWJlIiwib2ZmUHJvY2Vzc2VkIiwicmVnaXN0ZXJSZXN1bHRDb2xsZWN0b3IiLCJyZXN1bHRDb2xsZWN0b3IiLCJkZWNvZGVTaW5nbGUiLCJyZXN1bHRDYWxsYmFjayIsInNlcXVlbmNlIiwiZGVidWciLCJvbmNlIiwiSW1hZ2VEZWJ1ZyIsIlJlc3VsdENvbGxlY3RvciIsImNvbnRhaW5zIiwiZXZlcnkiLCJwYXNzZXNGaWx0ZXIiLCJyZXN1bHRzIiwiY2FwdHVyZSIsIm1hdGNoZXNDb25zdHJhaW50cyIsImJsYWNrbGlzdCIsImltYWdlU2l6ZSIsInRvRGF0YVVSTCIsImdldFJlc3VsdHMiLCJkb3QiLCJwb2ludE1hcCIsInVwZGF0ZUNlbnRlciIsInBvaW50VG9BZGQiLCJpZCIsIm90aGVyUG9pbnQiLCJzaW1pbGFyaXR5IiwiZ2V0UG9pbnRzIiwiZ2V0Q2VudGVyIiwiZXZlbnRzIiwiZ2V0RXZlbnQiLCJldmVudE5hbWUiLCJzdWJzY3JpYmVycyIsImNsZWFyRXZlbnRzIiwicHVibGlzaFN1YnNjcmlwdGlvbiIsInN1YnNjcmlwdGlvbiIsImFzeW5jIiwic2V0VGltZW91dCIsInN1YnNjcmliZXIiLCJlbnVtZXJhdGVEZXZpY2VzIiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiUHJvbWlzZSIsInJlamVjdCIsIkVycm9yIiwiZ2V0VXNlck1lZGlhIiwiSSIsIm9yaWdpbmFsU2l6ZSIsInVwZGF0ZURhdGEiLCJ1cGRhdGVGcm9tIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib1JlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiaW11bCIsImFoIiwiYWwiLCJiaCIsImJsIiwiYXNzaWduIiwiVHlwZUVycm9yIiwiaW5kZXgiLCJhcmd1bWVudHMiLCJuZXh0U291cmNlIiwibmV4dEtleSIsImhhc093blByb3BlcnR5IiwibW9kdWxlIiwiZXhwb3J0cyIsIm5hbWUiLCJmYWNpbmdNb2RlIiwiZHJhd0JvdW5kaW5nQm94Iiwic2hvd0ZyZXF1ZW5jeSIsImRyYXdTY2FubGluZSIsInNob3dQYXR0ZXJuIiwic2hvd0NhbnZhcyIsInNob3dQYXRjaGVzIiwic2hvd0ZvdW5kUGF0Y2hlcyIsInNob3dTa2VsZXRvbiIsInNob3dMYWJlbHMiLCJzaG93UGF0Y2hMYWJlbHMiLCJzaG93UmVtYWluaW5nUGF0Y2hMYWJlbHMiLCJib3hGcm9tUGF0Y2hlcyIsInNob3dUcmFuc2Zvcm1lZCIsInNob3dUcmFuc2Zvcm1lZEJveCIsInNob3dCQiIsIm5vZGUiLCJSRUFERVJTIiwiY29kZV8xMjhfcmVhZGVyIiwiQ29kZTEyOFJlYWRlciIsImVhbl9yZWFkZXIiLCJlYW5fNV9yZWFkZXIiLCJFQU41UmVhZGVyIiwiZWFuXzJfcmVhZGVyIiwiRUFOMlJlYWRlciIsImVhbl84X3JlYWRlciIsIkVBTjhSZWFkZXIiLCJjb2RlXzM5X3JlYWRlciIsImNvZGVfMzlfdmluX3JlYWRlciIsIkNvZGUzOVZJTlJlYWRlciIsImNvZGFiYXJfcmVhZGVyIiwiQ29kYWJhclJlYWRlciIsInVwY19yZWFkZXIiLCJVUENSZWFkZXIiLCJ1cGNfZV9yZWFkZXIiLCJVUENFUmVhZGVyIiwiaTJvZjVfcmVhZGVyIiwiSTJvZjVSZWFkZXIiLCJUd29PZkZpdmVSZWFkZXIiLCJjb2RlXzkzX3JlYWRlciIsIkNvZGU5M1JlYWRlciIsImlucHV0SW1hZ2VXcmFwcGVyIiwiX2NhbnZhcyIsIl9iYXJjb2RlUmVhZGVycyIsImluaXRSZWFkZXJzIiwiaW5pdENvbmZpZyIsIiRkZWJ1ZyIsInJlYWRlckNvbmZpZyIsInJlYWRlciIsImNvbmZpZ3VyYXRpb24iLCJtYXAiLCJKU09OIiwic3RyaW5naWZ5IiwidmlzIiwicHJvcCIsImRpc3BsYXkiLCJnZXRFeHRlbmRlZExpbmUiLCJhbmdsZSIsImV4dGVuZExpbmUiLCJhbW91bnQiLCJleHRlbnNpb24iLCJjZWlsIiwiZ2V0TGluZSIsInRyeURlY29kZSIsImJhcmNvZGVMaW5lIiwiQnJlc2VuaGFtIiwiZ2V0QmFyY29kZUxpbmUiLCJwcmludEZyZXF1ZW5jeSIsInRvQmluYXJ5TGluZSIsInByaW50UGF0dGVybiIsInRyeURlY29kZUJydXRlRm9yY2UiLCJsaW5lQW5nbGUiLCJzaWRlTGVuZ3RoIiwicG93Iiwic2xpY2VzIiwieGRpciIsInlkaXIiLCJnZXRMaW5lTGVuZ3RoIiwiZGVjb2RlRnJvbUJvdW5kaW5nQm94IiwibGluZUxlbmd0aCIsImF0YW4yIiwibXVsdGlwbGUiLCJTbG9wZSIsIkRJUiIsIlVQIiwiRE9XTiIsIngwIiwieTAiLCJ4MSIsInkxIiwic3RlZXAiLCJkZWx0YXgiLCJkZWx0YXkiLCJ5c3RlcCIsInJlYWQiLCJzbG9wZSIsInNsb3BlMiIsImV4dHJlbWEiLCJjdXJyZW50RGlyIiwiclRocmVzaG9sZCIsImZpbGxDb2xvciIsImZpbGxSZWN0IiwiZmFjaW5nTWF0Y2hpbmciLCJzdHJlYW1SZWYiLCJ3YWl0Rm9yVmlkZW8iLCJyZXNvbHZlIiwiYXR0ZW1wdHMiLCJjaGVja1ZpZGVvIiwidmlkZW9XaWR0aCIsInZpZGVvSGVpZ2h0IiwiaW5pdENhbWVyYSIsInN0cmVhbSIsInNyY09iamVjdCIsImRlcHJlY2F0ZWRDb25zdHJhaW50cyIsInZpZGVvQ29uc3RyYWludHMiLCJub3JtYWxpemVkIiwibWluQXNwZWN0UmF0aW8iLCJhc3BlY3RSYXRpbyIsImZhY2luZyIsInBpY2tDb25zdHJhaW50cyIsIm5vcm1hbGl6ZWRDb25zdHJhaW50cyIsImF1ZGlvIiwiZGV2aWNlSWQiLCJlbnVtZXJhdGVWaWRlb0RldmljZXMiLCJkZXZpY2VzIiwiZGV2aWNlIiwia2luZCIsImdldEFjdGl2ZVRyYWNrIiwidHJhY2tzIiwiZ2V0VmlkZW9UcmFja3MiLCJnZXRBY3RpdmVTdHJlYW1MYWJlbCIsInRyYWNrIiwiRXhpZlRhZ3MiLCJBdmFpbGFibGVUYWdzIiwiZmluZFRhZ3NJbk9iamVjdFVSTCIsInRhZ3MiLCJ0ZXN0Iiwib2JqZWN0VVJMVG9CbG9iIiwicmVhZFRvQnVmZmVyIiwiZmluZFRhZ3NJbkJ1ZmZlciIsImJhc2U2NFRvQXJyYXlCdWZmZXIiLCJkYXRhVXJsIiwiYmFzZTY0IiwicmVwbGFjZSIsImJpbmFyeSIsImF0b2IiLCJsZW4iLCJBcnJheUJ1ZmZlciIsInZpZXciLCJjaGFyQ29kZUF0IiwiZmlsZVJlYWRlciIsIkZpbGVSZWFkZXIiLCJyZWFkQXNBcnJheUJ1ZmZlciIsInVybCIsImh0dHAiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJyZXNwb25zZVR5cGUiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwiRE9ORSIsInN0YXR1cyIsInJlc3BvbnNlIiwib25lcnJvciIsInNlbmQiLCJmaWxlIiwic2VsZWN0ZWRUYWdzIiwiZGF0YVZpZXciLCJEYXRhVmlldyIsImJ5dGVMZW5ndGgiLCJleGlmVGFncyIsInNlbGVjdGVkVGFnIiwiZXhpZlRhZyIsInRhZyIsIm1hcmtlciIsImdldFVpbnQ4IiwicmVhZEVYSUZEYXRhIiwiZ2V0VWludDE2IiwiZ2V0U3RyaW5nRnJvbUJ1ZmZlciIsInRpZmZPZmZzZXQiLCJiaWdFbmQiLCJmaXJzdElGRE9mZnNldCIsImdldFVpbnQzMiIsInJlYWRUYWdzIiwidGlmZlN0YXJ0IiwiZGlyU3RhcnQiLCJzdHJpbmdzIiwiZW50cmllcyIsImVudHJ5T2Zmc2V0IiwicmVhZFRhZ1ZhbHVlIiwibnVtVmFsdWVzIiwib3V0c3RyIiwiVE9fUkFESUFOUyIsImFkanVzdENhbnZhc1NpemUiLCJ0YXJnZXRTaXplIiwiX3RoYXQiLCJfc3RyZWFtQ29uZmlnIiwiZ2V0Q29uZmlnIiwiX3ZpZGVvX3NpemUiLCJnZXRSZWFsV2lkdGgiLCJnZXRSZWFsSGVpZ2h0IiwiX2NhbnZhc1NpemUiLCJfc2l6ZSIsIl9zeCIsIl9zeSIsIl9jdHgiLCJfZGF0YSIsInZpZGVvU2l6ZSIsImNhbnZhc1NpemUiLCJnZXREYXRhIiwiZG9IYWxmU2FtcGxlIiwiZ2V0RnJhbWUiLCJkcmF3YWJsZSIsImRyYXdBbmdsZSIsIm9yaWVudGF0aW9uIiwidHJhbnNsYXRlIiwicm90YXRlIiwiZ2V0U2l6ZSIsIkltYWdlTG9hZGVyIiwibG9hZCIsImRpcmVjdG9yeSIsImh0bWxJbWFnZXNTcmNBcnJheSIsImh0bWxJbWFnZXNBcnJheSIsIm51bSIsIm5vdExvYWRlZCIsImFkZEltYWdlIiwibG9hZGVkIiwibG9hZGVkSW1nIiwibm90bG9hZGVkSW1ncyIsInNwbGljZSIsImltZ05hbWUiLCJzdWJzdHIiLCJsYXN0SW5kZXhPZiIsImFkZE9ubG9hZEhhbmRsZXIiLCJfZXZlbnROYW1lcyIsIl9ldmVudEhhbmRsZXJzIiwiX2NhbGN1bGF0ZWRXaWR0aCIsIl9jYWxjdWxhdGVkSGVpZ2h0IiwiX3RvcFJpZ2h0IiwiaW5pdFNpemUiLCJzZXRXaWR0aCIsInNldEhlaWdodCIsImVuZGVkIiwic2V0Q3VycmVudFRpbWUiLCJ0aW1lIiwiY3VycmVudFRpbWUiLCJmIiwiYm9vbCIsImhhbmRsZXJzIiwiaGFuZGxlciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhcmdzIiwic2V0VG9wUmlnaHQiLCJzZXRDYW52YXNTaXplIiwiZnJhbWVJZHgiLCJwYXVzZWQiLCJpbWdBcnJheSIsImJhc2VVcmwiLCJjYWxjdWxhdGVkV2lkdGgiLCJjYWxjdWxhdGVkSGVpZ2h0IiwibG9hZEltYWdlcyIsImltZ3MiLCJwdWJsaXNoRXZlbnQiLCJuZXdXaWR0aCIsIm5ld0hlaWdodCIsInRyYW5zZm9ybU1hdDIiLCJtYXQyIiwiY29weSIsIl9jdXJyZW50SW1hZ2VXcmFwcGVyIiwiX3NrZWxJbWFnZVdyYXBwZXIiLCJfc3ViSW1hZ2VXcmFwcGVyIiwiX2xhYmVsSW1hZ2VXcmFwcGVyIiwiX3BhdGNoR3JpZCIsIl9wYXRjaExhYmVsR3JpZCIsIl9pbWFnZVRvUGF0Y2hHcmlkIiwiX2JpbmFyeUltYWdlV3JhcHBlciIsIl9wYXRjaFNpemUiLCJfbnVtUGF0Y2hlcyIsIl9za2VsZXRvbml6ZXIiLCJza2VsZXRvbkltYWdlRGF0YSIsInNrZWxldG9uaXplciIsImdsb2JhbCIsInVzZVdvcmtlciIsInBhdGNoZXMiLCJvdmVyQXZnIiwicGF0Y2giLCJ0cmFuc01hdCIsIm1pbngiLCJtaW55IiwibWF4eCIsIm1heHkiLCJiaW5hcml6ZUltYWdlIiwiZmluZFBhdGNoZXMiLCJwYXRjaGVzRm91bmQiLCJyYXN0ZXJpemVyIiwicmFzdGVyUmVzdWx0Iiwic2tlbGV0b25pemUiLCJSYXN0ZXJpemVyIiwicmFzdGVyaXplIiwiZGVzY3JpYmVQYXRjaCIsImZpbmRCaWdnZXN0Q29ubmVjdGVkQXJlYXMiLCJtYXhMYWJlbCIsImxhYmVsSGlzdCIsInRvcExhYmVscyIsInNvcnQiLCJlbCIsImZpbmRCb3hlcyIsInNpbWlsYXJNb21lbnRzIiwidG9wQ2x1c3RlciIsInBhdGNoUG9zIiwiZWxpZ2libGVNb21lbnRzIiwibWF0Y2hpbmdNb21lbnRzIiwibWluQ29tcG9uZW50V2VpZ2h0IiwicmFzdGVyaXplQW5ndWxhclNpbWlsYXJpdHkiLCJjdXJySWR4Iiwibm90WWV0UHJvY2Vzc2VkIiwiY3VycmVudElkeCIsImN1cnJlbnRQYXRjaCIsImNyZWF0ZUNvbnRvdXIyRCIsImZpcnN0VmVydGV4IiwiaW5zaWRlQ29udG91cnMiLCJuZXh0cGVlciIsInByZXZwZWVyIiwiQ09OVE9VUl9ESVIiLCJDV19ESVIiLCJDQ1dfRElSIiwiVU5LTk9XTl9ESVIiLCJPVVRTSURFX0VER0UiLCJJTlNJREVfRURHRSIsInRyYWNlciIsImRlcHRobGFiZWwiLCJiYyIsImxjIiwibGFiZWxpbmRleCIsImNvbG9yTWFwIiwidmVydGV4IiwicCIsImNjIiwic2MiLCJjb25uZWN0ZWRDb3VudCIsImRyYXdDb250b3VyIiwiZmlyc3RDb250b3VyIiwicHEiLCJpcSIsInEiLCJTa2VsZXRvbml6ZXIiLCJzdGRsaWIiLCJmb3JlaWduIiwiaW1hZ2VzIiwiaW5JbWFnZVB0ciIsIm91dEltYWdlUHRyIiwiYUltYWdlUHRyIiwiYkltYWdlUHRyIiwiaW1hZ2VQdHIiLCJtZW1jcHkiLCJzcmNJbWFnZVB0ciIsImRzdEltYWdlUHRyIiwic3ViSW1hZ2VQdHIiLCJlcm9kZWRJbWFnZVB0ciIsInRlbXBJbWFnZVB0ciIsInNrZWxJbWFnZVB0ciIsImRvbmUiLCJiYXJTcGFjZVJhdGlvIiwiTiIsIlciLCJ3cml0YWJsZSIsInN0YXJ0UGF0dGVybkxlbmd0aCIsIm5hcnJvd0JhcldpZHRoIiwiY291bnRlckxlbmd0aCIsIl92ZXJpZnlDb3VudGVyTGVuZ3RoIiwiX2NvdW50ZXJzIiwiU1RBUlRfRU5EIiwiTUlOX0VOQ09ERURfQ0hBUlMiLCJNQVhfQUNDRVBUQUJMRSIsIlBBRERJTkciLCJzdGFydENvdW50ZXIiLCJfaXNTdGFydEVuZCIsIl92ZXJpZnlXaGl0ZXNwYWNlIiwiX3ZhbGlkYXRlUmVzdWx0IiwiX3N1bUNvdW50ZXJzIiwiZW5kQ291bnRlciIsIl9jYWxjdWxhdGVQYXR0ZXJuTGVuZ3RoIiwiX3RocmVzaG9sZFJlc3VsdFBhdHRlcm4iLCJjYXRlZ29yaXphdGlvbiIsInNwYWNlIiwibmFycm93IiwiY291bnRzIiwid2lkZSIsImJhciIsImNhdCIsIl9jaGFyVG9QYXR0ZXJuIiwibmV3a2luZCIsImNoYXIiLCJjaGFyQ29kZSIsInRocmVzaG9sZHMiLCJfY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkIiwiYmFyVGhyZXNob2xkIiwic3BhY2VUaHJlc2hvbGQiLCJiaXRtYXNrIiwiQ09ERV9TSElGVCIsIkNPREVfQyIsIkNPREVfQiIsIkNPREVfQSIsIlNUQVJUX0NPREVfQSIsIlNUQVJUX0NPREVfQiIsIlNUQVJUX0NPREVfQyIsIlNUT1BfQ09ERSIsIk1PRFVMRV9JTkRJQ0VTIiwiX2NvcnJlY3QiLCJjYWxjdWxhdGVDb3JyZWN0aW9uIiwibXVsdGlwbGllciIsImNoZWNrc3VtIiwicmF3UmVzdWx0Iiwic2hpZnROZXh0IiwicmVtb3ZlTGFzdENoYXJhY3RlciIsImV4cGVjdGVkIiwic3VtTm9ybWFsaXplZCIsInN1bUV4cGVjdGVkIiwicGF0dGVybnMiLCJJT1EiLCJBWjA5IiwiX2NoZWNrQ2hlY2tzdW0iLCJzcGxpdCIsIl92ZXJpZnlFbmQiLCJfdmVyaWZ5Q2hlY2tzdW1zIiwiX2RlY29kZUV4dGVuZGVkIiwiY2hhckFycmF5IiwibmV4dENoYXIiLCJuZXh0Q2hhckNvZGUiLCJfbWF0Y2hDaGVja0NoYXIiLCJtYXhXZWlnaHQiLCJhcnJheVRvQ2hlY2siLCJ3ZWlnaHRlZFN1bXMiLCJ3ZWlnaHQiLCJjaGVja0NoYXIiLCJwYXJzZUludCIsIkNIRUNLX0RJR0lUX0VOQ09ESU5HUyIsImV4dGVuc2lvbkNoZWNrc3VtIiwiZGV0ZXJtaW5lQ2hlY2tEaWdpdCIsIm5vcm1hbGl6ZUJhclNwYWNlV2lkdGgiLCJNQVhfQ09SUkVDVElPTl9GQUNUT1IiLCJjb3VudGVyU3VtIiwiY29kZVN1bSIsImNvcnJlY3Rpb25SYXRpbyIsImNvcnJlY3Rpb25SYXRpb0ludmVyc2UiLCJfZGVjb2RlUGFpciIsImNvdW50ZXJQYWlyIiwiY29kZXMiLCJfZGV0ZXJtaW5lUGFyaXR5IiwibnJTeXN0ZW0iLCJfY29udmVydFRvVVBDQSIsInVwY2EiLCJsYXN0RGlnaXQiLCJjaGFyQXQiLCJzdWJzdHJpbmciXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNSQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2pCQSxpQkFBaUIsbUJBQU8sQ0FBQyxHQUFlO0FBQ3hDLGFBQWEsbUJBQU8sQ0FBQyxFQUFVOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsVUFBVTtBQUNWO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQy9CQSxtQkFBbUIsbUJBQU8sQ0FBQyxHQUFpQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6InF1YWdnYS5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoZmFjdG9yeS50b1N0cmluZygpKS5kZWZhdWx0O1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiUXVhZ2dhXCJdID0gZmFjdG9yeShmYWN0b3J5LnRvU3RyaW5nKCkpLmRlZmF1bHQ7XG5cdGVsc2Vcblx0XHRyb290W1wiUXVhZ2dhXCJdID0gZmFjdG9yeShmYWN0b3J5LnRvU3RyaW5nKCkpLmRlZmF1bHQ7XG59KSh0aGlzLCBmdW5jdGlvbihfX2ZhY3RvcnlTb3VyY2VfXykge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL215TW9kdWxlRGVmaW5pdGlvbiIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbiBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL1wiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDE2Nyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgYzA2YmRiNzhlY2NhMWU2YzcxNjAiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvaXNPYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4uL2NvbW1vbi9hcnJheV9oZWxwZXInO1xuXG5mdW5jdGlvbiBCYXJjb2RlUmVhZGVyKGNvbmZpZywgc3VwcGxlbWVudHMpIHtcbiAgICB0aGlzLl9yb3cgPSBbXTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICB0aGlzLnN1cHBsZW1lbnRzID0gc3VwcGxlbWVudHM7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbkJhcmNvZGVSZWFkZXIucHJvdG90eXBlLl9uZXh0VW5zZXQgPSBmdW5jdGlvbihsaW5lLCBzdGFydCkge1xuICAgIHZhciBpO1xuXG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFsaW5lW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGluZS5sZW5ndGg7XG59O1xuXG5CYXJjb2RlUmVhZGVyLnByb3RvdHlwZS5fbWF0Y2hQYXR0ZXJuID0gZnVuY3Rpb24oY291bnRlciwgY29kZSwgbWF4U2luZ2xlRXJyb3IpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgZXJyb3IgPSAwLFxuICAgICAgICBzaW5nbGVFcnJvciA9IDAsXG4gICAgICAgIHN1bSA9IDAsXG4gICAgICAgIG1vZHVsbyA9IDAsXG4gICAgICAgIGJhcldpZHRoLFxuICAgICAgICBjb3VudCxcbiAgICAgICAgc2NhbGVkO1xuXG4gICAgbWF4U2luZ2xlRXJyb3IgPSBtYXhTaW5nbGVFcnJvciB8fCB0aGlzLlNJTkdMRV9DT0RFX0VSUk9SIHx8IDE7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdW0gKz0gY291bnRlcltpXTtcbiAgICAgICAgbW9kdWxvICs9IGNvZGVbaV07XG4gICAgfVxuICAgIGlmIChzdW0gPCBtb2R1bG8pIHtcbiAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG4gICAgfVxuICAgIGJhcldpZHRoID0gc3VtIC8gbW9kdWxvO1xuICAgIG1heFNpbmdsZUVycm9yICo9IGJhcldpZHRoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY291bnQgPSBjb3VudGVyW2ldO1xuICAgICAgICBzY2FsZWQgPSBjb2RlW2ldICogYmFyV2lkdGg7XG4gICAgICAgIHNpbmdsZUVycm9yID0gTWF0aC5hYnMoY291bnQgLSBzY2FsZWQpIC8gc2NhbGVkO1xuICAgICAgICBpZiAoc2luZ2xlRXJyb3IgPiBtYXhTaW5nbGVFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IgKz0gc2luZ2xlRXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBlcnJvciAvIG1vZHVsbztcbn07XG5cbkJhcmNvZGVSZWFkZXIucHJvdG90eXBlLl9uZXh0U2V0ID0gZnVuY3Rpb24obGluZSwgb2Zmc2V0KSB7XG4gICAgdmFyIGk7XG5cbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsaW5lW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGluZS5sZW5ndGg7XG59O1xuXG5CYXJjb2RlUmVhZGVyLnByb3RvdHlwZS5fY29ycmVjdEJhcnMgPSBmdW5jdGlvbihjb3VudGVyLCBjb3JyZWN0aW9uLCBpbmRpY2VzKSB7XG4gICAgdmFyIGxlbmd0aCA9IGluZGljZXMubGVuZ3RoLFxuICAgICAgICB0bXAgPSAwO1xuICAgIHdoaWxlKGxlbmd0aC0tKSB7XG4gICAgICAgIHRtcCA9IGNvdW50ZXJbaW5kaWNlc1tsZW5ndGhdXSAqICgxIC0gKCgxIC0gY29ycmVjdGlvbikgLyAyKSk7XG4gICAgICAgIGlmICh0bXAgPiAxKSB7XG4gICAgICAgICAgICBjb3VudGVyW2luZGljZXNbbGVuZ3RoXV0gPSB0bXA7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkJhcmNvZGVSZWFkZXIucHJvdG90eXBlLl9tYXRjaFRyYWNlID0gZnVuY3Rpb24oY21wQ291bnRlciwgZXBzaWxvbikge1xuICAgIHZhciBjb3VudGVyID0gW10sXG4gICAgICAgIGksXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBvZmZzZXQgPSBzZWxmLl9uZXh0U2V0KHNlbGYuX3JvdyksXG4gICAgICAgIGlzV2hpdGUgPSAhc2VsZi5fcm93W29mZnNldF0sXG4gICAgICAgIGNvdW50ZXJQb3MgPSAwLFxuICAgICAgICBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I7XG5cbiAgICBpZiAoY21wQ291bnRlcikge1xuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGNtcENvdW50ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvdW50ZXIucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKCBpID0gb2Zmc2V0OyBpIDwgc2VsZi5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5fcm93W2ldIF4gaXNXaGl0ZSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHNlbGYuX21hdGNoUGF0dGVybihjb3VudGVyLCBjbXBDb3VudGVyKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY291bnRlciA9IGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvdW50ZXIucHVzaCgwKTtcbiAgICAgICAgZm9yICggaSA9IG9mZnNldDsgaSA8IHNlbGYuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHNlbGYuX3Jvd1tpXSBeIGlzV2hpdGUpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICBjb3VudGVyLnB1c2goMCk7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgY21wQ291bnRlciB3YXMgbm90IGdpdmVuXG4gICAgYmVzdE1hdGNoLnN0YXJ0ID0gb2Zmc2V0O1xuICAgIGJlc3RNYXRjaC5lbmQgPSBzZWxmLl9yb3cubGVuZ3RoIC0gMTtcbiAgICBiZXN0TWF0Y2guY291bnRlciA9IGNvdW50ZXI7XG4gICAgcmV0dXJuIGJlc3RNYXRjaDtcbn07XG5cbkJhcmNvZGVSZWFkZXIucHJvdG90eXBlLmRlY29kZVBhdHRlcm4gPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBzZWxmLl9yb3cgPSBwYXR0ZXJuO1xuICAgIHJlc3VsdCA9IHNlbGYuX2RlY29kZSgpO1xuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgc2VsZi5fcm93LnJldmVyc2UoKTtcbiAgICAgICAgcmVzdWx0ID0gc2VsZi5fZGVjb2RlKCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kaXJlY3Rpb24gPSBCYXJjb2RlUmVhZGVyLkRJUkVDVElPTi5SRVZFUlNFO1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gc2VsZi5fcm93Lmxlbmd0aCAtIHJlc3VsdC5zdGFydDtcbiAgICAgICAgICAgIHJlc3VsdC5lbmQgPSBzZWxmLl9yb3cubGVuZ3RoIC0gcmVzdWx0LmVuZDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5kaXJlY3Rpb24gPSBCYXJjb2RlUmVhZGVyLkRJUkVDVElPTi5GT1JXQVJEO1xuICAgIH1cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdC5mb3JtYXQgPSBzZWxmLkZPUk1BVDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkJhcmNvZGVSZWFkZXIucHJvdG90eXBlLl9tYXRjaFJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCwgdmFsdWUpIHtcbiAgICB2YXIgaTtcblxuICAgIHN0YXJ0ID0gc3RhcnQgPCAwID8gMCA6IHN0YXJ0O1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbkJhcmNvZGVSZWFkZXIucHJvdG90eXBlLl9maWxsQ291bnRlcnMgPSBmdW5jdGlvbihvZmZzZXQsIGVuZCwgaXNXaGl0ZSkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgY291bnRlclBvcyA9IDAsXG4gICAgICAgIGksXG4gICAgICAgIGNvdW50ZXJzID0gW107XG5cbiAgICBpc1doaXRlID0gKHR5cGVvZiBpc1doaXRlICE9PSAndW5kZWZpbmVkJykgPyBpc1doaXRlIDogdHJ1ZTtcbiAgICBvZmZzZXQgPSAodHlwZW9mIG9mZnNldCAhPT0gJ3VuZGVmaW5lZCcpID8gb2Zmc2V0IDogc2VsZi5fbmV4dFVuc2V0KHNlbGYuX3Jvdyk7XG4gICAgZW5kID0gZW5kIHx8IHNlbGYuX3Jvdy5sZW5ndGg7XG5cbiAgICBjb3VudGVyc1tjb3VudGVyUG9zXSA9IDA7XG4gICAgZm9yIChpID0gb2Zmc2V0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGYuX3Jvd1tpXSBeIGlzV2hpdGUpIHtcbiAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvdW50ZXJzO1xufTtcblxuQmFyY29kZVJlYWRlci5wcm90b3R5cGUuX3RvQ291bnRlcnMgPSBmdW5jdGlvbihzdGFydCwgY291bnRlcikge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgbnVtQ291bnRlcnMgPSBjb3VudGVyLmxlbmd0aCxcbiAgICAgICAgZW5kID0gc2VsZi5fcm93Lmxlbmd0aCxcbiAgICAgICAgaXNXaGl0ZSA9ICFzZWxmLl9yb3dbc3RhcnRdLFxuICAgICAgICBpLFxuICAgICAgICBjb3VudGVyUG9zID0gMDtcblxuICAgIEFycmF5SGVscGVyLmluaXQoY291bnRlciwgMCk7XG5cbiAgICBmb3IgKCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICBpZiAoc2VsZi5fcm93W2ldIF4gaXNXaGl0ZSkge1xuICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IG51bUNvdW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb3VudGVyO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhcmNvZGVSZWFkZXIucHJvdG90eXBlLCBcIkZPUk1BVFwiLCB7XG4gICAgdmFsdWU6ICd1bmtub3duJyxcbiAgICB3cml0ZWFibGU6IGZhbHNlXG59KTtcblxuQmFyY29kZVJlYWRlci5ESVJFQ1RJT04gPSB7XG4gICAgRk9SV0FSRDogMSxcbiAgICBSRVZFUlNFOiAtMVxufTtcblxuQmFyY29kZVJlYWRlci5FeGNlcHRpb24gPSB7XG4gICAgU3RhcnROb3RGb3VuZEV4Y2VwdGlvbjogXCJTdGFydC1JbmZvIHdhcyBub3QgZm91bmQhXCIsXG4gICAgQ29kZU5vdEZvdW5kRXhjZXB0aW9uOiBcIkNvZGUgY291bGQgbm90IGJlIGZvdW5kIVwiLFxuICAgIFBhdHRlcm5Ob3RGb3VuZEV4Y2VwdGlvbjogXCJQYXR0ZXJuIGNvdWxkIG5vdCBiZSBmb3VuZCFcIlxufTtcblxuQmFyY29kZVJlYWRlci5DT05GSUdfS0VZUyA9IHt9O1xuXG5leHBvcnQgZGVmYXVsdCBCYXJjb2RlUmVhZGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlYWRlci9iYXJjb2RlX3JlYWRlci5qcyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL2lzQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0IGRlZmF1bHQge1xuICAgIGluaXQ6IGZ1bmN0aW9uKGFyciwgdmFsKSB7XG4gICAgICAgIHZhciBsID0gYXJyLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGwtLSkge1xuICAgICAgICAgICAgYXJyW2xdID0gdmFsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNodWZmbGVzIHRoZSBjb250ZW50IG9mIGFuIGFycmF5XG4gICAgICogQHJldHVybiB7QXJyYXl9IHRoZSBhcnJheSBpdHNlbGYgc2h1ZmZsZWRcbiAgICAgKi9cbiAgICBzaHVmZmxlOiBmdW5jdGlvbihhcnIpIHtcbiAgICAgICAgdmFyIGkgPSBhcnIubGVuZ3RoIC0gMSwgaiwgeDtcbiAgICAgICAgZm9yIChpOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGkpO1xuICAgICAgICAgICAgeCA9IGFycltpXTtcbiAgICAgICAgICAgIGFycltpXSA9IGFycltqXTtcbiAgICAgICAgICAgIGFycltqXSA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuXG4gICAgdG9Qb2ludExpc3Q6IGZ1bmN0aW9uKGFycikge1xuICAgICAgICB2YXIgaSwgaiwgcm93ID0gW10sIHJvd3MgPSBbXTtcbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJvdyA9IFtdO1xuICAgICAgICAgICAgZm9yICggaiA9IDA7IGogPCBhcnJbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICByb3dbal0gPSBhcnJbaV1bal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dzW2ldID0gXCJbXCIgKyByb3cuam9pbihcIixcIikgKyBcIl1cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJbXCIgKyByb3dzLmpvaW4oXCIsXFxyXFxuXCIpICsgXCJdXCI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIGVsZW1lbnRzIHdoaWNoJ3Mgc2NvcmUgaXMgYmlnZ2VyIHRoYW4gdGhlIHRocmVzaG9sZFxuICAgICAqIEByZXR1cm4ge0FycmF5fSB0aGUgcmVkdWNlZCBhcnJheVxuICAgICAqL1xuICAgIHRocmVzaG9sZDogZnVuY3Rpb24oYXJyLCB0aHJlc2hvbGQsIHNjb3JlRnVuYykge1xuICAgICAgICB2YXIgaSwgcXVldWUgPSBbXTtcbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzY29yZUZ1bmMuYXBwbHkoYXJyLCBbYXJyW2ldXSkgPj0gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaChhcnJbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdWV1ZTtcbiAgICB9LFxuXG4gICAgbWF4SW5kZXg6IGZ1bmN0aW9uKGFycikge1xuICAgICAgICB2YXIgaSwgbWF4ID0gMDtcbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJbaV0gPiBhcnJbbWF4XSkge1xuICAgICAgICAgICAgICAgIG1heCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9LFxuXG4gICAgbWF4OiBmdW5jdGlvbihhcnIpIHtcbiAgICAgICAgdmFyIGksIG1heCA9IDA7XG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJyW2ldID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gYXJyW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfSxcblxuICAgIHN1bTogZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcnIubGVuZ3RoLFxuICAgICAgICAgICAgc3VtID0gMDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIHN1bSArPSBhcnJbbGVuZ3RoXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tbW9uL2FycmF5X2hlbHBlci5qcyIsImltcG9ydCBCYXJjb2RlUmVhZGVyIGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuaW1wb3J0IHttZXJnZX0gZnJvbSAnbG9kYXNoJztcblxuZnVuY3Rpb24gRUFOUmVhZGVyKG9wdHMsIHN1cHBsZW1lbnRzKSB7XG4gICAgb3B0cyA9IG1lcmdlKGdldERlZmF1bENvbmZpZygpLCBvcHRzKTtcbiAgICBCYXJjb2RlUmVhZGVyLmNhbGwodGhpcywgb3B0cywgc3VwcGxlbWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXREZWZhdWxDb25maWcoKSB7XG4gICAgdmFyIGNvbmZpZyA9IHt9O1xuXG4gICAgT2JqZWN0LmtleXMoRUFOUmVhZGVyLkNPTkZJR19LRVlTKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBjb25maWdba2V5XSA9IEVBTlJlYWRlci5DT05GSUdfS0VZU1trZXldLmRlZmF1bHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbmZpZztcbn1cblxudmFyIHByb3BlcnRpZXMgPSB7XG4gICAgQ09ERV9MX1NUQVJUOiB7dmFsdWU6IDB9LFxuICAgIENPREVfR19TVEFSVDoge3ZhbHVlOiAxMH0sXG4gICAgU1RBUlRfUEFUVEVSTjoge3ZhbHVlOiBbMSwgMSwgMV19LFxuICAgIFNUT1BfUEFUVEVSTjoge3ZhbHVlOiBbMSwgMSwgMV19LFxuICAgIE1JRERMRV9QQVRURVJOOiB7dmFsdWU6IFsxLCAxLCAxLCAxLCAxXX0sXG4gICAgRVhURU5TSU9OX1NUQVJUX1BBVFRFUk46IHt2YWx1ZTogWzEsIDEsIDJdfSxcbiAgICBDT0RFX1BBVFRFUk46IHt2YWx1ZTogW1xuICAgICAgICBbMywgMiwgMSwgMV0sXG4gICAgICAgIFsyLCAyLCAyLCAxXSxcbiAgICAgICAgWzIsIDEsIDIsIDJdLFxuICAgICAgICBbMSwgNCwgMSwgMV0sXG4gICAgICAgIFsxLCAxLCAzLCAyXSxcbiAgICAgICAgWzEsIDIsIDMsIDFdLFxuICAgICAgICBbMSwgMSwgMSwgNF0sXG4gICAgICAgIFsxLCAzLCAxLCAyXSxcbiAgICAgICAgWzEsIDIsIDEsIDNdLFxuICAgICAgICBbMywgMSwgMSwgMl0sXG4gICAgICAgIFsxLCAxLCAyLCAzXSxcbiAgICAgICAgWzEsIDIsIDIsIDJdLFxuICAgICAgICBbMiwgMiwgMSwgMl0sXG4gICAgICAgIFsxLCAxLCA0LCAxXSxcbiAgICAgICAgWzIsIDMsIDEsIDFdLFxuICAgICAgICBbMSwgMywgMiwgMV0sXG4gICAgICAgIFs0LCAxLCAxLCAxXSxcbiAgICAgICAgWzIsIDEsIDMsIDFdLFxuICAgICAgICBbMywgMSwgMiwgMV0sXG4gICAgICAgIFsyLCAxLCAxLCAzXVxuICAgIF19LFxuICAgIENPREVfRlJFUVVFTkNZOiB7dmFsdWU6IFswLCAxMSwgMTMsIDE0LCAxOSwgMjUsIDI4LCAyMSwgMjIsIDI2XX0sXG4gICAgU0lOR0xFX0NPREVfRVJST1I6IHt2YWx1ZTogMC43MH0sXG4gICAgQVZHX0NPREVfRVJST1I6IHt2YWx1ZTogMC40OH0sXG4gICAgRk9STUFUOiB7dmFsdWU6IFwiZWFuXzEzXCIsIHdyaXRlYWJsZTogZmFsc2V9XG59O1xuXG5FQU5SZWFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXJjb2RlUmVhZGVyLnByb3RvdHlwZSwgcHJvcGVydGllcyk7XG5FQU5SZWFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRUFOUmVhZGVyO1xuXG5FQU5SZWFkZXIucHJvdG90eXBlLl9kZWNvZGVDb2RlID0gZnVuY3Rpb24oc3RhcnQsIGNvZGVyYW5nZSkge1xuICAgIHZhciBjb3VudGVyID0gWzAsIDAsIDAsIDBdLFxuICAgICAgICBpLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgb2Zmc2V0ID0gc3RhcnQsXG4gICAgICAgIGlzV2hpdGUgPSAhc2VsZi5fcm93W29mZnNldF0sXG4gICAgICAgIGNvdW50ZXJQb3MgPSAwLFxuICAgICAgICBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBzdGFydFxuICAgICAgICB9LFxuICAgICAgICBjb2RlLFxuICAgICAgICBlcnJvcjtcblxuICAgIGlmICghY29kZXJhbmdlKSB7XG4gICAgICAgIGNvZGVyYW5nZSA9IHNlbGYuQ09ERV9QQVRURVJOLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IgKCBpID0gb2Zmc2V0OyBpIDwgc2VsZi5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmLl9yb3dbaV0gXiBpc1doaXRlKSB7XG4gICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb2RlID0gMDsgY29kZSA8IGNvZGVyYW5nZTsgY29kZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gc2VsZi5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHNlbGYuQ09ERV9QQVRURVJOW2NvZGVdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICBpZiAoYmVzdE1hdGNoLmVycm9yID4gc2VsZi5BVkdfQ09ERV9FUlJPUikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5FQU5SZWFkZXIucHJvdG90eXBlLl9maW5kUGF0dGVybiA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9mZnNldCwgaXNXaGl0ZSwgdHJ5SGFyZGVyLCBlcHNpbG9uKSB7XG4gICAgdmFyIGNvdW50ZXIgPSBbXSxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIGksXG4gICAgICAgIGNvdW50ZXJQb3MgPSAwLFxuICAgICAgICBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGosXG4gICAgICAgIHN1bTtcblxuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IHNlbGYuX25leHRTZXQoc2VsZi5fcm93KTtcbiAgICB9XG5cbiAgICBpZiAoaXNXaGl0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlzV2hpdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodHJ5SGFyZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdHJ5SGFyZGVyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIGVwc2lsb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlcHNpbG9uID0gc2VsZi5BVkdfQ09ERV9FUlJPUjtcbiAgICB9XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY291bnRlcltpXSA9IDA7XG4gICAgfVxuXG4gICAgZm9yICggaSA9IG9mZnNldDsgaSA8IHNlbGYuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZi5fcm93W2ldIF4gaXNXaGl0ZSkge1xuICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICggaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBjb3VudGVyW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlcnJvciA9IHNlbGYuX21hdGNoUGF0dGVybihjb3VudGVyLCBwYXR0ZXJuKTtcblxuICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBzdW07XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHJ5SGFyZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGogPSAwOyBqIDwgY291bnRlci5sZW5ndGggLSAyOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbkVBTlJlYWRlci5wcm90b3R5cGUuX2ZpbmRTdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgbGVhZGluZ1doaXRlc3BhY2VTdGFydCxcbiAgICAgICAgb2Zmc2V0ID0gc2VsZi5fbmV4dFNldChzZWxmLl9yb3cpLFxuICAgICAgICBzdGFydEluZm87XG5cbiAgICB3aGlsZSAoIXN0YXJ0SW5mbykge1xuICAgICAgICBzdGFydEluZm8gPSBzZWxmLl9maW5kUGF0dGVybihzZWxmLlNUQVJUX1BBVFRFUk4sIG9mZnNldCk7XG4gICAgICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID0gc3RhcnRJbmZvLnN0YXJ0IC0gKHN0YXJ0SW5mby5lbmQgLSBzdGFydEluZm8uc3RhcnQpO1xuICAgICAgICBpZiAobGVhZGluZ1doaXRlc3BhY2VTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5fbWF0Y2hSYW5nZShsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0LCBzdGFydEluZm8uc3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0SW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgPSBzdGFydEluZm8uZW5kO1xuICAgICAgICBzdGFydEluZm8gPSBudWxsO1xuICAgIH1cbn07XG5cbkVBTlJlYWRlci5wcm90b3R5cGUuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZSA9IGZ1bmN0aW9uKGVuZEluZm8pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIHRyYWlsaW5nV2hpdGVzcGFjZUVuZDtcblxuICAgIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCk7XG4gICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHNlbGYuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHNlbGYuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuRUFOUmVhZGVyLnByb3RvdHlwZS5fZmluZEVuZCA9IGZ1bmN0aW9uKG9mZnNldCwgaXNXaGl0ZSkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgZW5kSW5mbyA9IHNlbGYuX2ZpbmRQYXR0ZXJuKHNlbGYuU1RPUF9QQVRURVJOLCBvZmZzZXQsIGlzV2hpdGUsIGZhbHNlKTtcblxuICAgIHJldHVybiBlbmRJbmZvICE9PSBudWxsID8gc2VsZi5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pIDogbnVsbDtcbn07XG5cbkVBTlJlYWRlci5wcm90b3R5cGUuX2NhbGN1bGF0ZUZpcnN0RGlnaXQgPSBmdW5jdGlvbihjb2RlRnJlcXVlbmN5KSB7XG4gICAgdmFyIGksXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgZm9yICggaSA9IDA7IGkgPCBzZWxmLkNPREVfRlJFUVVFTkNZLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjb2RlRnJlcXVlbmN5ID09PSBzZWxmLkNPREVfRlJFUVVFTkNZW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbkVBTlJlYWRlci5wcm90b3R5cGUuX2RlY29kZVBheWxvYWQgPSBmdW5jdGlvbihjb2RlLCByZXN1bHQsIGRlY29kZWRDb2Rlcykge1xuICAgIHZhciBpLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgY29kZUZyZXF1ZW5jeSA9IDB4MCxcbiAgICAgICAgZmlyc3REaWdpdDtcblxuICAgIGZvciAoIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgIGNvZGUgPSBzZWxmLl9kZWNvZGVDb2RlKGNvZGUuZW5kKTtcbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZS5jb2RlID49IHNlbGYuQ09ERV9HX1NUQVJUKSB7XG4gICAgICAgICAgICBjb2RlLmNvZGUgPSBjb2RlLmNvZGUgLSBzZWxmLkNPREVfR19TVEFSVDtcbiAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gMSA8PCAoNSAtIGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAwIDw8ICg1IC0gaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goY29kZS5jb2RlKTtcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgfVxuXG4gICAgZmlyc3REaWdpdCA9IHNlbGYuX2NhbGN1bGF0ZUZpcnN0RGlnaXQoY29kZUZyZXF1ZW5jeSk7XG4gICAgaWYgKGZpcnN0RGlnaXQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC51bnNoaWZ0KGZpcnN0RGlnaXQpO1xuXG4gICAgY29kZSA9IHNlbGYuX2ZpbmRQYXR0ZXJuKHNlbGYuTUlERExFX1BBVFRFUk4sIGNvZGUuZW5kLCB0cnVlLCBmYWxzZSk7XG4gICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuXG4gICAgZm9yICggaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgY29kZSA9IHNlbGYuX2RlY29kZUNvZGUoY29kZS5lbmQsIHNlbGYuQ09ERV9HX1NUQVJUKTtcbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgcmVzdWx0LnB1c2goY29kZS5jb2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29kZTtcbn07XG5cbkVBTlJlYWRlci5wcm90b3R5cGUuX2RlY29kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFydEluZm8sXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBjb2RlLFxuICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgZGVjb2RlZENvZGVzID0gW10sXG4gICAgICAgIHJlc3VsdEluZm8gPSB7fTtcblxuICAgIHN0YXJ0SW5mbyA9IHNlbGYuX2ZpbmRTdGFydCgpO1xuICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb2RlID0ge1xuICAgICAgICBjb2RlOiBzdGFydEluZm8uY29kZSxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgZW5kOiBzdGFydEluZm8uZW5kXG4gICAgfTtcbiAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICBjb2RlID0gc2VsZi5fZGVjb2RlUGF5bG9hZChjb2RlLCByZXN1bHQsIGRlY29kZWRDb2Rlcyk7XG4gICAgaWYgKCFjb2RlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb2RlID0gc2VsZi5fZmluZEVuZChjb2RlLmVuZCwgZmFsc2UpO1xuICAgIGlmICghY29kZSl7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuXG4gICAgLy8gQ2hlY2tzdW1cbiAgICBpZiAoIXNlbGYuX2NoZWNrc3VtKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3VwcGxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBsZXQgZXh0ID0gdGhpcy5fZGVjb2RlRXh0ZW5zaW9ucyhjb2RlLmVuZCk7XG4gICAgICAgIGlmICghZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGFzdENvZGUgPSBleHQuZGVjb2RlZENvZGVzW2V4dC5kZWNvZGVkQ29kZXMubGVuZ3RoLTFdLFxuICAgICAgICAgICAgZW5kSW5mbyA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogbGFzdENvZGUuc3RhcnQgKyAoKChsYXN0Q29kZS5lbmQgLSBsYXN0Q29kZS5zdGFydCkgLyAyKSB8IDApLFxuICAgICAgICAgICAgICAgIGVuZDogbGFzdENvZGUuZW5kXG4gICAgICAgICAgICB9O1xuICAgICAgICBpZighc2VsZi5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRJbmZvID0ge1xuICAgICAgICAgICAgc3VwcGxlbWVudDogZXh0LFxuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oXCJcIikgKyBleHQuY29kZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oXCJcIiksXG4gICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgIGVuZDogY29kZS5lbmQsXG4gICAgICAgIGNvZGVzZXQ6IFwiXCIsXG4gICAgICAgIHN0YXJ0SW5mbzogc3RhcnRJbmZvLFxuICAgICAgICBkZWNvZGVkQ29kZXM6IGRlY29kZWRDb2RlcyxcbiAgICAgICAgLi4ucmVzdWx0SW5mb1xuICAgIH07XG59O1xuXG5FQU5SZWFkZXIucHJvdG90eXBlLl9kZWNvZGVFeHRlbnNpb25zID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgdmFyIGksXG4gICAgICAgIHN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIG9mZnNldCksXG4gICAgICAgIHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKHRoaXMuRVhURU5TSU9OX1NUQVJUX1BBVFRFUk4sIHN0YXJ0LCBmYWxzZSwgZmFsc2UpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoc3RhcnRJbmZvID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnN1cHBsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuc3VwcGxlbWVudHNbaV0uZGVjb2RlKHRoaXMuX3Jvdywgc3RhcnRJbmZvLmVuZCk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29kZTogcmVzdWx0LmNvZGUsXG4gICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgc3RhcnRJbmZvLFxuICAgICAgICAgICAgICAgIGVuZDogcmVzdWx0LmVuZCxcbiAgICAgICAgICAgICAgICBjb2Rlc2V0OiBcIlwiLFxuICAgICAgICAgICAgICAgIGRlY29kZWRDb2RlczogcmVzdWx0LmRlY29kZWRDb2Rlc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuRUFOUmVhZGVyLnByb3RvdHlwZS5fY2hlY2tzdW0gPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICB2YXIgc3VtID0gMCwgaTtcblxuICAgIGZvciAoIGkgPSByZXN1bHQubGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgc3VtICs9IHJlc3VsdFtpXTtcbiAgICB9XG4gICAgc3VtICo9IDM7XG4gICAgZm9yICggaSA9IHJlc3VsdC5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICBzdW0gKz0gcmVzdWx0W2ldO1xuICAgIH1cbiAgICByZXR1cm4gc3VtICUgMTAgPT09IDA7XG59O1xuXG5FQU5SZWFkZXIuQ09ORklHX0tFWVMgPSB7XG4gICAgc3VwcGxlbWVudHM6IHtcbiAgICAgICAgJ3R5cGUnOiAnYXJyYXlPZihzdHJpbmcpJyxcbiAgICAgICAgJ2RlZmF1bHQnOiBbXSxcbiAgICAgICAgJ2Rlc2NyaXB0aW9uJzogJ0FsbG93ZWQgZXh0ZW5zaW9ucyB0byBiZSBkZWNvZGVkICgyIGFuZC9vciA1KSdcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCAoRUFOUmVhZGVyKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZWFkZXIvZWFuX3JlYWRlci5qcyIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX3Jvb3QuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9pc09iamVjdExpa2UuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBjbG9uZVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gY2xvbmUoYSkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDIpXG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGFbMV1cbiAgICByZXR1cm4gb3V0XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2dsLXZlYzIvY2xvbmUuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VHZXRUYWcuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0IGRlZmF1bHQge1xuICAgIGRyYXdSZWN0OiBmdW5jdGlvbihwb3MsIHNpemUsIGN0eCwgc3R5bGUpe1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoIHx8IDE7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZVJlY3QocG9zLngsIHBvcy55LCBzaXplLngsIHNpemUueSk7XG4gICAgfSxcbiAgICBkcmF3UGF0aDogZnVuY3Rpb24ocGF0aCwgZGVmLCBjdHgsIHN0eWxlKSB7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gc3R5bGUuY29sb3I7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBzdHlsZS5saW5lV2lkdGg7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhwYXRoWzBdW2RlZi54XSwgcGF0aFswXVtkZWYueV0pO1xuICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHBhdGgubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8ocGF0aFtqXVtkZWYueF0sIHBhdGhbal1bZGVmLnldKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9LFxuICAgIGRyYXdJbWFnZTogZnVuY3Rpb24oaW1hZ2VEYXRhLCBzaXplLCBjdHgpIHtcbiAgICAgICAgdmFyIGNhbnZhc0RhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHNpemUueCwgc2l6ZS55KSxcbiAgICAgICAgICAgIGRhdGEgPSBjYW52YXNEYXRhLmRhdGEsXG4gICAgICAgICAgICBpbWFnZURhdGFQb3MgPSBpbWFnZURhdGEubGVuZ3RoLFxuICAgICAgICAgICAgY2FudmFzRGF0YVBvcyA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgICAgdmFsdWU7XG5cbiAgICAgICAgaWYgKGNhbnZhc0RhdGFQb3MgLyBpbWFnZURhdGFQb3MgIT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaW1hZ2VEYXRhUG9zLS0pe1xuICAgICAgICAgICAgdmFsdWUgPSBpbWFnZURhdGFbaW1hZ2VEYXRhUG9zXTtcbiAgICAgICAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IDI1NTtcbiAgICAgICAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IHZhbHVlO1xuICAgICAgICAgICAgZGF0YVstLWNhbnZhc0RhdGFQb3NdID0gdmFsdWU7XG4gICAgICAgICAgICBkYXRhWy0tY2FudmFzRGF0YVBvc10gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGNhbnZhc0RhdGEsIDAsIDApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbW1vbi9pbWFnZV9kZWJ1Zy5qcyIsInZhciBsaXN0Q2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUNsZWFyJyksXG4gICAgbGlzdENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlRGVsZXRlJyksXG4gICAgbGlzdENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlR2V0JyksXG4gICAgbGlzdENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlSGFzJyksXG4gICAgbGlzdENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0Q2FjaGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19MaXN0Q2FjaGUuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19TeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NvY0luZGV4T2Y7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19hc3NvY0luZGV4T2YuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHN0cmluZ1RvUGF0aCA9IHJlcXVpcmUoJy4vX3N0cmluZ1RvUGF0aCcpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RQYXRoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fY2FzdFBhdGguanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc0tleWFibGUgPSByZXF1aXJlKCcuL19pc0tleWFibGUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcERhdGE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19nZXRNYXBEYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbmRleDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2lzSW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVDcmVhdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19uYXRpdmVDcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9lcS5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VJc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vX2Jhc2VJc0FyZ3VtZW50cycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9pc0FyZ3VtZW50cy5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IENsdXN0ZXIyIGZyb20gJy4vY2x1c3Rlcic7XG5pbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi9hcnJheV9oZWxwZXInO1xuY29uc3QgdmVjMiA9IHtcbiAgICBjbG9uZTogcmVxdWlyZSgnZ2wtdmVjMi9jbG9uZScpLFxufTtcbmNvbnN0IHZlYzMgPSB7XG4gICAgY2xvbmU6IHJlcXVpcmUoJ2dsLXZlYzMvY2xvbmUnKSxcbn07XG5cbi8qKlxuICogQHBhcmFtIHggeC1jb29yZGluYXRlXG4gKiBAcGFyYW0geSB5LWNvb3JkaW5hdGVcbiAqIEByZXR1cm4gSW1hZ2VSZWZlcmVuY2Uge3gseX0gQ29vcmRpbmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW1hZ2VSZWYoeCwgeSkge1xuICAgIHZhciB0aGF0ID0ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB0b1ZlYzI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZlYzIuY2xvbmUoW3RoaXMueCwgdGhpcy55XSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvVmVjMzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdmVjMy5jbG9uZShbdGhpcy54LCB0aGlzLnksIDFdKTtcbiAgICAgICAgfSxcbiAgICAgICAgcm91bmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy54ID0gdGhpcy54ID4gMC4wID8gTWF0aC5mbG9vcih0aGlzLnggKyAwLjUpIDogTWF0aC5mbG9vcih0aGlzLnggLSAwLjUpO1xuICAgICAgICAgICAgdGhpcy55ID0gdGhpcy55ID4gMC4wID8gTWF0aC5mbG9vcih0aGlzLnkgKyAwLjUpIDogTWF0aC5mbG9vcih0aGlzLnkgLSAwLjUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB0aGF0O1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyBhbiBpbnRlZ3JhbCBpbWFnZSBvZiBhIGdpdmVuIGdyYXlzY2FsZSBpbWFnZS5cbiAqIEBwYXJhbSBpbWFnZURhdGFDb250YWluZXIge0ltYWdlRGF0YUNvbnRhaW5lcn0gdGhlIGltYWdlIHRvIGJlIGludGVncmF0ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVJbnRlZ3JhbEltYWdlMihpbWFnZVdyYXBwZXIsIGludGVncmFsV3JhcHBlcikge1xuICAgIHZhciBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICB2YXIgd2lkdGggPSBpbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIHZhciBoZWlnaHQgPSBpbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIHZhciBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xuICAgIHZhciBzdW0gPSAwLCBwb3NBID0gMCwgcG9zQiA9IDAsIHBvc0MgPSAwLCBwb3NEID0gMCwgeCwgeTtcblxuICAgIC8vIHN1bSB1cCBmaXJzdCBjb2x1bW5cbiAgICBwb3NCID0gd2lkdGg7XG4gICAgc3VtID0gMDtcbiAgICBmb3IgKCB5ID0gMTsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgIHN1bSArPSBpbWFnZURhdGFbcG9zQV07XG4gICAgICAgIGludGVncmFsSW1hZ2VEYXRhW3Bvc0JdICs9IHN1bTtcbiAgICAgICAgcG9zQSArPSB3aWR0aDtcbiAgICAgICAgcG9zQiArPSB3aWR0aDtcbiAgICB9XG5cbiAgICBwb3NBID0gMDtcbiAgICBwb3NCID0gMTtcbiAgICBzdW0gPSAwO1xuICAgIGZvciAoIHggPSAxOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICBzdW0gKz0gaW1hZ2VEYXRhW3Bvc0FdO1xuICAgICAgICBpbnRlZ3JhbEltYWdlRGF0YVtwb3NCXSArPSBzdW07XG4gICAgICAgIHBvc0ErKztcbiAgICAgICAgcG9zQisrO1xuICAgIH1cblxuICAgIGZvciAoIHkgPSAxOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgcG9zQSA9IHkgKiB3aWR0aCArIDE7XG4gICAgICAgIHBvc0IgPSAoeSAtIDEpICogd2lkdGggKyAxO1xuICAgICAgICBwb3NDID0geSAqIHdpZHRoO1xuICAgICAgICBwb3NEID0gKHkgLSAxKSAqIHdpZHRoO1xuICAgICAgICBmb3IgKCB4ID0gMTsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgIGludGVncmFsSW1hZ2VEYXRhW3Bvc0FdICs9XG4gICAgICAgICAgICAgICAgaW1hZ2VEYXRhW3Bvc0FdICsgaW50ZWdyYWxJbWFnZURhdGFbcG9zQl0gKyBpbnRlZ3JhbEltYWdlRGF0YVtwb3NDXSAtIGludGVncmFsSW1hZ2VEYXRhW3Bvc0RdO1xuICAgICAgICAgICAgcG9zQSsrO1xuICAgICAgICAgICAgcG9zQisrO1xuICAgICAgICAgICAgcG9zQysrO1xuICAgICAgICAgICAgcG9zRCsrO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVJbnRlZ3JhbEltYWdlKGltYWdlV3JhcHBlciwgaW50ZWdyYWxXcmFwcGVyKSB7XG4gICAgdmFyIGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgIHZhciB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgdmFyIGhlaWdodCA9IGltYWdlV3JhcHBlci5zaXplLnk7XG4gICAgdmFyIGludGVncmFsSW1hZ2VEYXRhID0gaW50ZWdyYWxXcmFwcGVyLmRhdGE7XG4gICAgdmFyIHN1bSA9IDA7XG5cbiAgICAvLyBzdW0gdXAgZmlyc3Qgcm93XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgIHN1bSArPSBpbWFnZURhdGFbaV07XG4gICAgICAgIGludGVncmFsSW1hZ2VEYXRhW2ldID0gc3VtO1xuICAgIH1cblxuICAgIGZvciAodmFyIHYgPSAxOyB2IDwgaGVpZ2h0OyB2KyspIHtcbiAgICAgICAgc3VtID0gMDtcbiAgICAgICAgZm9yICh2YXIgdSA9IDA7IHUgPCB3aWR0aDsgdSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gaW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdO1xuICAgICAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbKCh2KSAqIHdpZHRoKSArIHVdID0gc3VtICsgaW50ZWdyYWxJbWFnZURhdGFbKHYgLSAxKSAqIHdpZHRoICsgdV07XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdGhyZXNob2xkSW1hZ2UoaW1hZ2VXcmFwcGVyLCB0aHJlc2hvbGQsIHRhcmdldFdyYXBwZXIpIHtcbiAgICBpZiAoIXRhcmdldFdyYXBwZXIpIHtcbiAgICAgICAgdGFyZ2V0V3JhcHBlciA9IGltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgdmFyIGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhLCBsZW5ndGggPSBpbWFnZURhdGEubGVuZ3RoLCB0YXJnZXREYXRhID0gdGFyZ2V0V3JhcHBlci5kYXRhO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHRhcmdldERhdGFbbGVuZ3RoXSA9IGltYWdlRGF0YVtsZW5ndGhdIDwgdGhyZXNob2xkID8gMSA6IDA7XG4gICAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVIaXN0b2dyYW0oaW1hZ2VXcmFwcGVyLCBiaXRzUGVyUGl4ZWwpIHtcbiAgICBpZiAoIWJpdHNQZXJQaXhlbCkge1xuICAgICAgICBiaXRzUGVyUGl4ZWwgPSA4O1xuICAgIH1cbiAgICB2YXIgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGEsXG4gICAgICAgIGxlbmd0aCA9IGltYWdlRGF0YS5sZW5ndGgsXG4gICAgICAgIGJpdFNoaWZ0ID0gOCAtIGJpdHNQZXJQaXhlbCxcbiAgICAgICAgYnVja2V0Q250ID0gMSA8PCBiaXRzUGVyUGl4ZWwsXG4gICAgICAgIGhpc3QgPSBuZXcgSW50MzJBcnJheShidWNrZXRDbnQpO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGhpc3RbaW1hZ2VEYXRhW2xlbmd0aF0gPj4gYml0U2hpZnRdKys7XG4gICAgfVxuICAgIHJldHVybiBoaXN0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHNoYXJwZW5MaW5lKGxpbmUpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbGVuZ3RoID0gbGluZS5sZW5ndGgsXG4gICAgICAgIGxlZnQgPSBsaW5lWzBdLFxuICAgICAgICBjZW50ZXIgPSBsaW5lWzFdLFxuICAgICAgICByaWdodDtcblxuICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgcmlnaHQgPSBsaW5lW2kgKyAxXTtcbiAgICAgICAgLy8gIC0xIDQgLTEga2VybmVsXG4gICAgICAgIGxpbmVbaSAtIDFdID0gKCgoY2VudGVyICogMikgLSBsZWZ0IC0gcmlnaHQpKSAmIDI1NTtcbiAgICAgICAgbGVmdCA9IGNlbnRlcjtcbiAgICAgICAgY2VudGVyID0gcmlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBsaW5lO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluZU90c3VUaHJlc2hvbGQoaW1hZ2VXcmFwcGVyLCBiaXRzUGVyUGl4ZWwpIHtcbiAgICBpZiAoIWJpdHNQZXJQaXhlbCkge1xuICAgICAgICBiaXRzUGVyUGl4ZWwgPSA4O1xuICAgIH1cbiAgICB2YXIgaGlzdCxcbiAgICAgICAgdGhyZXNob2xkLFxuICAgICAgICBiaXRTaGlmdCA9IDggLSBiaXRzUGVyUGl4ZWw7XG5cbiAgICBmdW5jdGlvbiBweChpbml0LCBlbmQpIHtcbiAgICAgICAgdmFyIHN1bSA9IDAsIGk7XG4gICAgICAgIGZvciAoIGkgPSBpbml0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gaGlzdFtpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG14KGluaXQsIGVuZCkge1xuICAgICAgICB2YXIgaSwgc3VtID0gMDtcblxuICAgICAgICBmb3IgKCBpID0gaW5pdDsgaSA8PSBlbmQ7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IGkgKiBoaXN0W2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXRlcm1pbmVUaHJlc2hvbGQoKSB7XG4gICAgICAgIHZhciB2ZXQgPSBbMF0sIHAxLCBwMiwgcDEyLCBrLCBtMSwgbTIsIG0xMixcbiAgICAgICAgICAgIG1heCA9ICgxIDw8IGJpdHNQZXJQaXhlbCkgLSAxO1xuXG4gICAgICAgIGhpc3QgPSBjb21wdXRlSGlzdG9ncmFtKGltYWdlV3JhcHBlciwgYml0c1BlclBpeGVsKTtcbiAgICAgICAgZm9yICggayA9IDE7IGsgPCBtYXg7IGsrKykge1xuICAgICAgICAgICAgcDEgPSBweCgwLCBrKTtcbiAgICAgICAgICAgIHAyID0gcHgoayArIDEsIG1heCk7XG4gICAgICAgICAgICBwMTIgPSBwMSAqIHAyO1xuICAgICAgICAgICAgaWYgKHAxMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHAxMiA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtMSA9IG14KDAsIGspICogcDI7XG4gICAgICAgICAgICBtMiA9IG14KGsgKyAxLCBtYXgpICogcDE7XG4gICAgICAgICAgICBtMTIgPSBtMSAtIG0yO1xuICAgICAgICAgICAgdmV0W2tdID0gbTEyICogbTEyIC8gcDEyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBcnJheUhlbHBlci5tYXhJbmRleCh2ZXQpO1xuICAgIH1cblxuICAgIHRocmVzaG9sZCA9IGRldGVybWluZVRocmVzaG9sZCgpO1xuICAgIHJldHVybiB0aHJlc2hvbGQgPDwgYml0U2hpZnQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gb3RzdVRocmVzaG9sZChpbWFnZVdyYXBwZXIsIHRhcmdldFdyYXBwZXIpIHtcbiAgICB2YXIgdGhyZXNob2xkID0gZGV0ZXJtaW5lT3RzdVRocmVzaG9sZChpbWFnZVdyYXBwZXIpO1xuXG4gICAgdGhyZXNob2xkSW1hZ2UoaW1hZ2VXcmFwcGVyLCB0aHJlc2hvbGQsIHRhcmdldFdyYXBwZXIpO1xuICAgIHJldHVybiB0aHJlc2hvbGQ7XG59O1xuXG4vLyBsb2NhbCB0aHJlc2hvbGRpbmdcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQmluYXJ5SW1hZ2UoaW1hZ2VXcmFwcGVyLCBpbnRlZ3JhbFdyYXBwZXIsIHRhcmdldFdyYXBwZXIpIHtcbiAgICBjb21wdXRlSW50ZWdyYWxJbWFnZShpbWFnZVdyYXBwZXIsIGludGVncmFsV3JhcHBlcik7XG5cbiAgICBpZiAoIXRhcmdldFdyYXBwZXIpIHtcbiAgICAgICAgdGFyZ2V0V3JhcHBlciA9IGltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgdmFyIGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgIHZhciB0YXJnZXREYXRhID0gdGFyZ2V0V3JhcHBlci5kYXRhO1xuICAgIHZhciB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgdmFyIGhlaWdodCA9IGltYWdlV3JhcHBlci5zaXplLnk7XG4gICAgdmFyIGludGVncmFsSW1hZ2VEYXRhID0gaW50ZWdyYWxXcmFwcGVyLmRhdGE7XG4gICAgdmFyIHN1bSA9IDAsIHYsIHUsIGtlcm5lbCA9IDMsIEEsIEIsIEMsIEQsIGF2Zywgc2l6ZSA9IChrZXJuZWwgKiAyICsgMSkgKiAoa2VybmVsICogMiArIDEpO1xuXG4gICAgLy8gY2xlYXIgb3V0IHRvcCAmIGJvdHRvbS1ib3JkZXJcbiAgICBmb3IgKCB2ID0gMDsgdiA8PSBrZXJuZWw7IHYrKykge1xuICAgICAgICBmb3IgKCB1ID0gMDsgdSA8IHdpZHRoOyB1KyspIHtcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCh2KSAqIHdpZHRoKSArIHVdID0gMDtcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCgoaGVpZ2h0IC0gMSkgLSB2KSAqIHdpZHRoKSArIHVdID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNsZWFyIG91dCBsZWZ0ICYgcmlnaHQgYm9yZGVyXG4gICAgZm9yICggdiA9IGtlcm5lbDsgdiA8IGhlaWdodCAtIGtlcm5lbDsgdisrKSB7XG4gICAgICAgIGZvciAoIHUgPSAwOyB1IDw9IGtlcm5lbDsgdSsrKSB7XG4gICAgICAgICAgICB0YXJnZXREYXRhWygodikgKiB3aWR0aCkgKyB1XSA9IDA7XG4gICAgICAgICAgICB0YXJnZXREYXRhWygodikgKiB3aWR0aCkgKyAod2lkdGggLSAxIC0gdSldID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoIHYgPSBrZXJuZWwgKyAxOyB2IDwgaGVpZ2h0IC0ga2VybmVsIC0gMTsgdisrKSB7XG4gICAgICAgIGZvciAoIHUgPSBrZXJuZWwgKyAxOyB1IDwgd2lkdGggLSBrZXJuZWw7IHUrKykge1xuICAgICAgICAgICAgQSA9IGludGVncmFsSW1hZ2VEYXRhWyh2IC0ga2VybmVsIC0gMSkgKiB3aWR0aCArICh1IC0ga2VybmVsIC0gMSldO1xuICAgICAgICAgICAgQiA9IGludGVncmFsSW1hZ2VEYXRhWyh2IC0ga2VybmVsIC0gMSkgKiB3aWR0aCArICh1ICsga2VybmVsKV07XG4gICAgICAgICAgICBDID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgKyBrZXJuZWwpICogd2lkdGggKyAodSAtIGtlcm5lbCAtIDEpXTtcbiAgICAgICAgICAgIEQgPSBpbnRlZ3JhbEltYWdlRGF0YVsodiArIGtlcm5lbCkgKiB3aWR0aCArICh1ICsga2VybmVsKV07XG4gICAgICAgICAgICBzdW0gPSBEIC0gQyAtIEIgKyBBO1xuICAgICAgICAgICAgYXZnID0gc3VtIC8gKHNpemUpO1xuICAgICAgICAgICAgdGFyZ2V0RGF0YVt2ICogd2lkdGggKyB1XSA9IGltYWdlRGF0YVt2ICogd2lkdGggKyB1XSA+IChhdmcgKyA1KSA/IDAgOiAxO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNsdXN0ZXIocG9pbnRzLCB0aHJlc2hvbGQsIHByb3BlcnR5KSB7XG4gICAgdmFyIGksIGssIGNsdXN0ZXIsIHBvaW50LCBjbHVzdGVycyA9IFtdO1xuXG4gICAgaWYgKCFwcm9wZXJ0eSkge1xuICAgICAgICBwcm9wZXJ0eSA9IFwicmFkXCI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkVG9DbHVzdGVyKG5ld1BvaW50KSB7XG4gICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKCBrID0gMDsgayA8IGNsdXN0ZXJzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBjbHVzdGVyID0gY2x1c3RlcnNba107XG4gICAgICAgICAgICBpZiAoY2x1c3Rlci5maXRzKG5ld1BvaW50KSkge1xuICAgICAgICAgICAgICAgIGNsdXN0ZXIuYWRkKG5ld1BvaW50KTtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cblxuICAgIC8vIGl0ZXJhdGUgb3ZlciBlYWNoIGNsb3VkXG4gICAgZm9yICggaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcG9pbnQgPSBDbHVzdGVyMi5jcmVhdGVQb2ludChwb2ludHNbaV0sIGksIHByb3BlcnR5KTtcbiAgICAgICAgaWYgKCFhZGRUb0NsdXN0ZXIocG9pbnQpKSB7XG4gICAgICAgICAgICBjbHVzdGVycy5wdXNoKENsdXN0ZXIyLmNyZWF0ZShwb2ludCwgdGhyZXNob2xkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsdXN0ZXJzO1xufTtcblxuZXhwb3J0IGNvbnN0IFRyYWNlciA9IHtcbiAgICB0cmFjZTogZnVuY3Rpb24ocG9pbnRzLCB2ZWMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdGlvbiwgbWF4SXRlcmF0aW9ucyA9IDEwLCB0b3AgPSBbXSwgcmVzdWx0ID0gW10sIGNlbnRlclBvcyA9IDAsIGN1cnJlbnRQb3MgPSAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIHRyYWNlKGlkeCwgZm9yd2FyZCkge1xuICAgICAgICAgICAgdmFyIGZyb20sIHRvLCB0b0lkeCwgcHJlZGljdGVkUG9zLCB0aHJlc2hvbGRYID0gMSwgdGhyZXNob2xkWSA9IE1hdGguYWJzKHZlY1sxXSAvIDEwKSwgZm91bmQgPSBmYWxzZTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gbWF0Y2gocG9zLCBwcmVkaWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zLnggPiAocHJlZGljdGVkLnggLSB0aHJlc2hvbGRYKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnggPCAocHJlZGljdGVkLnggKyB0aHJlc2hvbGRYKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnkgPiAocHJlZGljdGVkLnkgLSB0aHJlc2hvbGRZKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnkgPCAocHJlZGljdGVkLnkgKyB0aHJlc2hvbGRZKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgbmV4dCBpbmRleCBpcyB3aXRoaW4gdGhlIHZlYyBzcGVjaWZpY2F0aW9uc1xuICAgICAgICAgICAgLy8gaWYgbm90LCBjaGVjayBhcyBsb25nIGFzIHRoZSB0aHJlc2hvbGQgaXMgbWV0XG5cbiAgICAgICAgICAgIGZyb20gPSBwb2ludHNbaWR4XTtcbiAgICAgICAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgICAgICAgICAgcHJlZGljdGVkUG9zID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBmcm9tLnggKyB2ZWNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHk6IGZyb20ueSArIHZlY1sxXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZWRpY3RlZFBvcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogZnJvbS54IC0gdmVjWzBdLFxuICAgICAgICAgICAgICAgICAgICB5OiBmcm9tLnkgLSB2ZWNbMV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b0lkeCA9IGZvcndhcmQgPyBpZHggKyAxIDogaWR4IC0gMTtcbiAgICAgICAgICAgIHRvID0gcG9pbnRzW3RvSWR4XTtcbiAgICAgICAgICAgIHdoaWxlICh0byAmJiAoIGZvdW5kID0gbWF0Y2godG8sIHByZWRpY3RlZFBvcykpICE9PSB0cnVlICYmIChNYXRoLmFicyh0by55IC0gZnJvbS55KSA8IHZlY1sxXSkpIHtcbiAgICAgICAgICAgICAgICB0b0lkeCA9IGZvcndhcmQgPyB0b0lkeCArIDEgOiB0b0lkeCAtIDE7XG4gICAgICAgICAgICAgICAgdG8gPSBwb2ludHNbdG9JZHhdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZm91bmQgPyB0b0lkeCA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCBpdGVyYXRpb24gPSAwOyBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zOyBpdGVyYXRpb24rKykge1xuICAgICAgICAgICAgLy8gcmFuZG9tbHkgc2VsZWN0IHBvaW50IHRvIHN0YXJ0IHdpdGhcbiAgICAgICAgICAgIGNlbnRlclBvcyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvaW50cy5sZW5ndGgpO1xuXG4gICAgICAgICAgICAvLyB0cmFjZSBmb3J3YXJkXG4gICAgICAgICAgICB0b3AgPSBbXTtcbiAgICAgICAgICAgIGN1cnJlbnRQb3MgPSBjZW50ZXJQb3M7XG4gICAgICAgICAgICB0b3AucHVzaChwb2ludHNbY3VycmVudFBvc10pO1xuICAgICAgICAgICAgd2hpbGUgKCggY3VycmVudFBvcyA9IHRyYWNlKGN1cnJlbnRQb3MsIHRydWUpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRvcC5wdXNoKHBvaW50c1tjdXJyZW50UG9zXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2VudGVyUG9zID4gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MgPSBjZW50ZXJQb3M7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCggY3VycmVudFBvcyA9IHRyYWNlKGN1cnJlbnRQb3MsIGZhbHNlKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wLnB1c2gocG9pbnRzW2N1cnJlbnRQb3NdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0b3AubGVuZ3RoID4gcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBESUxBVEUgPSAxO1xuZXhwb3J0IGNvbnN0IEVST0RFID0gMjtcblxuZXhwb3J0IGZ1bmN0aW9uIGRpbGF0ZShpbkltYWdlV3JhcHBlciwgb3V0SW1hZ2VXcmFwcGVyKSB7XG4gICAgdmFyIHYsXG4gICAgICAgIHUsXG4gICAgICAgIGluSW1hZ2VEYXRhID0gaW5JbWFnZVdyYXBwZXIuZGF0YSxcbiAgICAgICAgb3V0SW1hZ2VEYXRhID0gb3V0SW1hZ2VXcmFwcGVyLmRhdGEsXG4gICAgICAgIGhlaWdodCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueSxcbiAgICAgICAgd2lkdGggPSBpbkltYWdlV3JhcHBlci5zaXplLngsXG4gICAgICAgIHN1bSxcbiAgICAgICAgeVN0YXJ0MSxcbiAgICAgICAgeVN0YXJ0MixcbiAgICAgICAgeFN0YXJ0MSxcbiAgICAgICAgeFN0YXJ0MjtcblxuICAgIGZvciAoIHYgPSAxOyB2IDwgaGVpZ2h0IC0gMTsgdisrKSB7XG4gICAgICAgIGZvciAoIHUgPSAxOyB1IDwgd2lkdGggLSAxOyB1KyspIHtcbiAgICAgICAgICAgIHlTdGFydDEgPSB2IC0gMTtcbiAgICAgICAgICAgIHlTdGFydDIgPSB2ICsgMTtcbiAgICAgICAgICAgIHhTdGFydDEgPSB1IC0gMTtcbiAgICAgICAgICAgIHhTdGFydDIgPSB1ICsgMTtcbiAgICAgICAgICAgIHN1bSA9IGluSW1hZ2VEYXRhW3lTdGFydDEgKiB3aWR0aCArIHhTdGFydDFdICsgaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0Ml0gK1xuICAgICAgICAgICAgaW5JbWFnZURhdGFbdiAqIHdpZHRoICsgdV0gK1xuICAgICAgICAgICAgaW5JbWFnZURhdGFbeVN0YXJ0MiAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQyXTtcbiAgICAgICAgICAgIG91dEltYWdlRGF0YVt2ICogd2lkdGggKyB1XSA9IHN1bSA+IDAgPyAxIDogMDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBlcm9kZShpbkltYWdlV3JhcHBlciwgb3V0SW1hZ2VXcmFwcGVyKSB7XG4gICAgdmFyIHYsXG4gICAgICAgIHUsXG4gICAgICAgIGluSW1hZ2VEYXRhID0gaW5JbWFnZVdyYXBwZXIuZGF0YSxcbiAgICAgICAgb3V0SW1hZ2VEYXRhID0gb3V0SW1hZ2VXcmFwcGVyLmRhdGEsXG4gICAgICAgIGhlaWdodCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueSxcbiAgICAgICAgd2lkdGggPSBpbkltYWdlV3JhcHBlci5zaXplLngsXG4gICAgICAgIHN1bSxcbiAgICAgICAgeVN0YXJ0MSxcbiAgICAgICAgeVN0YXJ0MixcbiAgICAgICAgeFN0YXJ0MSxcbiAgICAgICAgeFN0YXJ0MjtcblxuICAgIGZvciAoIHYgPSAxOyB2IDwgaGVpZ2h0IC0gMTsgdisrKSB7XG4gICAgICAgIGZvciAoIHUgPSAxOyB1IDwgd2lkdGggLSAxOyB1KyspIHtcbiAgICAgICAgICAgIHlTdGFydDEgPSB2IC0gMTtcbiAgICAgICAgICAgIHlTdGFydDIgPSB2ICsgMTtcbiAgICAgICAgICAgIHhTdGFydDEgPSB1IC0gMTtcbiAgICAgICAgICAgIHhTdGFydDIgPSB1ICsgMTtcbiAgICAgICAgICAgIHN1bSA9IGluSW1hZ2VEYXRhW3lTdGFydDEgKiB3aWR0aCArIHhTdGFydDFdICsgaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0Ml0gK1xuICAgICAgICAgICAgaW5JbWFnZURhdGFbdiAqIHdpZHRoICsgdV0gK1xuICAgICAgICAgICAgaW5JbWFnZURhdGFbeVN0YXJ0MiAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQyXTtcbiAgICAgICAgICAgIG91dEltYWdlRGF0YVt2ICogd2lkdGggKyB1XSA9IHN1bSA9PT0gNSA/IDEgOiAwO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KGFJbWFnZVdyYXBwZXIsIGJJbWFnZVdyYXBwZXIsIHJlc3VsdEltYWdlV3JhcHBlcikge1xuICAgIGlmICghcmVzdWx0SW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgIHJlc3VsdEltYWdlV3JhcHBlciA9IGFJbWFnZVdyYXBwZXI7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBhSW1hZ2VXcmFwcGVyLmRhdGEubGVuZ3RoLFxuICAgICAgICBhSW1hZ2VEYXRhID0gYUltYWdlV3JhcHBlci5kYXRhLFxuICAgICAgICBiSW1hZ2VEYXRhID0gYkltYWdlV3JhcHBlci5kYXRhLFxuICAgICAgICBjSW1hZ2VEYXRhID0gcmVzdWx0SW1hZ2VXcmFwcGVyLmRhdGE7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgY0ltYWdlRGF0YVtsZW5ndGhdID0gYUltYWdlRGF0YVtsZW5ndGhdIC0gYkltYWdlRGF0YVtsZW5ndGhdO1xuICAgIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBiaXR3aXNlT3IoYUltYWdlV3JhcHBlciwgYkltYWdlV3JhcHBlciwgcmVzdWx0SW1hZ2VXcmFwcGVyKSB7XG4gICAgaWYgKCFyZXN1bHRJbWFnZVdyYXBwZXIpIHtcbiAgICAgICAgcmVzdWx0SW1hZ2VXcmFwcGVyID0gYUltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGFJbWFnZVdyYXBwZXIuZGF0YS5sZW5ndGgsXG4gICAgICAgIGFJbWFnZURhdGEgPSBhSW1hZ2VXcmFwcGVyLmRhdGEsXG4gICAgICAgIGJJbWFnZURhdGEgPSBiSW1hZ2VXcmFwcGVyLmRhdGEsXG4gICAgICAgIGNJbWFnZURhdGEgPSByZXN1bHRJbWFnZVdyYXBwZXIuZGF0YTtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBjSW1hZ2VEYXRhW2xlbmd0aF0gPSBhSW1hZ2VEYXRhW2xlbmd0aF0gfHwgYkltYWdlRGF0YVtsZW5ndGhdO1xuICAgIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3VudE5vblplcm8oaW1hZ2VXcmFwcGVyKSB7XG4gICAgdmFyIGxlbmd0aCA9IGltYWdlV3JhcHBlci5kYXRhLmxlbmd0aCwgZGF0YSA9IGltYWdlV3JhcHBlci5kYXRhLCBzdW0gPSAwO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHN1bSArPSBkYXRhW2xlbmd0aF07XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdG9wR2VuZXJpYyhsaXN0LCB0b3AsIHNjb3JlRnVuYykge1xuICAgIHZhciBpLCBtaW5JZHggPSAwLCBtaW4gPSAwLCBxdWV1ZSA9IFtdLCBzY29yZSwgaGl0LCBwb3M7XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IHRvcDsgaSsrKSB7XG4gICAgICAgIHF1ZXVlW2ldID0ge1xuICAgICAgICAgICAgc2NvcmU6IDAsXG4gICAgICAgICAgICBpdGVtOiBudWxsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZm9yICggaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNjb3JlID0gc2NvcmVGdW5jLmFwcGx5KHRoaXMsIFtsaXN0W2ldXSk7XG4gICAgICAgIGlmIChzY29yZSA+IG1pbikge1xuICAgICAgICAgICAgaGl0ID0gcXVldWVbbWluSWR4XTtcbiAgICAgICAgICAgIGhpdC5zY29yZSA9IHNjb3JlO1xuICAgICAgICAgICAgaGl0Lml0ZW0gPSBsaXN0W2ldO1xuICAgICAgICAgICAgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgIGZvciAoIHBvcyA9IDA7IHBvcyA8IHRvcDsgcG9zKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocXVldWVbcG9zXS5zY29yZSA8IG1pbikge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSBxdWV1ZVtwb3NdLnNjb3JlO1xuICAgICAgICAgICAgICAgICAgICBtaW5JZHggPSBwb3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1ZXVlO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdyYXlBcnJheUZyb21JbWFnZShodG1sSW1hZ2UsIG9mZnNldFgsIGN0eCwgYXJyYXkpIHtcbiAgICBjdHguZHJhd0ltYWdlKGh0bWxJbWFnZSwgb2Zmc2V0WCwgMCwgaHRtbEltYWdlLndpZHRoLCBodG1sSW1hZ2UuaGVpZ2h0KTtcbiAgICB2YXIgY3R4RGF0YSA9IGN0eC5nZXRJbWFnZURhdGEob2Zmc2V0WCwgMCwgaHRtbEltYWdlLndpZHRoLCBodG1sSW1hZ2UuaGVpZ2h0KS5kYXRhO1xuICAgIGNvbXB1dGVHcmF5KGN0eERhdGEsIGFycmF5KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBncmF5QXJyYXlGcm9tQ29udGV4dChjdHgsIHNpemUsIG9mZnNldCwgYXJyYXkpIHtcbiAgICB2YXIgY3R4RGF0YSA9IGN0eC5nZXRJbWFnZURhdGEob2Zmc2V0LngsIG9mZnNldC55LCBzaXplLngsIHNpemUueSkuZGF0YTtcbiAgICBjb21wdXRlR3JheShjdHhEYXRhLCBhcnJheSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ3JheUFuZEhhbGZTYW1wbGVGcm9tQ2FudmFzRGF0YShjYW52YXNEYXRhLCBzaXplLCBvdXRBcnJheSkge1xuICAgIHZhciB0b3BSb3dJZHggPSAwO1xuICAgIHZhciBib3R0b21Sb3dJZHggPSBzaXplLng7XG4gICAgdmFyIGVuZElkeCA9IE1hdGguZmxvb3IoY2FudmFzRGF0YS5sZW5ndGggLyA0KTtcbiAgICB2YXIgb3V0V2lkdGggPSBzaXplLnggLyAyO1xuICAgIHZhciBvdXRJbWdJZHggPSAwO1xuICAgIHZhciBpbldpZHRoID0gc2l6ZS54O1xuICAgIHZhciBpO1xuXG4gICAgd2hpbGUgKGJvdHRvbVJvd0lkeCA8IGVuZElkeCkge1xuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IG91dFdpZHRoOyBpKyspIHtcbiAgICAgICAgICAgIG91dEFycmF5W291dEltZ0lkeF0gPSAoXG4gICAgICAgICAgICAgICAgKDAuMjk5ICogY2FudmFzRGF0YVt0b3BSb3dJZHggKiA0ICsgMF0gK1xuICAgICAgICAgICAgICAgICAwLjU4NyAqIGNhbnZhc0RhdGFbdG9wUm93SWR4ICogNCArIDFdICtcbiAgICAgICAgICAgICAgICAgMC4xMTQgKiBjYW52YXNEYXRhW3RvcFJvd0lkeCAqIDQgKyAyXSkgK1xuICAgICAgICAgICAgICAgICgwLjI5OSAqIGNhbnZhc0RhdGFbKHRvcFJvd0lkeCArIDEpICogNCArIDBdICtcbiAgICAgICAgICAgICAgICAgMC41ODcgKiBjYW52YXNEYXRhWyh0b3BSb3dJZHggKyAxKSAqIDQgKyAxXSArXG4gICAgICAgICAgICAgICAgIDAuMTE0ICogY2FudmFzRGF0YVsodG9wUm93SWR4ICsgMSkgKiA0ICsgMl0pICtcbiAgICAgICAgICAgICAgICAoMC4yOTkgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDBdICtcbiAgICAgICAgICAgICAgICAgMC41ODcgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDFdICtcbiAgICAgICAgICAgICAgICAgMC4xMTQgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDJdKSArXG4gICAgICAgICAgICAgICAgKDAuMjk5ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4ICsgMSkgKiA0ICsgMF0gK1xuICAgICAgICAgICAgICAgICAwLjU4NyAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCArIDEpICogNCArIDFdICtcbiAgICAgICAgICAgICAgICAgMC4xMTQgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHggKyAxKSAqIDQgKyAyXSkpIC8gNDtcbiAgICAgICAgICAgIG91dEltZ0lkeCsrO1xuICAgICAgICAgICAgdG9wUm93SWR4ID0gdG9wUm93SWR4ICsgMjtcbiAgICAgICAgICAgIGJvdHRvbVJvd0lkeCA9IGJvdHRvbVJvd0lkeCArIDI7XG4gICAgICAgIH1cbiAgICAgICAgdG9wUm93SWR4ID0gdG9wUm93SWR4ICsgaW5XaWR0aDtcbiAgICAgICAgYm90dG9tUm93SWR4ID0gYm90dG9tUm93SWR4ICsgaW5XaWR0aDtcbiAgICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUdyYXkoaW1hZ2VEYXRhLCBvdXRBcnJheSwgY29uZmlnKSB7XG4gICAgdmFyIGwgPSAoaW1hZ2VEYXRhLmxlbmd0aCAvIDQpIHwgMCxcbiAgICAgICAgaSxcbiAgICAgICAgc2luZ2xlQ2hhbm5lbCA9IGNvbmZpZyAmJiBjb25maWcuc2luZ2xlQ2hhbm5lbCA9PT0gdHJ1ZTtcblxuICAgIGlmIChzaW5nbGVDaGFubmVsKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIG91dEFycmF5W2ldID0gaW1hZ2VEYXRhW2kgKiA0ICsgMF07XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRBcnJheVtpXSA9XG4gICAgICAgICAgICAgICAgMC4yOTkgKiBpbWFnZURhdGFbaSAqIDQgKyAwXSArIDAuNTg3ICogaW1hZ2VEYXRhW2kgKiA0ICsgMV0gKyAwLjExNCAqIGltYWdlRGF0YVtpICogNCArIDJdO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRJbWFnZUFycmF5KHNyYywgY2FsbGJhY2ssIGNhbnZhcykge1xuICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIH1cbiAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgaW1nLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLCAwLCAwKTtcbiAgICAgICAgdmFyIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLCAwLCAwKTtcbiAgICAgICAgdmFyIGRhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KS5kYXRhO1xuICAgICAgICBjb21wdXRlR3JheShkYXRhLCBhcnJheSk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soYXJyYXksIHtcbiAgICAgICAgICAgIHg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICB5OiB0aGlzLmhlaWdodFxuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuICAgIGltZy5zcmMgPSBzcmM7XG59O1xuXG4vKipcbiAqIEBwYXJhbSBpbkltZyB7SW1hZ2VXcmFwcGVyfSBpbnB1dCBpbWFnZSB0byBiZSBzYW1wbGVkXG4gKiBAcGFyYW0gb3V0SW1nIHtJbWFnZVdyYXBwZXJ9IHRvIGJlIHN0b3JlZCBpblxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFsZlNhbXBsZShpbkltZ1dyYXBwZXIsIG91dEltZ1dyYXBwZXIpIHtcbiAgICB2YXIgaW5JbWcgPSBpbkltZ1dyYXBwZXIuZGF0YTtcbiAgICB2YXIgaW5XaWR0aCA9IGluSW1nV3JhcHBlci5zaXplLng7XG4gICAgdmFyIG91dEltZyA9IG91dEltZ1dyYXBwZXIuZGF0YTtcbiAgICB2YXIgdG9wUm93SWR4ID0gMDtcbiAgICB2YXIgYm90dG9tUm93SWR4ID0gaW5XaWR0aDtcbiAgICB2YXIgZW5kSWR4ID0gaW5JbWcubGVuZ3RoO1xuICAgIHZhciBvdXRXaWR0aCA9IGluV2lkdGggLyAyO1xuICAgIHZhciBvdXRJbWdJZHggPSAwO1xuICAgIHdoaWxlIChib3R0b21Sb3dJZHggPCBlbmRJZHgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRXaWR0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRJbWdbb3V0SW1nSWR4XSA9IE1hdGguZmxvb3IoXG4gICAgICAgICAgICAgICAgKGluSW1nW3RvcFJvd0lkeF0gKyBpbkltZ1t0b3BSb3dJZHggKyAxXSArIGluSW1nW2JvdHRvbVJvd0lkeF0gKyBpbkltZ1tib3R0b21Sb3dJZHggKyAxXSkgLyA0KTtcbiAgICAgICAgICAgIG91dEltZ0lkeCsrO1xuICAgICAgICAgICAgdG9wUm93SWR4ID0gdG9wUm93SWR4ICsgMjtcbiAgICAgICAgICAgIGJvdHRvbVJvd0lkeCA9IGJvdHRvbVJvd0lkeCArIDI7XG4gICAgICAgIH1cbiAgICAgICAgdG9wUm93SWR4ID0gdG9wUm93SWR4ICsgaW5XaWR0aDtcbiAgICAgICAgYm90dG9tUm93SWR4ID0gYm90dG9tUm93SWR4ICsgaW5XaWR0aDtcbiAgICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gaHN2MnJnYihoc3YsIHJnYikge1xuICAgIHZhciBoID0gaHN2WzBdLFxuICAgICAgICBzID0gaHN2WzFdLFxuICAgICAgICB2ID0gaHN2WzJdLFxuICAgICAgICBjID0gdiAqIHMsXG4gICAgICAgIHggPSBjICogKDEgLSBNYXRoLmFicygoaCAvIDYwKSAlIDIgLSAxKSksXG4gICAgICAgIG0gPSB2IC0gYyxcbiAgICAgICAgciA9IDAsXG4gICAgICAgIGcgPSAwLFxuICAgICAgICBiID0gMDtcblxuICAgIHJnYiA9IHJnYiB8fCBbMCwgMCwgMF07XG5cbiAgICBpZiAoaCA8IDYwKSB7XG4gICAgICAgIHIgPSBjO1xuICAgICAgICBnID0geDtcbiAgICB9IGVsc2UgaWYgKGggPCAxMjApIHtcbiAgICAgICAgciA9IHg7XG4gICAgICAgIGcgPSBjO1xuICAgIH0gZWxzZSBpZiAoaCA8IDE4MCkge1xuICAgICAgICBnID0gYztcbiAgICAgICAgYiA9IHg7XG4gICAgfSBlbHNlIGlmIChoIDwgMjQwKSB7XG4gICAgICAgIGcgPSB4O1xuICAgICAgICBiID0gYztcbiAgICB9IGVsc2UgaWYgKGggPCAzMDApIHtcbiAgICAgICAgciA9IHg7XG4gICAgICAgIGIgPSBjO1xuICAgIH0gZWxzZSBpZiAoaCA8IDM2MCkge1xuICAgICAgICByID0gYztcbiAgICAgICAgYiA9IHg7XG4gICAgfVxuICAgIHJnYlswXSA9ICgociArIG0pICogMjU1KSB8IDA7XG4gICAgcmdiWzFdID0gKChnICsgbSkgKiAyNTUpIHwgMDtcbiAgICByZ2JbMl0gPSAoKGIgKyBtKSAqIDI1NSkgfCAwO1xuICAgIHJldHVybiByZ2I7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX2NvbXB1dGVEaXZpc29ycyhuKSB7XG4gICAgdmFyIGxhcmdlRGl2aXNvcnMgPSBbXSxcbiAgICAgICAgZGl2aXNvcnMgPSBbXSxcbiAgICAgICAgaTtcblxuICAgIGZvciAoaSA9IDE7IGkgPCBNYXRoLnNxcnQobikgKyAxOyBpKyspIHtcbiAgICAgICAgaWYgKG4gJSBpID09PSAwKSB7XG4gICAgICAgICAgICBkaXZpc29ycy5wdXNoKGkpO1xuICAgICAgICAgICAgaWYgKGkgIT09IG4gLyBpKSB7XG4gICAgICAgICAgICAgICAgbGFyZ2VEaXZpc29ycy51bnNoaWZ0KE1hdGguZmxvb3IobiAvIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGl2aXNvcnMuY29uY2F0KGxhcmdlRGl2aXNvcnMpO1xufTtcblxuZnVuY3Rpb24gX2NvbXB1dGVJbnRlcnNlY3Rpb24oYXJyMSwgYXJyMikge1xuICAgIHZhciBpID0gMCxcbiAgICAgICAgaiA9IDAsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKGkgPCBhcnIxLmxlbmd0aCAmJiBqIDwgYXJyMi5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGFycjFbaV0gPT09IGFycjJbal0pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycjFbaV0pO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9IGVsc2UgaWYgKGFycjFbaV0gPiBhcnIyW2pdKSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVQYXRjaFNpemUocGF0Y2hTaXplLCBpbWdTaXplKSB7XG4gICAgdmFyIGRpdmlzb3JzWCA9IF9jb21wdXRlRGl2aXNvcnMoaW1nU2l6ZS54KSxcbiAgICAgICAgZGl2aXNvcnNZID0gX2NvbXB1dGVEaXZpc29ycyhpbWdTaXplLnkpLFxuICAgICAgICB3aWRlU2lkZSA9IE1hdGgubWF4KGltZ1NpemUueCwgaW1nU2l6ZS55KSxcbiAgICAgICAgY29tbW9uID0gX2NvbXB1dGVJbnRlcnNlY3Rpb24oZGl2aXNvcnNYLCBkaXZpc29yc1kpLFxuICAgICAgICBuck9mUGF0Y2hlc0xpc3QgPSBbOCwgMTAsIDE1LCAyMCwgMzIsIDYwLCA4MF0sXG4gICAgICAgIG5yT2ZQYXRjaGVzTWFwID0ge1xuICAgICAgICAgICAgXCJ4LXNtYWxsXCI6IDUsXG4gICAgICAgICAgICBcInNtYWxsXCI6IDQsXG4gICAgICAgICAgICBcIm1lZGl1bVwiOiAzLFxuICAgICAgICAgICAgXCJsYXJnZVwiOiAyLFxuICAgICAgICAgICAgXCJ4LWxhcmdlXCI6IDFcbiAgICAgICAgfSxcbiAgICAgICAgbnJPZlBhdGNoZXNJZHggPSBuck9mUGF0Y2hlc01hcFtwYXRjaFNpemVdIHx8IG5yT2ZQYXRjaGVzTWFwLm1lZGl1bSxcbiAgICAgICAgbnJPZlBhdGNoZXMgPSBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHhdLFxuICAgICAgICBkZXNpcmVkUGF0Y2hTaXplID0gTWF0aC5mbG9vcih3aWRlU2lkZSAvIG5yT2ZQYXRjaGVzKSxcbiAgICAgICAgb3B0aW1hbFBhdGNoU2l6ZTtcblxuICAgIGZ1bmN0aW9uIGZpbmRQYXRjaFNpemVGb3JEaXZpc29ycyhkaXZpc29ycykge1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBmb3VuZCA9IGRpdmlzb3JzW01hdGguZmxvb3IoZGl2aXNvcnMubGVuZ3RoIC8gMildO1xuXG4gICAgICAgIHdoaWxlIChpIDwgKGRpdmlzb3JzLmxlbmd0aCAtIDEpICYmIGRpdmlzb3JzW2ldIDwgZGVzaXJlZFBhdGNoU2l6ZSkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRpdmlzb3JzW2ldIC0gZGVzaXJlZFBhdGNoU2l6ZSkgPiBNYXRoLmFicyhkaXZpc29yc1tpIC0gMV0gLSBkZXNpcmVkUGF0Y2hTaXplKSkge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gZGl2aXNvcnNbaSAtIDFdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IGRpdmlzb3JzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZXNpcmVkUGF0Y2hTaXplIC8gZm91bmQgPCBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHggKyAxXSAvIG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeF0gJiZcbiAgICAgICAgICAgIGRlc2lyZWRQYXRjaFNpemUgLyBmb3VuZCA+IG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeCAtIDFdIC8gbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4XSApIHtcbiAgICAgICAgICAgIHJldHVybiB7eDogZm91bmQsIHk6IGZvdW5kfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBvcHRpbWFsUGF0Y2hTaXplID0gZmluZFBhdGNoU2l6ZUZvckRpdmlzb3JzKGNvbW1vbik7XG4gICAgaWYgKCFvcHRpbWFsUGF0Y2hTaXplKSB7XG4gICAgICAgIG9wdGltYWxQYXRjaFNpemUgPSBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoX2NvbXB1dGVEaXZpc29ycyh3aWRlU2lkZSkpO1xuICAgICAgICBpZiAoIW9wdGltYWxQYXRjaFNpemUpIHtcbiAgICAgICAgICAgIG9wdGltYWxQYXRjaFNpemUgPSBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoKF9jb21wdXRlRGl2aXNvcnMoZGVzaXJlZFBhdGNoU2l6ZSAqIG5yT2ZQYXRjaGVzKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHRpbWFsUGF0Y2hTaXplO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9wYXJzZUNTU0RpbWVuc2lvblZhbHVlcyh2YWx1ZSkge1xuICAgIHZhciBkaW1lbnNpb24gPSB7XG4gICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KHZhbHVlKSxcbiAgICAgICAgdW5pdDogdmFsdWUuaW5kZXhPZihcIiVcIikgPT09IHZhbHVlLmxlbmd0aCAtIDEgPyBcIiVcIiA6IFwiJVwiXG4gICAgfTtcblxuICAgIHJldHVybiBkaW1lbnNpb247XG59O1xuXG5leHBvcnQgY29uc3QgX2RpbWVuc2lvbnNDb252ZXJ0ZXJzID0ge1xuICAgIHRvcDogZnVuY3Rpb24oZGltZW5zaW9uLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChkaW1lbnNpb24udW5pdCA9PT0gXCIlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKGNvbnRleHQuaGVpZ2h0ICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByaWdodDogZnVuY3Rpb24oZGltZW5zaW9uLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChkaW1lbnNpb24udW5pdCA9PT0gXCIlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKGNvbnRleHQud2lkdGggLSAoY29udGV4dC53aWR0aCAqIChkaW1lbnNpb24udmFsdWUgLyAxMDApKSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGJvdHRvbTogZnVuY3Rpb24oZGltZW5zaW9uLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChkaW1lbnNpb24udW5pdCA9PT0gXCIlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKGNvbnRleHQuaGVpZ2h0IC0gKGNvbnRleHQuaGVpZ2h0ICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbGVmdDogZnVuY3Rpb24oZGltZW5zaW9uLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChkaW1lbnNpb24udW5pdCA9PT0gXCIlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKGNvbnRleHQud2lkdGggKiAoZGltZW5zaW9uLnZhbHVlIC8gMTAwKSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUltYWdlQXJlYShpbnB1dFdpZHRoLCBpbnB1dEhlaWdodCwgYXJlYSkge1xuICAgIHZhciBjb250ZXh0ID0ge3dpZHRoOiBpbnB1dFdpZHRoLCBoZWlnaHQ6IGlucHV0SGVpZ2h0fTtcblxuICAgIHZhciBwYXJzZWRBcmVhID0gT2JqZWN0LmtleXMoYXJlYSkucmVkdWNlKGZ1bmN0aW9uKHJlc3VsdCwga2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFyZWFba2V5XSxcbiAgICAgICAgICAgIHBhcnNlZCA9IF9wYXJzZUNTU0RpbWVuc2lvblZhbHVlcyh2YWx1ZSksXG4gICAgICAgICAgICBjYWxjdWxhdGVkID0gX2RpbWVuc2lvbnNDb252ZXJ0ZXJzW2tleV0ocGFyc2VkLCBjb250ZXh0KTtcblxuICAgICAgICByZXN1bHRba2V5XSA9IGNhbGN1bGF0ZWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwge30pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3g6IHBhcnNlZEFyZWEubGVmdCxcbiAgICAgICAgc3k6IHBhcnNlZEFyZWEudG9wLFxuICAgICAgICBzdzogcGFyc2VkQXJlYS5yaWdodCAtIHBhcnNlZEFyZWEubGVmdCxcbiAgICAgICAgc2g6IHBhcnNlZEFyZWEuYm90dG9tIC0gcGFyc2VkQXJlYS50b3BcbiAgICB9O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21tb24vY3ZfdXRpbHMuanMiLCJpbXBvcnQgU3ViSW1hZ2UgZnJvbSAnLi9zdWJJbWFnZSc7XG5pbXBvcnQge2hzdjJyZ2J9IGZyb20gJy4uL2NvbW1vbi9jdl91dGlscyc7XG5pbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi4vY29tbW9uL2FycmF5X2hlbHBlcic7XG5jb25zdCB2ZWMyID0ge1xuICAgIGNsb25lOiByZXF1aXJlKCdnbC12ZWMyL2Nsb25lJyksXG59O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBiYXNpYyBpbWFnZSBjb21iaW5pbmcgdGhlIGRhdGEgYW5kIHNpemUuXG4gKiBJbiBhZGRpdGlvbiwgc29tZSBtZXRob2RzIGZvciBtYW5pcHVsYXRpb24gYXJlIGNvbnRhaW5lZC5cbiAqIEBwYXJhbSBzaXplIHt4LHl9IFRoZSBzaXplIG9mIHRoZSBpbWFnZSBpbiBwaXhlbFxuICogQHBhcmFtIGRhdGEge0FycmF5fSBJZiBnaXZlbiwgYSBmbGF0IGFycmF5IGNvbnRhaW5pbmcgdGhlIHBpeGVsIGRhdGFcbiAqIEBwYXJhbSBBcnJheVR5cGUge1R5cGV9IElmIGdpdmVuLCB0aGUgZGVzaXJlZCBEYXRhVHlwZSBvZiB0aGUgQXJyYXkgKG1heSBiZSB0eXBlZC9ub24tdHlwZWQpXG4gKiBAcGFyYW0gaW5pdGlhbGl6ZSB7Qm9vbGVhbn0gSW5kaWNhdGluZyBpZiB0aGUgYXJyYXkgc2hvdWxkIGJlIGluaXRpYWxpemVkIG9uIGNyZWF0aW9uLlxuICogQHJldHVybnMge0ltYWdlV3JhcHBlcn1cbiAqL1xuZnVuY3Rpb24gSW1hZ2VXcmFwcGVyKHNpemUsIGRhdGEsIEFycmF5VHlwZSwgaW5pdGlhbGl6ZSkge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgICBpZiAoQXJyYXlUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgQXJyYXlUeXBlKHNpemUueCAqIHNpemUueSk7XG4gICAgICAgICAgICBpZiAoQXJyYXlUeXBlID09PSBBcnJheSAmJiBpbml0aWFsaXplKSB7XG4gICAgICAgICAgICAgICAgQXJyYXlIZWxwZXIuaW5pdCh0aGlzLmRhdGEsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZS54ICogc2l6ZS55KTtcbiAgICAgICAgICAgIGlmIChVaW50OEFycmF5ID09PSBBcnJheSAmJiBpbml0aWFsaXplKSB7XG4gICAgICAgICAgICAgICAgQXJyYXlIZWxwZXIuaW5pdCh0aGlzLmRhdGEsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbn1cblxuLyoqXG4gKiB0ZXN0cyBpZiBhIHBvc2l0aW9uIGlzIHdpdGhpbiB0aGUgaW1hZ2Ugd2l0aCBhIGdpdmVuIG9mZnNldFxuICogQHBhcmFtIGltZ1JlZiB7eCwgeX0gVGhlIGxvY2F0aW9uIHRvIHRlc3RcbiAqIEBwYXJhbSBib3JkZXIgTnVtYmVyIHRoZSBwYWRkaW5nIHZhbHVlIGluIHBpeGVsXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBsb2NhdGlvbiBpbnNpZGUgdGhlIGltYWdlJ3MgYm9yZGVyLCBmYWxzZSBvdGhlcndpc2VcbiAqIEBzZWUgY3ZkL2ltYWdlLmhcbiAqL1xuSW1hZ2VXcmFwcGVyLnByb3RvdHlwZS5pbkltYWdlV2l0aEJvcmRlciA9IGZ1bmN0aW9uKGltZ1JlZiwgYm9yZGVyKSB7XG4gICAgcmV0dXJuIChpbWdSZWYueCA+PSBib3JkZXIpXG4gICAgICAgICYmIChpbWdSZWYueSA+PSBib3JkZXIpXG4gICAgICAgICYmIChpbWdSZWYueCA8ICh0aGlzLnNpemUueCAtIGJvcmRlcikpXG4gICAgICAgICYmIChpbWdSZWYueSA8ICh0aGlzLnNpemUueSAtIGJvcmRlcikpO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBiaWxpbmVhciBzYW1wbGluZ1xuICogQHBhcmFtIGluSW1nIEltYWdlIHRvIGV4dHJhY3Qgc2FtcGxlIGZyb21cbiAqIEBwYXJhbSB4IHRoZSB4LWNvb3JkaW5hdGVcbiAqIEBwYXJhbSB5IHRoZSB5LWNvb3JkaW5hdGVcbiAqIEByZXR1cm5zIHRoZSBzYW1wbGVkIHZhbHVlXG4gKiBAc2VlIGN2ZC92aXNpb24uaFxuICovXG5JbWFnZVdyYXBwZXIuc2FtcGxlID0gZnVuY3Rpb24oaW5JbWcsIHgsIHkpIHtcbiAgICB2YXIgbHggPSBNYXRoLmZsb29yKHgpO1xuICAgIHZhciBseSA9IE1hdGguZmxvb3IoeSk7XG4gICAgdmFyIHcgPSBpbkltZy5zaXplLng7XG4gICAgdmFyIGJhc2UgPSBseSAqIGluSW1nLnNpemUueCArIGx4O1xuICAgIHZhciBhID0gaW5JbWcuZGF0YVtiYXNlICsgMF07XG4gICAgdmFyIGIgPSBpbkltZy5kYXRhW2Jhc2UgKyAxXTtcbiAgICB2YXIgYyA9IGluSW1nLmRhdGFbYmFzZSArIHddO1xuICAgIHZhciBkID0gaW5JbWcuZGF0YVtiYXNlICsgdyArIDFdO1xuICAgIHZhciBlID0gYSAtIGI7XG4gICAgeCAtPSBseDtcbiAgICB5IC09IGx5O1xuXG4gICAgdmFyIHJlc3VsdCA9IE1hdGguZmxvb3IoeCAqICh5ICogKGUgLSBjICsgZCkgLSBlKSArIHkgKiAoYyAtIGEpICsgYSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBnaXZlbiBhcnJheS4gU2V0cyBlYWNoIGVsZW1lbnQgdG8gemVyby5cbiAqIEBwYXJhbSBhcnJheSB7QXJyYXl9IFRoZSBhcnJheSB0byBpbml0aWFsaXplXG4gKi9cbkltYWdlV3JhcHBlci5jbGVhckFycmF5ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgbCA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAobC0tKSB7XG4gICAgICAgIGFycmF5W2xdID0gMDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSB7U3ViSW1hZ2V9IGZyb20gdGhlIGN1cnJlbnQgaW1hZ2UgKHt0aGlzfSkuXG4gKiBAcGFyYW0gZnJvbSB7SW1hZ2VSZWZ9IFRoZSBwb3NpdGlvbiB3aGVyZSB0byBzdGFydCB0aGUge1N1YkltYWdlfSBmcm9tLiAodG9wLWxlZnQgY29ybmVyKVxuICogQHBhcmFtIHNpemUge0ltYWdlUmVmfSBUaGUgc2l6ZSBvZiB0aGUgcmVzdWx0aW5nIGltYWdlXG4gKiBAcmV0dXJucyB7U3ViSW1hZ2V9IEEgc2hhcmVkIHBhcnQgb2YgdGhlIG9yaWdpbmFsIGltYWdlXG4gKi9cbkltYWdlV3JhcHBlci5wcm90b3R5cGUuc3ViSW1hZ2UgPSBmdW5jdGlvbihmcm9tLCBzaXplKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJJbWFnZShmcm9tLCBzaXplLCB0aGlzKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiB7SW1hZ2VXcmFwcGVyKSBhbmQgY29waWVzIHRoZSBuZWVkZWQgdW5kZXJseWluZyBpbWFnZS1kYXRhIGFyZWFcbiAqIEBwYXJhbSBpbWFnZVdyYXBwZXIge0ltYWdlV3JhcHBlcn0gVGhlIHRhcmdldCB7SW1hZ2VXcmFwcGVyfSB3aGVyZSB0aGUgZGF0YSBzaG91bGQgYmUgY29waWVkXG4gKiBAcGFyYW0gZnJvbSB7SW1hZ2VSZWZ9IFRoZSBsb2NhdGlvbiB3aGVyZSB0byBjb3B5IGZyb20gKHRvcC1sZWZ0IGxvY2F0aW9uKVxuICovXG5JbWFnZVdyYXBwZXIucHJvdG90eXBlLnN1YkltYWdlQXNDb3B5ID0gZnVuY3Rpb24oaW1hZ2VXcmFwcGVyLCBmcm9tKSB7XG4gICAgdmFyIHNpemVZID0gaW1hZ2VXcmFwcGVyLnNpemUueSwgc2l6ZVggPSBpbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIHZhciB4LCB5O1xuICAgIGZvciAoIHggPSAwOyB4IDwgc2l6ZVg7IHgrKykge1xuICAgICAgICBmb3IgKCB5ID0gMDsgeSA8IHNpemVZOyB5KyspIHtcbiAgICAgICAgICAgIGltYWdlV3JhcHBlci5kYXRhW3kgKiBzaXplWCArIHhdID0gdGhpcy5kYXRhWyhmcm9tLnkgKyB5KSAqIHRoaXMuc2l6ZS54ICsgZnJvbS54ICsgeF07XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5JbWFnZVdyYXBwZXIucHJvdG90eXBlLmNvcHlUbyA9IGZ1bmN0aW9uKGltYWdlV3JhcHBlcikge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmRhdGEubGVuZ3RoLCBzcmNEYXRhID0gdGhpcy5kYXRhLCBkc3REYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgZHN0RGF0YVtsZW5ndGhdID0gc3JjRGF0YVtsZW5ndGhdO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGEgZ2l2ZW4gcGl4ZWwgcG9zaXRpb24gZnJvbSB0aGUgaW1hZ2VcbiAqIEBwYXJhbSB4IHtOdW1iZXJ9IFRoZSB4LXBvc2l0aW9uXG4gKiBAcGFyYW0geSB7TnVtYmVyfSBUaGUgeS1wb3NpdGlvblxuICogQHJldHVybnMge051bWJlcn0gVGhlIGdyYXlzY2FsZSB2YWx1ZSBhdCB0aGUgcGl4ZWwtcG9zaXRpb25cbiAqL1xuSW1hZ2VXcmFwcGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVt5ICogdGhpcy5zaXplLnggKyB4XTtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGEgZ2l2ZW4gcGl4ZWwgcG9zaXRpb24gZnJvbSB0aGUgaW1hZ2VcbiAqIEBwYXJhbSB4IHtOdW1iZXJ9IFRoZSB4LXBvc2l0aW9uXG4gKiBAcGFyYW0geSB7TnVtYmVyfSBUaGUgeS1wb3NpdGlvblxuICogQHJldHVybnMge051bWJlcn0gVGhlIGdyYXlzY2FsZSB2YWx1ZSBhdCB0aGUgcGl4ZWwtcG9zaXRpb25cbiAqL1xuSW1hZ2VXcmFwcGVyLnByb3RvdHlwZS5nZXRTYWZlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciBpO1xuXG4gICAgaWYgKCF0aGlzLmluZGV4TWFwcGluZykge1xuICAgICAgICB0aGlzLmluZGV4TWFwcGluZyA9IHtcbiAgICAgICAgICAgIHg6IFtdLFxuICAgICAgICAgICAgeTogW11cbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2l6ZS54OyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nLnhbaV0gPSBpO1xuICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcueFtpICsgdGhpcy5zaXplLnhdID0gaTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zaXplLnk7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcueVtpXSA9IGk7XG4gICAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZy55W2kgKyB0aGlzLnNpemUueV0gPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRhdGFbKHRoaXMuaW5kZXhNYXBwaW5nLnlbeSArIHRoaXMuc2l6ZS55XSkgKiB0aGlzLnNpemUueCArIHRoaXMuaW5kZXhNYXBwaW5nLnhbeCArIHRoaXMuc2l6ZS54XV07XG59O1xuXG4vKipcbiAqIFNldHMgYSBnaXZlbiBwaXhlbCBwb3NpdGlvbiBpbiB0aGUgaW1hZ2VcbiAqIEBwYXJhbSB4IHtOdW1iZXJ9IFRoZSB4LXBvc2l0aW9uXG4gKiBAcGFyYW0geSB7TnVtYmVyfSBUaGUgeS1wb3NpdGlvblxuICogQHBhcmFtIHZhbHVlIHtOdW1iZXJ9IFRoZSBncmF5c2NhbGUgdmFsdWUgdG8gc2V0XG4gKiBAcmV0dXJucyB7SW1hZ2VXcmFwcGVyfSBUaGUgSW1hZ2UgaXRzZWxmIChmb3IgcG9zc2libGUgY2hhaW5pbmcpXG4gKi9cbkltYWdlV3JhcHBlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICB0aGlzLmRhdGFbeSAqIHRoaXMuc2l6ZS54ICsgeF0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgYm9yZGVyIG9mIHRoZSBpbWFnZSAoMSBwaXhlbCkgdG8gemVyb1xuICovXG5JbWFnZVdyYXBwZXIucHJvdG90eXBlLnplcm9Cb3JkZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaSwgd2lkdGggPSB0aGlzLnNpemUueCwgaGVpZ2h0ID0gdGhpcy5zaXplLnksIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgZm9yICggaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgIGRhdGFbaV0gPSBkYXRhWyhoZWlnaHQgLSAxKSAqIHdpZHRoICsgaV0gPSAwO1xuICAgIH1cbiAgICBmb3IgKCBpID0gMTsgaSA8IGhlaWdodCAtIDE7IGkrKykge1xuICAgICAgICBkYXRhW2kgKiB3aWR0aF0gPSBkYXRhW2kgKiB3aWR0aCArICh3aWR0aCAtIDEpXSA9IDA7XG4gICAgfVxufTtcblxuLyoqXG4gKiBJbnZlcnRzIGEgYmluYXJ5IGltYWdlIGluIHBsYWNlXG4gKi9cbkltYWdlV3JhcHBlci5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEsIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGRhdGFbbGVuZ3RoXSA9IGRhdGFbbGVuZ3RoXSA/IDAgOiAxO1xuICAgIH1cbn07XG5cbkltYWdlV3JhcHBlci5wcm90b3R5cGUuY29udm9sdmUgPSBmdW5jdGlvbihrZXJuZWwpIHtcbiAgICB2YXIgeCwgeSwga3gsIGt5LCBrU2l6ZSA9IChrZXJuZWwubGVuZ3RoIC8gMikgfCAwLCBhY2N1ID0gMDtcbiAgICBmb3IgKCB5ID0gMDsgeSA8IHRoaXMuc2l6ZS55OyB5KyspIHtcbiAgICAgICAgZm9yICggeCA9IDA7IHggPCB0aGlzLnNpemUueDsgeCsrKSB7XG4gICAgICAgICAgICBhY2N1ID0gMDtcbiAgICAgICAgICAgIGZvciAoIGt5ID0gLWtTaXplOyBreSA8PSBrU2l6ZTsga3krKykge1xuICAgICAgICAgICAgICAgIGZvciAoIGt4ID0gLWtTaXplOyBreCA8PSBrU2l6ZTsga3grKykge1xuICAgICAgICAgICAgICAgICAgICBhY2N1ICs9IGtlcm5lbFtreSArIGtTaXplXVtreCArIGtTaXplXSAqIHRoaXMuZ2V0U2FmZSh4ICsga3gsIHkgKyBreSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kYXRhW3kgKiB0aGlzLnNpemUueCArIHhdID0gYWNjdTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkltYWdlV3JhcHBlci5wcm90b3R5cGUubW9tZW50cyA9IGZ1bmN0aW9uKGxhYmVsY291bnQpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5zaXplLnksXG4gICAgICAgIHdpZHRoID0gdGhpcy5zaXplLngsXG4gICAgICAgIHZhbCxcbiAgICAgICAgeXNxLFxuICAgICAgICBsYWJlbHN1bSA9IFtdLFxuICAgICAgICBpLFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgbXUxMSxcbiAgICAgICAgbXUwMixcbiAgICAgICAgbXUyMCxcbiAgICAgICAgeF8sXG4gICAgICAgIHlfLFxuICAgICAgICB0bXAsXG4gICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICBQSSA9IE1hdGguUEksXG4gICAgICAgIFBJXzQgPSBQSSAvIDQ7XG5cbiAgICBpZiAobGFiZWxjb3VudCA8PSAwKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZm9yICggaSA9IDA7IGkgPCBsYWJlbGNvdW50OyBpKyspIHtcbiAgICAgICAgbGFiZWxzdW1baV0gPSB7XG4gICAgICAgICAgICBtMDA6IDAsXG4gICAgICAgICAgICBtMDE6IDAsXG4gICAgICAgICAgICBtMTA6IDAsXG4gICAgICAgICAgICBtMTE6IDAsXG4gICAgICAgICAgICBtMDI6IDAsXG4gICAgICAgICAgICBtMjA6IDAsXG4gICAgICAgICAgICB0aGV0YTogMCxcbiAgICAgICAgICAgIHJhZDogMFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZvciAoIHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgeXNxID0geSAqIHk7XG4gICAgICAgIGZvciAoIHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgdmFsID0gZGF0YVt5ICogd2lkdGggKyB4XTtcbiAgICAgICAgICAgIGlmICh2YWwgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwgPSBsYWJlbHN1bVt2YWwgLSAxXTtcbiAgICAgICAgICAgICAgICBsYWJlbC5tMDAgKz0gMTtcbiAgICAgICAgICAgICAgICBsYWJlbC5tMDEgKz0geTtcbiAgICAgICAgICAgICAgICBsYWJlbC5tMTAgKz0geDtcbiAgICAgICAgICAgICAgICBsYWJlbC5tMTEgKz0geCAqIHk7XG4gICAgICAgICAgICAgICAgbGFiZWwubTAyICs9IHlzcTtcbiAgICAgICAgICAgICAgICBsYWJlbC5tMjAgKz0geCAqIHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IGxhYmVsY291bnQ7IGkrKykge1xuICAgICAgICBsYWJlbCA9IGxhYmVsc3VtW2ldO1xuICAgICAgICBpZiAoIWlzTmFOKGxhYmVsLm0wMCkgJiYgbGFiZWwubTAwICE9PSAwKSB7XG4gICAgICAgICAgICB4XyA9IGxhYmVsLm0xMCAvIGxhYmVsLm0wMDtcbiAgICAgICAgICAgIHlfID0gbGFiZWwubTAxIC8gbGFiZWwubTAwO1xuICAgICAgICAgICAgbXUxMSA9IGxhYmVsLm0xMSAvIGxhYmVsLm0wMCAtIHhfICogeV87XG4gICAgICAgICAgICBtdTAyID0gbGFiZWwubTAyIC8gbGFiZWwubTAwIC0geV8gKiB5XztcbiAgICAgICAgICAgIG11MjAgPSBsYWJlbC5tMjAgLyBsYWJlbC5tMDAgLSB4XyAqIHhfO1xuICAgICAgICAgICAgdG1wID0gKG11MDIgLSBtdTIwKSAvICgyICogbXUxMSk7XG4gICAgICAgICAgICB0bXAgPSAwLjUgKiBNYXRoLmF0YW4odG1wKSArIChtdTExID49IDAgPyBQSV80IDogLVBJXzQgKSArIFBJO1xuICAgICAgICAgICAgbGFiZWwudGhldGEgPSAodG1wICogMTgwIC8gUEkgKyA5MCkgJSAxODAgLSA5MDtcbiAgICAgICAgICAgIGlmIChsYWJlbC50aGV0YSA8IDApIHtcbiAgICAgICAgICAgICAgICBsYWJlbC50aGV0YSArPSAxODA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYWJlbC5yYWQgPSB0bXAgPiBQSSA/IHRtcCAtIFBJIDogdG1wO1xuICAgICAgICAgICAgbGFiZWwudmVjID0gdmVjMi5jbG9uZShbTWF0aC5jb3ModG1wKSwgTWF0aC5zaW4odG1wKV0pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobGFiZWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogRGlzcGxheXMgdGhlIHtJbWFnZVdyYXBwZXJ9IGluIGEgZ2l2ZW4gY2FudmFzXG4gKiBAcGFyYW0gY2FudmFzIHtDYW52YXN9IFRoZSBjYW52YXMgZWxlbWVudCB0byB3cml0ZSB0b1xuICogQHBhcmFtIHNjYWxlIHtOdW1iZXJ9IFNjYWxlIHdoaWNoIGlzIGFwcGxpZWQgdG8gZWFjaCBwaXhlbC12YWx1ZVxuICovXG5JbWFnZVdyYXBwZXIucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbihjYW52YXMsIHNjYWxlKSB7XG4gICAgdmFyIGN0eCxcbiAgICAgICAgZnJhbWUsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHBpeGVsLFxuICAgICAgICB4LFxuICAgICAgICB5O1xuXG4gICAgaWYgKCFzY2FsZSkge1xuICAgICAgICBzY2FsZSA9IDEuMDtcbiAgICB9XG4gICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY2FudmFzLndpZHRoID0gdGhpcy5zaXplLng7XG4gICAgY2FudmFzLmhlaWdodCA9IHRoaXMuc2l6ZS55O1xuICAgIGZyYW1lID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGRhdGEgPSBmcmFtZS5kYXRhO1xuICAgIGN1cnJlbnQgPSAwO1xuICAgIGZvciAoeSA9IDA7IHkgPCB0aGlzLnNpemUueTsgeSsrKSB7XG4gICAgICAgIGZvciAoeCA9IDA7IHggPCB0aGlzLnNpemUueDsgeCsrKSB7XG4gICAgICAgICAgICBwaXhlbCA9IHkgKiB0aGlzLnNpemUueCArIHg7XG4gICAgICAgICAgICBjdXJyZW50ID0gdGhpcy5nZXQoeCwgeSkgKiBzY2FsZTtcbiAgICAgICAgICAgIGRhdGFbcGl4ZWwgKiA0ICsgMF0gPSBjdXJyZW50O1xuICAgICAgICAgICAgZGF0YVtwaXhlbCAqIDQgKyAxXSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBkYXRhW3BpeGVsICogNCArIDJdID0gY3VycmVudDtcbiAgICAgICAgICAgIGRhdGFbcGl4ZWwgKiA0ICsgM10gPSAyNTU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy9mcmFtZS5kYXRhID0gZGF0YTtcbiAgICBjdHgucHV0SW1hZ2VEYXRhKGZyYW1lLCAwLCAwKTtcbn07XG5cbi8qKlxuICogRGlzcGxheXMgdGhlIHtTdWJJbWFnZX0gaW4gYSBnaXZlbiBjYW52YXNcbiAqIEBwYXJhbSBjYW52YXMge0NhbnZhc30gVGhlIGNhbnZhcyBlbGVtZW50IHRvIHdyaXRlIHRvXG4gKiBAcGFyYW0gc2NhbGUge051bWJlcn0gU2NhbGUgd2hpY2ggaXMgYXBwbGllZCB0byBlYWNoIHBpeGVsLXZhbHVlXG4gKi9cbkltYWdlV3JhcHBlci5wcm90b3R5cGUub3ZlcmxheSA9IGZ1bmN0aW9uKGNhbnZhcywgc2NhbGUsIGZyb20pIHtcbiAgICBpZiAoIXNjYWxlIHx8IHNjYWxlIDwgMCB8fCBzY2FsZSA+IDM2MCkge1xuICAgICAgICBzY2FsZSA9IDM2MDtcbiAgICB9XG4gICAgdmFyIGhzdiA9IFswLCAxLCAxXTtcbiAgICB2YXIgcmdiID0gWzAsIDAsIDBdO1xuICAgIHZhciB3aGl0ZVJnYiA9IFsyNTUsIDI1NSwgMjU1XTtcbiAgICB2YXIgYmxhY2tSZ2IgPSBbMCwgMCwgMF07XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB2YXIgZnJhbWUgPSBjdHguZ2V0SW1hZ2VEYXRhKGZyb20ueCwgZnJvbS55LCB0aGlzLnNpemUueCwgdGhpcy5zaXplLnkpO1xuICAgIHZhciBkYXRhID0gZnJhbWUuZGF0YTtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaHN2WzBdID0gdGhpcy5kYXRhW2xlbmd0aF0gKiBzY2FsZTtcbiAgICAgICAgcmVzdWx0ID0gaHN2WzBdIDw9IDAgPyB3aGl0ZVJnYiA6IGhzdlswXSA+PSAzNjAgPyBibGFja1JnYiA6IGhzdjJyZ2IoaHN2LCByZ2IpO1xuICAgICAgICBkYXRhW2xlbmd0aCAqIDQgKyAwXSA9IHJlc3VsdFswXTtcbiAgICAgICAgZGF0YVtsZW5ndGggKiA0ICsgMV0gPSByZXN1bHRbMV07XG4gICAgICAgIGRhdGFbbGVuZ3RoICogNCArIDJdID0gcmVzdWx0WzJdO1xuICAgICAgICBkYXRhW2xlbmd0aCAqIDQgKyAzXSA9IDI1NTtcbiAgICB9XG4gICAgY3R4LnB1dEltYWdlRGF0YShmcmFtZSwgZnJvbS54LCBmcm9tLnkpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VXcmFwcGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbW1vbi9pbWFnZV93cmFwcGVyLmpzIiwidmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduVmFsdWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fZ2V0TmF0aXZlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fdG9LZXkuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9pc0FycmF5TGlrZS5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvaXNGdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9pc0xlbmd0aC5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3ltYm9sO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9pc1N5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VNZXJnZSA9IHJlcXVpcmUoJy4vX2Jhc2VNZXJnZScpLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gcmVxdWlyZSgnLi9fY3JlYXRlQXNzaWduZXInKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAqIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIGludG8gdGhlXG4gKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICogYXJlIG1lcmdlZCByZWN1cnNpdmVseS4gT3RoZXIgb2JqZWN0cyBhbmQgdmFsdWUgdHlwZXMgYXJlIG92ZXJyaWRkZW4gYnlcbiAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuNS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7XG4gKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gKiB9O1xuICpcbiAqIHZhciBvdGhlciA9IHtcbiAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAqIH07XG4gKlxuICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IDIsICdjJzogMyB9LCB7ICdkJzogNCwgJ2UnOiA1IH1dIH1cbiAqL1xudmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVyZ2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL21lcmdlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogaHR0cDovL3d3dy5jb2RlcHJvamVjdC5jb20vVGlwcy80MDcxNzIvQ29ubmVjdGVkLUNvbXBvbmVudC1MYWJlbGluZy1hbmQtVmVjdG9yaXphdGlvblxuICovXG52YXIgVHJhY2VyID0ge1xuICAgIHNlYXJjaERpcmVjdGlvbnM6IFtbMCwgMV0sIFsxLCAxXSwgWzEsIDBdLCBbMSwgLTFdLCBbMCwgLTFdLCBbLTEsIC0xXSwgWy0xLCAwXSwgWy0xLCAxXV0sXG4gICAgY3JlYXRlOiBmdW5jdGlvbihpbWFnZVdyYXBwZXIsIGxhYmVsV3JhcHBlcikge1xuICAgICAgICB2YXIgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGEsXG4gICAgICAgICAgICBsYWJlbERhdGEgPSBsYWJlbFdyYXBwZXIuZGF0YSxcbiAgICAgICAgICAgIHNlYXJjaERpcmVjdGlvbnMgPSB0aGlzLnNlYXJjaERpcmVjdGlvbnMsXG4gICAgICAgICAgICB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLngsXG4gICAgICAgICAgICBwb3M7XG5cbiAgICAgICAgZnVuY3Rpb24gdHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpIHtcbiAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgeDtcblxuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgICAgICB5ID0gY3VycmVudC5jeSArIHNlYXJjaERpcmVjdGlvbnNbY3VycmVudC5kaXJdWzBdO1xuICAgICAgICAgICAgICAgIHggPSBjdXJyZW50LmN4ICsgc2VhcmNoRGlyZWN0aW9uc1tjdXJyZW50LmRpcl1bMV07XG4gICAgICAgICAgICAgICAgcG9zID0geSAqIHdpZHRoICsgeDtcbiAgICAgICAgICAgICAgICBpZiAoKGltYWdlRGF0YVtwb3NdID09PSBjb2xvcikgJiYgKChsYWJlbERhdGFbcG9zXSA9PT0gMCkgfHwgKGxhYmVsRGF0YVtwb3NdID09PSBsYWJlbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsRGF0YVtwb3NdID0gbGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuY3kgPSB5O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmN4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsRGF0YVtwb3NdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbERhdGFbcG9zXSA9IGVkZ2VsYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmRpciA9IChjdXJyZW50LmRpciArIDEpICUgODtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB2ZXJ0ZXgyRCh4LCB5LCBkaXIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGlyOiBkaXIsXG4gICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgcHJldjogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbnRvdXJUcmFjaW5nKHN5LCBzeCwgbGFiZWwsIGNvbG9yLCBlZGdlbGFiZWwpIHtcbiAgICAgICAgICAgIHZhciBGdiA9IG51bGwsXG4gICAgICAgICAgICAgICAgQ3YsXG4gICAgICAgICAgICAgICAgUCxcbiAgICAgICAgICAgICAgICBsZGlyLFxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGN4OiBzeCxcbiAgICAgICAgICAgICAgICAgICAgY3k6IHN5LFxuICAgICAgICAgICAgICAgICAgICBkaXI6IDBcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgRnYgPSB2ZXJ0ZXgyRChzeCwgc3ksIGN1cnJlbnQuZGlyKTtcbiAgICAgICAgICAgICAgICBDdiA9IEZ2O1xuICAgICAgICAgICAgICAgIGxkaXIgPSBjdXJyZW50LmRpcjtcbiAgICAgICAgICAgICAgICBQID0gdmVydGV4MkQoY3VycmVudC5jeCwgY3VycmVudC5jeSwgMCk7XG4gICAgICAgICAgICAgICAgUC5wcmV2ID0gQ3Y7XG4gICAgICAgICAgICAgICAgQ3YubmV4dCA9IFA7XG4gICAgICAgICAgICAgICAgUC5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBDdiA9IFA7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmRpciA9IChjdXJyZW50LmRpciArIDYpICUgODtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGRpciAhPT0gY3VycmVudC5kaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2LmRpciA9IGN1cnJlbnQuZGlyO1xuICAgICAgICAgICAgICAgICAgICAgICAgUCA9IHZlcnRleDJEKGN1cnJlbnQuY3gsIGN1cnJlbnQuY3ksIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgUC5wcmV2ID0gQ3Y7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdi5uZXh0ID0gUDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFAubmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdiA9IFA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdi5kaXIgPSBsZGlyO1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YueCA9IGN1cnJlbnQuY3g7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdi55ID0gY3VycmVudC5jeTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZGlyID0gY3VycmVudC5kaXI7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoY3VycmVudC5jeCAhPT0gc3ggfHwgY3VycmVudC5jeSAhPT0gc3kpO1xuICAgICAgICAgICAgICAgIEZ2LnByZXYgPSBDdi5wcmV2O1xuICAgICAgICAgICAgICAgIEN2LnByZXYubmV4dCA9IEZ2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZ2O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyYWNlOiBmdW5jdGlvbihjdXJyZW50LCBjb2xvciwgbGFiZWwsIGVkZ2VsYWJlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFjZShjdXJyZW50LCBjb2xvciwgbGFiZWwsIGVkZ2VsYWJlbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udG91clRyYWNpbmc6IGZ1bmN0aW9uKHN5LCBzeCwgbGFiZWwsIGNvbG9yLCBlZGdlbGFiZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udG91clRyYWNpbmcoc3ksIHN4LCBsYWJlbCwgY29sb3IsIGVkZ2VsYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKFRyYWNlcik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbG9jYXRvci90cmFjZXIuanMiLCJpbXBvcnQgQmFyY29kZVJlYWRlciBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcblxuZnVuY3Rpb24gQ29kZTM5UmVhZGVyKCkge1xuICAgIEJhcmNvZGVSZWFkZXIuY2FsbCh0aGlzKTtcbn1cblxudmFyIHByb3BlcnRpZXMgPSB7XG4gICAgQUxQSEFCRVRIX1NUUklORzoge3ZhbHVlOiBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWi0uICokLyslXCJ9LFxuICAgIEFMUEhBQkVUOiB7dmFsdWU6IFs0OCwgNDksIDUwLCA1MSwgNTIsIDUzLCA1NCwgNTUsIDU2LCA1NywgNjUsIDY2LCA2NywgNjgsIDY5LCA3MCwgNzEsIDcyLCA3MywgNzQsIDc1LCA3NiwgNzcsIDc4LFxuICAgICAgICA3OSwgODAsIDgxLCA4MiwgODMsIDg0LCA4NSwgODYsIDg3LCA4OCwgODksIDkwLCA0NSwgNDYsIDMyLCA0MiwgMzYsIDQ3LCA0MywgMzddfSxcbiAgICBDSEFSQUNURVJfRU5DT0RJTkdTOiB7dmFsdWU6IFsweDAzNCwgMHgxMjEsIDB4MDYxLCAweDE2MCwgMHgwMzEsIDB4MTMwLCAweDA3MCwgMHgwMjUsIDB4MTI0LCAweDA2NCwgMHgxMDksIDB4MDQ5LFxuICAgICAgICAweDE0OCwgMHgwMTksIDB4MTE4LCAweDA1OCwgMHgwMEQsIDB4MTBDLCAweDA0QywgMHgwMUMsIDB4MTAzLCAweDA0MywgMHgxNDIsIDB4MDEzLCAweDExMiwgMHgwNTIsIDB4MDA3LCAweDEwNixcbiAgICAgICAgMHgwNDYsIDB4MDE2LCAweDE4MSwgMHgwQzEsIDB4MUMwLCAweDA5MSwgMHgxOTAsIDB4MEQwLCAweDA4NSwgMHgxODQsIDB4MEM0LCAweDA5NCwgMHgwQTgsIDB4MEEyLCAweDA4QSwgMHgwMkFcbiAgICBdfSxcbiAgICBBU1RFUklTSzoge3ZhbHVlOiAweDA5NH0sXG4gICAgRk9STUFUOiB7dmFsdWU6IFwiY29kZV8zOVwiLCB3cml0ZWFibGU6IGZhbHNlfVxufTtcblxuQ29kZTM5UmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFyY29kZVJlYWRlci5wcm90b3R5cGUsIHByb3BlcnRpZXMpO1xuQ29kZTM5UmVhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvZGUzOVJlYWRlcjtcblxuQ29kZTM5UmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBjb3VudGVycyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSxcbiAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgIHN0YXJ0ID0gc2VsZi5fZmluZFN0YXJ0KCksXG4gICAgICAgIGRlY29kZWRDaGFyLFxuICAgICAgICBsYXN0U3RhcnQsXG4gICAgICAgIHBhdHRlcm4sXG4gICAgICAgIG5leHRTdGFydDtcblxuICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG5leHRTdGFydCA9IHNlbGYuX25leHRTZXQoc2VsZi5fcm93LCBzdGFydC5lbmQpO1xuXG4gICAgZG8ge1xuICAgICAgICBjb3VudGVycyA9IHNlbGYuX3RvQ291bnRlcnMobmV4dFN0YXJ0LCBjb3VudGVycyk7XG4gICAgICAgIHBhdHRlcm4gPSBzZWxmLl90b1BhdHRlcm4oY291bnRlcnMpO1xuICAgICAgICBpZiAocGF0dGVybiA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZWRDaGFyID0gc2VsZi5fcGF0dGVyblRvQ2hhcihwYXR0ZXJuKTtcbiAgICAgICAgaWYgKGRlY29kZWRDaGFyIDwgMCl7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkQ2hhcik7XG4gICAgICAgIGxhc3RTdGFydCA9IG5leHRTdGFydDtcbiAgICAgICAgbmV4dFN0YXJ0ICs9IEFycmF5SGVscGVyLnN1bShjb3VudGVycyk7XG4gICAgICAgIG5leHRTdGFydCA9IHNlbGYuX25leHRTZXQoc2VsZi5fcm93LCBuZXh0U3RhcnQpO1xuICAgIH0gd2hpbGUgKGRlY29kZWRDaGFyICE9PSAnKicpO1xuICAgIHJlc3VsdC5wb3AoKTtcblxuICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIXNlbGYuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShsYXN0U3RhcnQsIG5leHRTdGFydCwgY291bnRlcnMpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKFwiXCIpLFxuICAgICAgICBzdGFydDogc3RhcnQuc3RhcnQsXG4gICAgICAgIGVuZDogbmV4dFN0YXJ0LFxuICAgICAgICBzdGFydEluZm86IHN0YXJ0LFxuICAgICAgICBkZWNvZGVkQ29kZXM6IHJlc3VsdFxuICAgIH07XG59O1xuXG5Db2RlMzlSZWFkZXIucHJvdG90eXBlLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UgPSBmdW5jdGlvbihsYXN0U3RhcnQsIG5leHRTdGFydCwgY291bnRlcnMpIHtcbiAgICB2YXIgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLFxuICAgICAgICBwYXR0ZXJuU2l6ZSA9IEFycmF5SGVscGVyLnN1bShjb3VudGVycyk7XG5cbiAgICB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBuZXh0U3RhcnQgLSBsYXN0U3RhcnQgLSBwYXR0ZXJuU2l6ZTtcbiAgICBpZiAoKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCAqIDMpID49IHBhdHRlcm5TaXplKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5Db2RlMzlSZWFkZXIucHJvdG90eXBlLl9wYXR0ZXJuVG9DaGFyID0gZnVuY3Rpb24ocGF0dGVybikge1xuICAgIHZhciBpLFxuICAgICAgICBzZWxmID0gdGhpcztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzZWxmLkNIQVJBQ1RFUl9FTkNPRElOR1MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGYuQ0hBUkFDVEVSX0VOQ09ESU5HU1tpXSA9PT0gcGF0dGVybikge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoc2VsZi5BTFBIQUJFVFtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcblxuQ29kZTM5UmVhZGVyLnByb3RvdHlwZS5fZmluZE5leHRXaWR0aCA9IGZ1bmN0aW9uKGNvdW50ZXJzLCBjdXJyZW50KSB7XG4gICAgdmFyIGksXG4gICAgICAgIG1pbldpZHRoID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY291bnRlcnNbaV0gPCBtaW5XaWR0aCAmJiBjb3VudGVyc1tpXSA+IGN1cnJlbnQpIHtcbiAgICAgICAgICAgIG1pbldpZHRoID0gY291bnRlcnNbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWluV2lkdGg7XG59O1xuXG5Db2RlMzlSZWFkZXIucHJvdG90eXBlLl90b1BhdHRlcm4gPSBmdW5jdGlvbihjb3VudGVycykge1xuICAgIHZhciBudW1Db3VudGVycyA9IGNvdW50ZXJzLmxlbmd0aCxcbiAgICAgICAgbWF4TmFycm93V2lkdGggPSAwLFxuICAgICAgICBudW1XaWRlQmFycyA9IG51bUNvdW50ZXJzLFxuICAgICAgICB3aWRlQmFyV2lkdGggPSAwLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgcGF0dGVybixcbiAgICAgICAgaTtcblxuICAgIHdoaWxlIChudW1XaWRlQmFycyA+IDMpIHtcbiAgICAgICAgbWF4TmFycm93V2lkdGggPSBzZWxmLl9maW5kTmV4dFdpZHRoKGNvdW50ZXJzLCBtYXhOYXJyb3dXaWR0aCk7XG4gICAgICAgIG51bVdpZGVCYXJzID0gMDtcbiAgICAgICAgcGF0dGVybiA9IDA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1Db3VudGVyczsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY291bnRlcnNbaV0gPiBtYXhOYXJyb3dXaWR0aCkge1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gfD0gMSA8PCAobnVtQ291bnRlcnMgLSAxIC0gaSk7XG4gICAgICAgICAgICAgICAgbnVtV2lkZUJhcnMrKztcbiAgICAgICAgICAgICAgICB3aWRlQmFyV2lkdGggKz0gY291bnRlcnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobnVtV2lkZUJhcnMgPT09IDMpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1Db3VudGVycyAmJiBudW1XaWRlQmFycyA+IDA7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyc1tpXSA+IG1heE5hcnJvd1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bVdpZGVCYXJzLS07XG4gICAgICAgICAgICAgICAgICAgIGlmICgoY291bnRlcnNbaV0gKiAyKSA+PSB3aWRlQmFyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn07XG5cbkNvZGUzOVJlYWRlci5wcm90b3R5cGUuX2ZpbmRTdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgb2Zmc2V0ID0gc2VsZi5fbmV4dFNldChzZWxmLl9yb3cpLFxuICAgICAgICBwYXR0ZXJuU3RhcnQgPSBvZmZzZXQsXG4gICAgICAgIGNvdW50ZXIgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0sXG4gICAgICAgIGNvdW50ZXJQb3MgPSAwLFxuICAgICAgICBpc1doaXRlID0gZmFsc2UsXG4gICAgICAgIGksXG4gICAgICAgIGosXG4gICAgICAgIHdoaXRlU3BhY2VNdXN0U3RhcnQ7XG5cbiAgICBmb3IgKCBpID0gb2Zmc2V0OyBpIDwgc2VsZi5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmLl9yb3dbaV0gXiBpc1doaXRlKSB7XG4gICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gZmluZCBzdGFydCBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX3RvUGF0dGVybihjb3VudGVyKSA9PT0gc2VsZi5BU1RFUklTSykge1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZVNwYWNlTXVzdFN0YXJ0ID0gTWF0aC5mbG9vcihNYXRoLm1heCgwLCBwYXR0ZXJuU3RhcnQgLSAoKGkgLSBwYXR0ZXJuU3RhcnQpIC8gNCkpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX21hdGNoUmFuZ2Uod2hpdGVTcGFjZU11c3RTdGFydCwgcGF0dGVyblN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcGF0dGVyblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogaVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyWzBdICsgY291bnRlclsxXTtcbiAgICAgICAgICAgICAgICBmb3IgKCBqID0gMDsgaiA8IDc7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbN10gPSAwO1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbOF0gPSAwO1xuICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDb2RlMzlSZWFkZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVhZGVyL2NvZGVfMzlfcmVhZGVyLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBkb3RcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbmZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZ2wtdmVjMi9kb3QuanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19NYXAuanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19NYXBDYWNoZS5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbk1lcmdlVmFsdWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19hc3NpZ25NZXJnZVZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduVmFsdWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19hc3NpZ25WYWx1ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0eTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19mcmVlR2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQcm90b3R5cGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19pc1Byb3RvdHlwZS5qc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyUmVzdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX292ZXJSZXN0LmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzYWZlR2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fc2FmZUdldC5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VTZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VTZXRUb1N0cmluZycpLFxuICAgIHNob3J0T3V0ID0gcmVxdWlyZSgnLi9fc2hvcnRPdXQnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb1N0cmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX3NldFRvU3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9pZGVudGl0eS5qc1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290JyksXG4gICAgc3R1YkZhbHNlID0gcmVxdWlyZSgnLi9zdHViRmFsc2UnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9pc0J1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VJc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19iYXNlSXNUeXBlZEFycmF5JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL2lzVHlwZWRBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzSW4nKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9rZXlzSW4uanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFR5cGVEZWZzIGZyb20gJy4vY29tbW9uL3R5cGVkZWZzJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tICcuL2NvbW1vbi9pbWFnZV93cmFwcGVyJztcbmltcG9ydCBCYXJjb2RlTG9jYXRvciBmcm9tICcuL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yJztcbmltcG9ydCBCYXJjb2RlRGVjb2RlciBmcm9tICcuL2RlY29kZXIvYmFyY29kZV9kZWNvZGVyJztcbmltcG9ydCBFdmVudHMgZnJvbSAnLi9jb21tb24vZXZlbnRzJztcbmltcG9ydCBDYW1lcmFBY2Nlc3MgZnJvbSAnLi9pbnB1dC9jYW1lcmFfYWNjZXNzJztcbmltcG9ydCBJbWFnZURlYnVnIGZyb20gJy4vY29tbW9uL2ltYWdlX2RlYnVnJztcbmltcG9ydCBSZXN1bHRDb2xsZWN0b3IgZnJvbSAnLi9hbmFseXRpY3MvcmVzdWx0X2NvbGxlY3Rvcic7XG5pbXBvcnQgQ29uZmlnIGZyb20gJy4vY29uZmlnL2NvbmZpZyc7XG5pbXBvcnQgSW5wdXRTdHJlYW0gZnJvbSAnaW5wdXRfc3RyZWFtJztcbmltcG9ydCBGcmFtZUdyYWJiZXIgZnJvbSAnZnJhbWVfZ3JhYmJlcic7XG5pbXBvcnQge21lcmdlfSBmcm9tICdsb2Rhc2gnO1xuY29uc3QgdmVjMiA9IHtcbiAgICBjbG9uZTogcmVxdWlyZSgnZ2wtdmVjMi9jbG9uZScpXG59O1xuXG52YXIgX2lucHV0U3RyZWFtLFxuICAgIF9mcmFtZWdyYWJiZXIsXG4gICAgX3N0b3BwZWQsXG4gICAgX2NhbnZhc0NvbnRhaW5lciA9IHtcbiAgICAgICAgY3R4OiB7XG4gICAgICAgICAgICBpbWFnZTogbnVsbCxcbiAgICAgICAgICAgIG92ZXJsYXk6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgZG9tOiB7XG4gICAgICAgICAgICBpbWFnZTogbnVsbCxcbiAgICAgICAgICAgIG92ZXJsYXk6IG51bGxcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX2lucHV0SW1hZ2VXcmFwcGVyLFxuICAgIF9ib3hTaXplLFxuICAgIF9kZWNvZGVyLFxuICAgIF93b3JrZXJQb29sID0gW10sXG4gICAgX29uVUlUaHJlYWQgPSB0cnVlLFxuICAgIF9yZXN1bHRDb2xsZWN0b3IsXG4gICAgX2NvbmZpZyA9IHt9O1xuXG5mdW5jdGlvbiBpbml0aWFsaXplRGF0YShpbWFnZVdyYXBwZXIpIHtcbiAgICBpbml0QnVmZmVycyhpbWFnZVdyYXBwZXIpO1xuICAgIF9kZWNvZGVyID0gQmFyY29kZURlY29kZXIuY3JlYXRlKF9jb25maWcuZGVjb2RlciwgX2lucHV0SW1hZ2VXcmFwcGVyKTtcbn1cblxuZnVuY3Rpb24gaW5pdElucHV0U3RyZWFtKGNiKSB7XG4gICAgdmFyIHZpZGVvO1xuICAgIGlmIChfY29uZmlnLmlucHV0U3RyZWFtLnR5cGUgPT09IFwiVmlkZW9TdHJlYW1cIikge1xuICAgICAgICB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiKTtcbiAgICAgICAgX2lucHV0U3RyZWFtID0gSW5wdXRTdHJlYW0uY3JlYXRlVmlkZW9TdHJlYW0odmlkZW8pO1xuICAgIH0gZWxzZSBpZiAoX2NvbmZpZy5pbnB1dFN0cmVhbS50eXBlID09PSBcIkltYWdlU3RyZWFtXCIpIHtcbiAgICAgICAgX2lucHV0U3RyZWFtID0gSW5wdXRTdHJlYW0uY3JlYXRlSW1hZ2VTdHJlYW0oKTtcbiAgICB9IGVsc2UgaWYgKF9jb25maWcuaW5wdXRTdHJlYW0udHlwZSA9PT0gXCJMaXZlU3RyZWFtXCIpIHtcbiAgICAgICAgdmFyICR2aWV3cG9ydCA9IGdldFZpZXdQb3J0KCk7XG4gICAgICAgIGlmICgkdmlld3BvcnQpIHtcbiAgICAgICAgICAgIHZpZGVvID0gJHZpZXdwb3J0LnF1ZXJ5U2VsZWN0b3IoXCJ2aWRlb1wiKTtcbiAgICAgICAgICAgIGlmICghdmlkZW8pIHtcbiAgICAgICAgICAgICAgICB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiKTtcbiAgICAgICAgICAgICAgICAkdmlld3BvcnQuYXBwZW5kQ2hpbGQodmlkZW8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9pbnB1dFN0cmVhbSA9IElucHV0U3RyZWFtLmNyZWF0ZUxpdmVTdHJlYW0odmlkZW8pO1xuICAgICAgICBDYW1lcmFBY2Nlc3MucmVxdWVzdCh2aWRlbywgX2NvbmZpZy5pbnB1dFN0cmVhbS5jb25zdHJhaW50cylcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgX2lucHV0U3RyZWFtLnRyaWdnZXIoXCJjYW5yZWNvcmRcIik7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfaW5wdXRTdHJlYW0uc2V0QXR0cmlidXRlKFwicHJlbG9hZFwiLCBcImF1dG9cIik7XG4gICAgX2lucHV0U3RyZWFtLnNldElucHV0U3RyZWFtKF9jb25maWcuaW5wdXRTdHJlYW0pO1xuICAgIF9pbnB1dFN0cmVhbS5hZGRFdmVudExpc3RlbmVyKFwiY2FucmVjb3JkXCIsIGNhblJlY29yZC5iaW5kKHVuZGVmaW5lZCwgY2IpKTtcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld1BvcnQoKSB7XG4gICAgdmFyIHRhcmdldCA9IF9jb25maWcuaW5wdXRTdHJlYW0udGFyZ2V0O1xuICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyBhbHJlYWR5IGEgRE9NIGVsZW1lbnRcbiAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5ub2RlTmFtZSAmJiB0YXJnZXQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVc2UgJyNpbnRlcmFjdGl2ZS52aWV3cG9ydCcgYXMgYSBmYWxsYmFjayBzZWxlY3RvciAoYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpXG4gICAgICAgIHZhciBzZWxlY3RvciA9IHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnID8gdGFyZ2V0IDogJyNpbnRlcmFjdGl2ZS52aWV3cG9ydCc7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNhblJlY29yZChjYikge1xuICAgIEJhcmNvZGVMb2NhdG9yLmNoZWNrSW1hZ2VDb25zdHJhaW50cyhfaW5wdXRTdHJlYW0sIF9jb25maWcubG9jYXRvcik7XG4gICAgaW5pdENhbnZhcyhfY29uZmlnKTtcbiAgICBfZnJhbWVncmFiYmVyID0gRnJhbWVHcmFiYmVyLmNyZWF0ZShfaW5wdXRTdHJlYW0sIF9jYW52YXNDb250YWluZXIuZG9tLmltYWdlKTtcblxuICAgIGFkanVzdFdvcmtlclBvb2woX2NvbmZpZy5udW1PZldvcmtlcnMsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoX2NvbmZpZy5udW1PZldvcmtlcnMgPT09IDApIHtcbiAgICAgICAgICAgIGluaXRpYWxpemVEYXRhKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVhZHkoY2IpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiByZWFkeShjYil7XG4gICAgX2lucHV0U3RyZWFtLnBsYXkoKTtcbiAgICBjYigpO1xufVxuXG5mdW5jdGlvbiBpbml0Q2FudmFzKCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdmFyICR2aWV3cG9ydCA9IGdldFZpZXdQb3J0KCk7XG4gICAgICAgIF9jYW52YXNDb250YWluZXIuZG9tLmltYWdlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImNhbnZhcy5pbWdCdWZmZXJcIik7XG4gICAgICAgIGlmICghX2NhbnZhc0NvbnRhaW5lci5kb20uaW1hZ2UpIHtcbiAgICAgICAgICAgIF9jYW52YXNDb250YWluZXIuZG9tLmltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgICAgIF9jYW52YXNDb250YWluZXIuZG9tLmltYWdlLmNsYXNzTmFtZSA9IFwiaW1nQnVmZmVyXCI7XG4gICAgICAgICAgICBpZiAoJHZpZXdwb3J0ICYmIF9jb25maWcuaW5wdXRTdHJlYW0udHlwZSA9PT0gXCJJbWFnZVN0cmVhbVwiKSB7XG4gICAgICAgICAgICAgICAgJHZpZXdwb3J0LmFwcGVuZENoaWxkKF9jYW52YXNDb250YWluZXIuZG9tLmltYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfY2FudmFzQ29udGFpbmVyLmN0eC5pbWFnZSA9IF9jYW52YXNDb250YWluZXIuZG9tLmltYWdlLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgX2NhbnZhc0NvbnRhaW5lci5kb20uaW1hZ2Uud2lkdGggPSBfaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpLng7XG4gICAgICAgIF9jYW52YXNDb250YWluZXIuZG9tLmltYWdlLmhlaWdodCA9IF9pbnB1dFN0cmVhbS5nZXRDYW52YXNTaXplKCkueTtcblxuICAgICAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5vdmVybGF5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImNhbnZhcy5kcmF3aW5nQnVmZmVyXCIpO1xuICAgICAgICBpZiAoIV9jYW52YXNDb250YWluZXIuZG9tLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIF9jYW52YXNDb250YWluZXIuZG9tLm92ZXJsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgX2NhbnZhc0NvbnRhaW5lci5kb20ub3ZlcmxheS5jbGFzc05hbWUgPSBcImRyYXdpbmdCdWZmZXJcIjtcbiAgICAgICAgICAgIGlmICgkdmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICAkdmlld3BvcnQuYXBwZW5kQ2hpbGQoX2NhbnZhc0NvbnRhaW5lci5kb20ub3ZlcmxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2xlYXJGaXggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7XG4gICAgICAgICAgICBjbGVhckZpeC5zZXRBdHRyaWJ1dGUoXCJjbGVhclwiLCBcImFsbFwiKTtcbiAgICAgICAgICAgIGlmICgkdmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICAkdmlld3BvcnQuYXBwZW5kQ2hpbGQoY2xlYXJGaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9jYW52YXNDb250YWluZXIuY3R4Lm92ZXJsYXkgPSBfY2FudmFzQ29udGFpbmVyLmRvbS5vdmVybGF5LmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgX2NhbnZhc0NvbnRhaW5lci5kb20ub3ZlcmxheS53aWR0aCA9IF9pbnB1dFN0cmVhbS5nZXRDYW52YXNTaXplKCkueDtcbiAgICAgICAgX2NhbnZhc0NvbnRhaW5lci5kb20ub3ZlcmxheS5oZWlnaHQgPSBfaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpLnk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbml0QnVmZmVycyhpbWFnZVdyYXBwZXIpIHtcbiAgICBpZiAoaW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgIF9pbnB1dEltYWdlV3JhcHBlciA9IGltYWdlV3JhcHBlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBfaW5wdXRJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKHtcbiAgICAgICAgICAgIHg6IF9pbnB1dFN0cmVhbS5nZXRXaWR0aCgpLFxuICAgICAgICAgICAgeTogX2lucHV0U3RyZWFtLmdldEhlaWdodCgpXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgY29uc29sZS5sb2coX2lucHV0SW1hZ2VXcmFwcGVyLnNpemUpO1xuICAgIH1cbiAgICBfYm94U2l6ZSA9IFtcbiAgICAgICAgdmVjMi5jbG9uZShbMCwgMF0pLFxuICAgICAgICB2ZWMyLmNsb25lKFswLCBfaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS55XSksXG4gICAgICAgIHZlYzIuY2xvbmUoW19pbnB1dEltYWdlV3JhcHBlci5zaXplLngsIF9pbnB1dEltYWdlV3JhcHBlci5zaXplLnldKSxcbiAgICAgICAgdmVjMi5jbG9uZShbX2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueCwgMF0pXG4gICAgXTtcbiAgICBCYXJjb2RlTG9jYXRvci5pbml0KF9pbnB1dEltYWdlV3JhcHBlciwgX2NvbmZpZy5sb2NhdG9yKTtcbn1cblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdCb3hlcygpIHtcbiAgICBpZiAoX2NvbmZpZy5sb2NhdGUpIHtcbiAgICAgICAgcmV0dXJuIEJhcmNvZGVMb2NhdG9yLmxvY2F0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbW1xuICAgICAgICAgICAgdmVjMi5jbG9uZShfYm94U2l6ZVswXSksXG4gICAgICAgICAgICB2ZWMyLmNsb25lKF9ib3hTaXplWzFdKSxcbiAgICAgICAgICAgIHZlYzIuY2xvbmUoX2JveFNpemVbMl0pLFxuICAgICAgICAgICAgdmVjMi5jbG9uZShfYm94U2l6ZVszXSldXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVJlc3VsdChyZXN1bHQpIHtcbiAgICB2YXIgdG9wUmlnaHQgPSBfaW5wdXRTdHJlYW0uZ2V0VG9wUmlnaHQoKSxcbiAgICAgICAgeE9mZnNldCA9IHRvcFJpZ2h0LngsXG4gICAgICAgIHlPZmZzZXQgPSB0b3BSaWdodC55LFxuICAgICAgICBpO1xuXG4gICAgaWYgKHhPZmZzZXQgPT09IDAgJiYgeU9mZnNldCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5iYXJjb2Rlcykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVzdWx0LmJhcmNvZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1SZXN1bHQocmVzdWx0LmJhcmNvZGVzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXN1bHQubGluZSAmJiByZXN1bHQubGluZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgbW92ZUxpbmUocmVzdWx0LmxpbmUpO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQuYm94KSB7XG4gICAgICAgIG1vdmVCb3gocmVzdWx0LmJveCk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5ib3hlcyAmJiByZXN1bHQuYm94ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVzdWx0LmJveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBtb3ZlQm94KHJlc3VsdC5ib3hlc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3ZlQm94KGJveCkge1xuICAgICAgICB2YXIgY29ybmVyID0gYm94Lmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoY29ybmVyLS0pIHtcbiAgICAgICAgICAgIGJveFtjb3JuZXJdWzBdICs9IHhPZmZzZXQ7XG4gICAgICAgICAgICBib3hbY29ybmVyXVsxXSArPSB5T2Zmc2V0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW92ZUxpbmUobGluZSkge1xuICAgICAgICBsaW5lWzBdLnggKz0geE9mZnNldDtcbiAgICAgICAgbGluZVswXS55ICs9IHlPZmZzZXQ7XG4gICAgICAgIGxpbmVbMV0ueCArPSB4T2Zmc2V0O1xuICAgICAgICBsaW5lWzFdLnkgKz0geU9mZnNldDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFkZFJlc3VsdCAocmVzdWx0LCBpbWFnZURhdGEpIHtcbiAgICBpZiAoIWltYWdlRGF0YSB8fCAhX3Jlc3VsdENvbGxlY3Rvcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5iYXJjb2Rlcykge1xuICAgICAgICByZXN1bHQuYmFyY29kZXMuZmlsdGVyKGJhcmNvZGUgPT4gYmFyY29kZS5jb2RlUmVzdWx0KVxuICAgICAgICAgICAgLmZvckVhY2goYmFyY29kZSA9PiBhZGRSZXN1bHQoYmFyY29kZSwgaW1hZ2VEYXRhKSk7XG4gICAgfSBlbHNlIGlmIChyZXN1bHQuY29kZVJlc3VsdCkge1xuICAgICAgICBfcmVzdWx0Q29sbGVjdG9yLmFkZFJlc3VsdChpbWFnZURhdGEsIF9pbnB1dFN0cmVhbS5nZXRDYW52YXNTaXplKCksIHJlc3VsdC5jb2RlUmVzdWx0KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGhhc0NvZGVSZXN1bHQgKHJlc3VsdCkge1xuICAgIHJldHVybiByZXN1bHQgJiYgKHJlc3VsdC5iYXJjb2RlcyA/XG4gICAgICByZXN1bHQuYmFyY29kZXMuc29tZShiYXJjb2RlID0+IGJhcmNvZGUuY29kZVJlc3VsdCkgOlxuICAgICAgcmVzdWx0LmNvZGVSZXN1bHQpO1xufVxuXG5mdW5jdGlvbiBwdWJsaXNoUmVzdWx0KHJlc3VsdCwgaW1hZ2VEYXRhKSB7XG4gICAgbGV0IHJlc3VsdFRvUHVibGlzaCA9IHJlc3VsdDtcblxuICAgIGlmIChyZXN1bHQgJiYgX29uVUlUaHJlYWQpIHtcbiAgICAgICAgdHJhbnNmb3JtUmVzdWx0KHJlc3VsdCk7XG4gICAgICAgIGFkZFJlc3VsdChyZXN1bHQsIGltYWdlRGF0YSk7XG4gICAgICAgIHJlc3VsdFRvUHVibGlzaCA9IHJlc3VsdC5iYXJjb2RlcyB8fCByZXN1bHQ7XG4gICAgfVxuXG4gICAgRXZlbnRzLnB1Ymxpc2goXCJwcm9jZXNzZWRcIiwgcmVzdWx0VG9QdWJsaXNoKTtcbiAgICBpZiAoaGFzQ29kZVJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAgIEV2ZW50cy5wdWJsaXNoKFwiZGV0ZWN0ZWRcIiwgcmVzdWx0VG9QdWJsaXNoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGxvY2F0ZUFuZERlY29kZSgpIHtcbiAgICB2YXIgcmVzdWx0LFxuICAgICAgICBib3hlcztcblxuICAgIGJveGVzID0gZ2V0Qm91bmRpbmdCb3hlcygpO1xuICAgIGlmIChib3hlcykge1xuICAgICAgICByZXN1bHQgPSBfZGVjb2Rlci5kZWNvZGVGcm9tQm91bmRpbmdCb3hlcyhib3hlcyk7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB7fTtcbiAgICAgICAgcmVzdWx0LmJveGVzID0gYm94ZXM7XG4gICAgICAgIHB1Ymxpc2hSZXN1bHQocmVzdWx0LCBfaW5wdXRJbWFnZVdyYXBwZXIuZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHVibGlzaFJlc3VsdCgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHZhciBhdmFpbGFibGVXb3JrZXI7XG5cbiAgICBpZiAoX29uVUlUaHJlYWQpIHtcbiAgICAgICAgaWYgKF93b3JrZXJQb29sLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGF2YWlsYWJsZVdvcmtlciA9IF93b3JrZXJQb29sLmZpbHRlcihmdW5jdGlvbih3b3JrZXJUaHJlYWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXdvcmtlclRocmVhZC5idXN5O1xuICAgICAgICAgICAgfSlbMF07XG4gICAgICAgICAgICBpZiAoYXZhaWxhYmxlV29ya2VyKSB7XG4gICAgICAgICAgICAgICAgX2ZyYW1lZ3JhYmJlci5hdHRhY2hEYXRhKGF2YWlsYWJsZVdvcmtlci5pbWFnZURhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIGFsbCB3b3JrZXJzIGFyZSBidXN5XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfZnJhbWVncmFiYmVyLmF0dGFjaERhdGEoX2lucHV0SW1hZ2VXcmFwcGVyLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfZnJhbWVncmFiYmVyLmdyYWIoKSkge1xuICAgICAgICAgICAgaWYgKGF2YWlsYWJsZVdvcmtlcikge1xuICAgICAgICAgICAgICAgIGF2YWlsYWJsZVdvcmtlci5idXN5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVXb3JrZXIud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgY21kOiAncHJvY2VzcycsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlRGF0YTogYXZhaWxhYmxlV29ya2VyLmltYWdlRGF0YVxuICAgICAgICAgICAgICAgIH0sIFthdmFpbGFibGVXb3JrZXIuaW1hZ2VEYXRhLmJ1ZmZlcl0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2NhdGVBbmREZWNvZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGxvY2F0ZUFuZERlY29kZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRDb250aW51b3VzVXBkYXRlKCkge1xuICAgIHZhciBuZXh0ID0gbnVsbCxcbiAgICAgICAgZGVsYXkgPSAxMDAwIC8gKF9jb25maWcuZnJlcXVlbmN5IHx8IDYwKTtcblxuICAgIF9zdG9wcGVkID0gZmFsc2U7XG4gICAgKGZ1bmN0aW9uIGZyYW1lKHRpbWVzdGFtcCkge1xuICAgICAgICBuZXh0ID0gbmV4dCB8fCB0aW1lc3RhbXA7XG4gICAgICAgIGlmICghX3N0b3BwZWQpIHtcbiAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgPj0gbmV4dCkge1xuICAgICAgICAgICAgICAgIG5leHQgKz0gZGVsYXk7XG4gICAgICAgICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1GcmFtZShmcmFtZSk7XG4gICAgICAgIH1cbiAgICB9KHBlcmZvcm1hbmNlLm5vdygpKSk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgIGlmIChfb25VSVRocmVhZCAmJiBfY29uZmlnLmlucHV0U3RyZWFtLnR5cGUgPT09IFwiTGl2ZVN0cmVhbVwiKSB7XG4gICAgICAgIHN0YXJ0Q29udGludW91c1VwZGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdvcmtlcihjYikge1xuICAgIHZhciBibG9iVVJMLFxuICAgICAgICB3b3JrZXJUaHJlYWQgPSB7XG4gICAgICAgICAgICB3b3JrZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGltYWdlRGF0YTogbmV3IFVpbnQ4QXJyYXkoX2lucHV0U3RyZWFtLmdldFdpZHRoKCkgKiBfaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCkpLFxuICAgICAgICAgICAgYnVzeTogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgYmxvYlVSTCA9IGdlbmVyYXRlV29ya2VyQmxvYigpO1xuICAgIHdvcmtlclRocmVhZC53b3JrZXIgPSBuZXcgV29ya2VyKGJsb2JVUkwpO1xuXG4gICAgd29ya2VyVGhyZWFkLndvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLmRhdGEuZXZlbnQgPT09ICdpbml0aWFsaXplZCcpIHtcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoYmxvYlVSTCk7XG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQuYnVzeSA9IGZhbHNlO1xuICAgICAgICAgICAgd29ya2VyVGhyZWFkLmltYWdlRGF0YSA9IG5ldyBVaW50OEFycmF5KGUuZGF0YS5pbWFnZURhdGEpO1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV29ya2VyIGluaXRpYWxpemVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNiKHdvcmtlclRocmVhZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmV2ZW50ID09PSAncHJvY2Vzc2VkJykge1xuICAgICAgICAgICAgd29ya2VyVGhyZWFkLmltYWdlRGF0YSA9IG5ldyBVaW50OEFycmF5KGUuZGF0YS5pbWFnZURhdGEpO1xuICAgICAgICAgICAgd29ya2VyVGhyZWFkLmJ1c3kgPSBmYWxzZTtcbiAgICAgICAgICAgIHB1Ymxpc2hSZXN1bHQoZS5kYXRhLnJlc3VsdCwgd29ya2VyVGhyZWFkLmltYWdlRGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmV2ZW50ID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJXb3JrZXIgZXJyb3I6IFwiICsgZS5kYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHdvcmtlclRocmVhZC53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBjbWQ6ICdpbml0JyxcbiAgICAgICAgc2l6ZToge3g6IF9pbnB1dFN0cmVhbS5nZXRXaWR0aCgpLCB5OiBfaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCl9LFxuICAgICAgICBpbWFnZURhdGE6IHdvcmtlclRocmVhZC5pbWFnZURhdGEsXG4gICAgICAgIGNvbmZpZzogY29uZmlnRm9yV29ya2VyKF9jb25maWcpXG4gICAgfSwgW3dvcmtlclRocmVhZC5pbWFnZURhdGEuYnVmZmVyXSk7XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ0Zvcldvcmtlcihjb25maWcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5jb25maWcsXG4gICAgICAgIGlucHV0U3RyZWFtOiB7XG4gICAgICAgICAgICAuLi5jb25maWcuaW5wdXRTdHJlYW0sXG4gICAgICAgICAgICB0YXJnZXQ6IG51bGxcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHdvcmtlckludGVyZmFjZShmYWN0b3J5KSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYqL1xuICAgIGlmIChmYWN0b3J5KSB7XG4gICAgICAgIHZhciBRdWFnZ2EgPSBmYWN0b3J5KCkuZGVmYXVsdDtcbiAgICAgICAgaWYgKCFRdWFnZ2EpIHtcbiAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeydldmVudCc6ICdlcnJvcicsIG1lc3NhZ2U6ICdRdWFnZ2EgY291bGQgbm90IGJlIGNyZWF0ZWQnfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGltYWdlV3JhcHBlcjtcblxuICAgIHNlbGYub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5kYXRhLmNtZCA9PT0gJ2luaXQnKSB7XG4gICAgICAgICAgICB2YXIgY29uZmlnID0gZS5kYXRhLmNvbmZpZztcbiAgICAgICAgICAgIGNvbmZpZy5udW1PZldvcmtlcnMgPSAwO1xuICAgICAgICAgICAgaW1hZ2VXcmFwcGVyID0gbmV3IFF1YWdnYS5JbWFnZVdyYXBwZXIoe1xuICAgICAgICAgICAgICAgIHg6IGUuZGF0YS5zaXplLngsXG4gICAgICAgICAgICAgICAgeTogZS5kYXRhLnNpemUueVxuICAgICAgICAgICAgfSwgbmV3IFVpbnQ4QXJyYXkoZS5kYXRhLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgUXVhZ2dhLmluaXQoY29uZmlnLCByZWFkeSwgaW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgICAgIFF1YWdnYS5vblByb2Nlc3NlZChvblByb2Nlc3NlZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmNtZCA9PT0gJ3Byb2Nlc3MnKSB7XG4gICAgICAgICAgICBpbWFnZVdyYXBwZXIuZGF0YSA9IG5ldyBVaW50OEFycmF5KGUuZGF0YS5pbWFnZURhdGEpO1xuICAgICAgICAgICAgUXVhZ2dhLnN0YXJ0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmNtZCA9PT0gJ3NldFJlYWRlcnMnKSB7XG4gICAgICAgICAgICBRdWFnZ2Euc2V0UmVhZGVycyhlLmRhdGEucmVhZGVycyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb25Qcm9jZXNzZWQocmVzdWx0KSB7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgJ2V2ZW50JzogJ3Byb2Nlc3NlZCcsXG4gICAgICAgICAgICBpbWFnZURhdGE6IGltYWdlV3JhcHBlci5kYXRhLFxuICAgICAgICAgICAgcmVzdWx0OiByZXN1bHRcbiAgICAgICAgfSwgW2ltYWdlV3JhcHBlci5kYXRhLmJ1ZmZlcl0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWR5KCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeydldmVudCc6ICdpbml0aWFsaXplZCcsIGltYWdlRGF0YTogaW1hZ2VXcmFwcGVyLmRhdGF9LCBbaW1hZ2VXcmFwcGVyLmRhdGEuYnVmZmVyXSk7XG4gICAgfVxuXG4gICAgLyogZXNsaW50LWVuYWJsZSAqL1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVdvcmtlckJsb2IoKSB7XG4gICAgdmFyIGJsb2IsXG4gICAgICAgIGZhY3RvcnlTb3VyY2U7XG5cbiAgICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gICAgaWYgKHR5cGVvZiBfX2ZhY3RvcnlTb3VyY2VfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZmFjdG9yeVNvdXJjZSA9IF9fZmFjdG9yeVNvdXJjZV9fOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgfVxuICAgIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cbiAgICBibG9iID0gbmV3IEJsb2IoWycoJyArIHdvcmtlckludGVyZmFjZS50b1N0cmluZygpICsgJykoJyArIGZhY3RvcnlTb3VyY2UgKyAnKTsnXSxcbiAgICAgICAge3R5cGU6ICd0ZXh0L2phdmFzY3JpcHQnfSk7XG5cbiAgICByZXR1cm4gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG59XG5cbmZ1bmN0aW9uIHNldFJlYWRlcnMocmVhZGVycykge1xuICAgIGlmIChfZGVjb2Rlcikge1xuICAgICAgICBfZGVjb2Rlci5zZXRSZWFkZXJzKHJlYWRlcnMpO1xuICAgIH0gZWxzZSBpZiAoX29uVUlUaHJlYWQgJiYgX3dvcmtlclBvb2wubGVuZ3RoID4gMCkge1xuICAgICAgICBfd29ya2VyUG9vbC5mb3JFYWNoKGZ1bmN0aW9uKHdvcmtlclRocmVhZCkge1xuICAgICAgICAgICAgd29ya2VyVGhyZWFkLndvcmtlci5wb3N0TWVzc2FnZSh7Y21kOiAnc2V0UmVhZGVycycsIHJlYWRlcnM6IHJlYWRlcnN9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhZGp1c3RXb3JrZXJQb29sKGNhcGFjaXR5LCBjYikge1xuICAgIGNvbnN0IGluY3JlYXNlQnkgPSBjYXBhY2l0eSAtIF93b3JrZXJQb29sLmxlbmd0aDtcbiAgICBpZiAoaW5jcmVhc2VCeSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY2IgJiYgY2IoKTtcbiAgICB9XG4gICAgaWYgKGluY3JlYXNlQnkgPCAwKSB7XG4gICAgICAgIGNvbnN0IHdvcmtlcnNUb1Rlcm1pbmF0ZSA9IF93b3JrZXJQb29sLnNsaWNlKGluY3JlYXNlQnkpO1xuICAgICAgICB3b3JrZXJzVG9UZXJtaW5hdGUuZm9yRWFjaChmdW5jdGlvbih3b3JrZXJUaHJlYWQpIHtcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC53b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJXb3JrZXIgdGVybWluYXRlZCFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBfd29ya2VyUG9vbCA9IF93b3JrZXJQb29sLnNsaWNlKDAsIGluY3JlYXNlQnkpO1xuICAgICAgICByZXR1cm4gY2IgJiYgY2IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluY3JlYXNlQnk7IGkrKykge1xuICAgICAgICAgICAgaW5pdFdvcmtlcih3b3JrZXJJbml0aWFsaXplZCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB3b3JrZXJJbml0aWFsaXplZCh3b3JrZXJUaHJlYWQpIHtcbiAgICAgICAgICAgIF93b3JrZXJQb29sLnB1c2god29ya2VyVGhyZWFkKTtcbiAgICAgICAgICAgIGlmIChfd29ya2VyUG9vbC5sZW5ndGggPj0gY2FwYWNpdHkpe1xuICAgICAgICAgICAgICAgIGNiICYmIGNiKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBpbml0OiBmdW5jdGlvbihjb25maWcsIGNiLCBpbWFnZVdyYXBwZXIpIHtcbiAgICAgICAgX2NvbmZpZyA9IG1lcmdlKHt9LCBDb25maWcsIGNvbmZpZyk7XG4gICAgICAgIGlmIChpbWFnZVdyYXBwZXIpIHtcbiAgICAgICAgICAgIF9vblVJVGhyZWFkID0gZmFsc2U7XG4gICAgICAgICAgICBpbml0aWFsaXplRGF0YShpbWFnZVdyYXBwZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbml0SW5wdXRTdHJlYW0oY2IpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0YXJ0KCk7XG4gICAgfSxcbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICBhZGp1c3RXb3JrZXJQb29sKDApO1xuICAgICAgICBpZiAoX2NvbmZpZy5pbnB1dFN0cmVhbS50eXBlID09PSBcIkxpdmVTdHJlYW1cIikge1xuICAgICAgICAgICAgQ2FtZXJhQWNjZXNzLnJlbGVhc2UoKTtcbiAgICAgICAgICAgIF9pbnB1dFN0cmVhbS5jbGVhckV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcGF1c2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICBfc3RvcHBlZCA9IHRydWU7XG4gICAgfSxcbiAgICBvbkRldGVjdGVkOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICBFdmVudHMuc3Vic2NyaWJlKFwiZGV0ZWN0ZWRcIiwgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgb2ZmRGV0ZWN0ZWQ6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIEV2ZW50cy51bnN1YnNjcmliZShcImRldGVjdGVkXCIsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIG9uUHJvY2Vzc2VkOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICBFdmVudHMuc3Vic2NyaWJlKFwicHJvY2Vzc2VkXCIsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIG9mZlByb2Nlc3NlZDogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgRXZlbnRzLnVuc3Vic2NyaWJlKFwicHJvY2Vzc2VkXCIsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIHNldFJlYWRlcnM6IGZ1bmN0aW9uKHJlYWRlcnMpIHtcbiAgICAgICAgc2V0UmVhZGVycyhyZWFkZXJzKTtcbiAgICB9LFxuICAgIHJlZ2lzdGVyUmVzdWx0Q29sbGVjdG9yOiBmdW5jdGlvbihyZXN1bHRDb2xsZWN0b3IpIHtcbiAgICAgICAgaWYgKHJlc3VsdENvbGxlY3RvciAmJiB0eXBlb2YgcmVzdWx0Q29sbGVjdG9yLmFkZFJlc3VsdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgX3Jlc3VsdENvbGxlY3RvciA9IHJlc3VsdENvbGxlY3RvcjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY2FudmFzOiBfY2FudmFzQ29udGFpbmVyLFxuICAgIGRlY29kZVNpbmdsZTogZnVuY3Rpb24oY29uZmlnLCByZXN1bHRDYWxsYmFjaykge1xuICAgICAgICBjb25maWcgPSBtZXJnZSh7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiSW1hZ2VTdHJlYW1cIixcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2l6ZTogODAwLFxuICAgICAgICAgICAgICAgIHNyYzogY29uZmlnLnNyY1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG51bU9mV29ya2VyczogKEVOVi5kZXZlbG9wbWVudCAmJiBjb25maWcuZGVidWcpID8gMCA6IDEsXG4gICAgICAgICAgICBsb2NhdG9yOiB7XG4gICAgICAgICAgICAgICAgaGFsZlNhbXBsZTogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgY29uZmlnKTtcbiAgICAgICAgdGhpcy5pbml0KGNvbmZpZywgKCkgPT4ge1xuICAgICAgICAgICAgRXZlbnRzLm9uY2UoXCJwcm9jZXNzZWRcIiwgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdENhbGxiYWNrLmNhbGwobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgc3RhcnQoKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBJbWFnZVdyYXBwZXI6IEltYWdlV3JhcHBlcixcbiAgICBJbWFnZURlYnVnOiBJbWFnZURlYnVnLFxuICAgIFJlc3VsdENvbGxlY3RvcjogUmVzdWx0Q29sbGVjdG9yLFxuICAgIENhbWVyYUFjY2VzczogQ2FtZXJhQWNjZXNzLFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9xdWFnZ2EuanMiLCJpbXBvcnQgSW1hZ2VEZWJ1ZyBmcm9tICcuLi9jb21tb24vaW1hZ2VfZGVidWcnO1xuXG5mdW5jdGlvbiBjb250YWlucyhjb2RlUmVzdWx0LCBsaXN0KSB7XG4gICAgaWYgKGxpc3QpIHtcbiAgICAgICAgcmV0dXJuIGxpc3Quc29tZShmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGl0ZW0pLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVtrZXldID09PSBjb2RlUmVzdWx0W2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcGFzc2VzRmlsdGVyKGNvZGVSZXN1bHQsIGZpbHRlcikge1xuICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXIoY29kZVJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgY3JlYXRlOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksXG4gICAgICAgICAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLFxuICAgICAgICAgICAgcmVzdWx0cyA9IFtdLFxuICAgICAgICAgICAgY2FwYWNpdHkgPSBjb25maWcuY2FwYWNpdHkgfHwgMjAsXG4gICAgICAgICAgICBjYXB0dXJlID0gY29uZmlnLmNhcHR1cmUgPT09IHRydWU7XG5cbiAgICAgICAgZnVuY3Rpb24gbWF0Y2hlc0NvbnN0cmFpbnRzKGNvZGVSZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYXBhY2l0eVxuICAgICAgICAgICAgICAgICYmIGNvZGVSZXN1bHRcbiAgICAgICAgICAgICAgICAmJiAhY29udGFpbnMoY29kZVJlc3VsdCwgY29uZmlnLmJsYWNrbGlzdClcbiAgICAgICAgICAgICAgICAmJiBwYXNzZXNGaWx0ZXIoY29kZVJlc3VsdCwgY29uZmlnLmZpbHRlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkUmVzdWx0OiBmdW5jdGlvbihkYXRhLCBpbWFnZVNpemUsIGNvZGVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlc0NvbnN0cmFpbnRzKGNvZGVSZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhcGFjaXR5LS07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jb2RlUmVzdWx0ID0gY29kZVJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltYWdlU2l6ZS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGltYWdlU2l6ZS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3SW1hZ2UoZGF0YSwgaW1hZ2VTaXplLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmZyYW1lID0gY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRSZXN1bHRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FuYWx5dGljcy9yZXN1bHRfY29sbGVjdG9yLmpzIiwiY29uc3QgdmVjMiA9IHtcbiAgICBjbG9uZTogcmVxdWlyZSgnZ2wtdmVjMi9jbG9uZScpLFxuICAgIGRvdDogcmVxdWlyZSgnZ2wtdmVjMi9kb3QnKVxufVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbHVzdGVyIGZvciBncm91cGluZyBzaW1pbGFyIG9yaWVudGF0aW9ucyBvZiBkYXRhcG9pbnRzXG4gICAgICovXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgY3JlYXRlOiBmdW5jdGlvbihwb2ludCwgdGhyZXNob2xkKSB7XG4gICAgICAgIHZhciBwb2ludHMgPSBbXSxcbiAgICAgICAgICAgIGNlbnRlciA9IHtcbiAgICAgICAgICAgICAgICByYWQ6IDAsXG4gICAgICAgICAgICAgICAgdmVjOiB2ZWMyLmNsb25lKFswLCAwXSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb2ludE1hcCA9IHt9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgICAgICBhZGQocG9pbnQpO1xuICAgICAgICAgICAgdXBkYXRlQ2VudGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGQocG9pbnRUb0FkZCkge1xuICAgICAgICAgICAgcG9pbnRNYXBbcG9pbnRUb0FkZC5pZF0gPSBwb2ludFRvQWRkO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2gocG9pbnRUb0FkZCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVDZW50ZXIoKSB7XG4gICAgICAgICAgICB2YXIgaSwgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3VtICs9IHBvaW50c1tpXS5yYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZW50ZXIucmFkID0gc3VtIC8gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGNlbnRlci52ZWMgPSB2ZWMyLmNsb25lKFtNYXRoLmNvcyhjZW50ZXIucmFkKSwgTWF0aC5zaW4oY2VudGVyLnJhZCldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluaXQoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkOiBmdW5jdGlvbihwb2ludFRvQWRkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwb2ludE1hcFtwb2ludFRvQWRkLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICBhZGQocG9pbnRUb0FkZCk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNlbnRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXRzOiBmdW5jdGlvbihvdGhlclBvaW50KSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgY29zaW5lIHNpbWlsYXJpdHkgdG8gY2VudGVyLWFuZ2xlXG4gICAgICAgICAgICAgICAgdmFyIHNpbWlsYXJpdHkgPSBNYXRoLmFicyh2ZWMyLmRvdChvdGhlclBvaW50LnBvaW50LnZlYywgY2VudGVyLnZlYykpO1xuICAgICAgICAgICAgICAgIGlmIChzaW1pbGFyaXR5ID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UG9pbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldENlbnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNyZWF0ZVBvaW50OiBmdW5jdGlvbihuZXdQb2ludCwgaWQsIHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYWQ6IG5ld1BvaW50W3Byb3BlcnR5XSxcbiAgICAgICAgICAgIHBvaW50OiBuZXdQb2ludCxcbiAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICB9O1xuICAgIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tbW9uL2NsdXN0ZXIuanMiLCJleHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV2ZW50cyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZ2V0RXZlbnQoZXZlbnROYW1lKSB7XG4gICAgICAgIGlmICghZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgICAgIGV2ZW50c1tldmVudE5hbWVdID0ge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnRzW2V2ZW50TmFtZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJFdmVudHMoKXtcbiAgICAgICAgZXZlbnRzID0ge307XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVibGlzaFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24sIGRhdGEpIHtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5hc3luYykge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgICB9LCA0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5jYWxsYmFjayhkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1YnNjcmliZShldmVudCwgY2FsbGJhY2ssIGFzeW5jKSB7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb247XG5cbiAgICAgICAgaWYgKCB0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBhc3luYzogYXN5bmNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBjYWxsYmFjaztcbiAgICAgICAgICAgIGlmICghc3Vic2NyaXB0aW9uLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJDYWxsYmFjayB3YXMgbm90IHNwZWNpZmllZCBvbiBvcHRpb25zXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnZXRFdmVudChldmVudCkuc3Vic2NyaWJlcnMucHVzaChzdWJzY3JpcHRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrLCBhc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmliZShldmVudCwgY2FsbGJhY2ssIGFzeW5jKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHVibGlzaDogZnVuY3Rpb24oZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBnZXRFdmVudChldmVudE5hbWUpLFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzID0gZXZlbnQuc3Vic2NyaWJlcnM7XG5cbiAgICAgICAgICAgIC8vIFB1Ymxpc2ggb25lLXRpbWUgc3Vic2NyaXB0aW9uc1xuICAgICAgICAgICAgc3Vic2NyaWJlcnMuZmlsdGVyKGZ1bmN0aW9uKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFzdWJzY3JpYmVyLm9uY2U7XG4gICAgICAgICAgICB9KS5mb3JFYWNoKChzdWJzY3JpYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgcHVibGlzaFN1YnNjcmlwdGlvbihzdWJzY3JpYmVyLCBkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlbSBmcm9tIHRoZSBzdWJzY3JpYmVyXG4gICAgICAgICAgICBldmVudC5zdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzLmZpbHRlcihmdW5jdGlvbihzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFzdWJzY3JpYmVyLm9uY2U7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gcHVibGlzaCB0aGUgcmVzdFxuICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMuZm9yRWFjaCgoc3Vic2NyaWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIHB1Ymxpc2hTdWJzY3JpcHRpb24oc3Vic2NyaWJlciwgZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25jZTogZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrLCBhc3luYykge1xuICAgICAgICAgICAgc3Vic2NyaWJlKGV2ZW50LCB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGFzeW5jOiBhc3luYyxcbiAgICAgICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBldmVudDtcblxuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gZ2V0RXZlbnQoZXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQgJiYgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMgPSBldmVudC5zdWJzY3JpYmVycy5maWx0ZXIoZnVuY3Rpb24oc3Vic2NyaWJlcil7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlci5jYWxsYmFjayAhPT0gY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN1YnNjcmliZXJzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGVhckV2ZW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tbW9uL2V2ZW50cy5qcyIsIlxuZXhwb3J0IGZ1bmN0aW9uIGVudW1lcmF0ZURldmljZXMoKSB7XG4gICAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXNcbiAgICAgICAgICAgICYmIHR5cGVvZiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdlbnVtZXJhdGVEZXZpY2VzIGlzIG5vdCBkZWZpbmVkJykpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVzZXJNZWRpYShjb25zdHJhaW50cykge1xuICAgIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzXG4gICAgICAgICAgICAmJiB0eXBlb2YgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5tZWRpYURldmljZXNcbiAgICAgICAgICAgIC5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdnZXRVc2VyTWVkaWEgaXMgbm90IGRlZmluZWQnKSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tbW9uL21lZGlhRGV2aWNlcy5qcyIsIi8qKlxuICogQ29uc3RydWN0IHJlcHJlc2VudGluZyBhIHBhcnQgb2YgYW5vdGhlciB7SW1hZ2VXcmFwcGVyfS4gU2hhcmVzIGRhdGFcbiAqIGJldHdlZW4gdGhlIHBhcmVudCBhbmQgdGhlIGNoaWxkLlxuICogQHBhcmFtIGZyb20ge0ltYWdlUmVmfSBUaGUgcG9zaXRpb24gd2hlcmUgdG8gc3RhcnQgdGhlIHtTdWJJbWFnZX0gZnJvbS4gKHRvcC1sZWZ0IGNvcm5lcilcbiAqIEBwYXJhbSBzaXplIHtJbWFnZVJlZn0gVGhlIHNpemUgb2YgdGhlIHJlc3VsdGluZyBpbWFnZVxuICogQHBhcmFtIEkge0ltYWdlV3JhcHBlcn0gVGhlIHtJbWFnZVdyYXBwZXJ9IHRvIHNoYXJlIGZyb21cbiAqIEByZXR1cm5zIHtTdWJJbWFnZX0gQSBzaGFyZWQgcGFydCBvZiB0aGUgb3JpZ2luYWwgaW1hZ2VcbiAqL1xuZnVuY3Rpb24gU3ViSW1hZ2UoZnJvbSwgc2l6ZSwgSSkge1xuICAgIGlmICghSSkge1xuICAgICAgICBJID0ge1xuICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgIHNpemU6IHNpemVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5kYXRhID0gSS5kYXRhO1xuICAgIHRoaXMub3JpZ2luYWxTaXplID0gSS5zaXplO1xuICAgIHRoaXMuSSA9IEk7XG5cbiAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG59XG5cbi8qKlxuICogRGlzcGxheXMgdGhlIHtTdWJJbWFnZX0gaW4gYSBnaXZlbiBjYW52YXNcbiAqIEBwYXJhbSBjYW52YXMge0NhbnZhc30gVGhlIGNhbnZhcyBlbGVtZW50IHRvIHdyaXRlIHRvXG4gKiBAcGFyYW0gc2NhbGUge051bWJlcn0gU2NhbGUgd2hpY2ggaXMgYXBwbGllZCB0byBlYWNoIHBpeGVsLXZhbHVlXG4gKi9cblN1YkltYWdlLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oY2FudmFzLCBzY2FsZSkge1xuICAgIHZhciBjdHgsXG4gICAgICAgIGZyYW1lLFxuICAgICAgICBkYXRhLFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICB5LFxuICAgICAgICB4LFxuICAgICAgICBwaXhlbDtcblxuICAgIGlmICghc2NhbGUpIHtcbiAgICAgICAgc2NhbGUgPSAxLjA7XG4gICAgfVxuICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuc2l6ZS54O1xuICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLnNpemUueTtcbiAgICBmcmFtZSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBkYXRhID0gZnJhbWUuZGF0YTtcbiAgICBjdXJyZW50ID0gMDtcbiAgICBmb3IgKHkgPSAwOyB5IDwgdGhpcy5zaXplLnk7IHkrKykge1xuICAgICAgICBmb3IgKHggPSAwOyB4IDwgdGhpcy5zaXplLng7IHgrKykge1xuICAgICAgICAgICAgcGl4ZWwgPSB5ICogdGhpcy5zaXplLnggKyB4O1xuICAgICAgICAgICAgY3VycmVudCA9IHRoaXMuZ2V0KHgsIHkpICogc2NhbGU7XG4gICAgICAgICAgICBkYXRhW3BpeGVsICogNCArIDBdID0gY3VycmVudDtcbiAgICAgICAgICAgIGRhdGFbcGl4ZWwgKiA0ICsgMV0gPSBjdXJyZW50O1xuICAgICAgICAgICAgZGF0YVtwaXhlbCAqIDQgKyAyXSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBkYXRhW3BpeGVsICogNCArIDNdID0gMjU1O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZyYW1lLmRhdGEgPSBkYXRhO1xuICAgIGN0eC5wdXRJbWFnZURhdGEoZnJhbWUsIDAsIDApO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBnaXZlbiBwaXhlbCBwb3NpdGlvbiBmcm9tIHRoZSB7U3ViSW1hZ2V9XG4gKiBAcGFyYW0geCB7TnVtYmVyfSBUaGUgeC1wb3NpdGlvblxuICogQHBhcmFtIHkge051bWJlcn0gVGhlIHktcG9zaXRpb25cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBncmF5c2NhbGUgdmFsdWUgYXQgdGhlIHBpeGVsLXBvc2l0aW9uXG4gKi9cblN1YkltYWdlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVsodGhpcy5mcm9tLnkgKyB5KSAqIHRoaXMub3JpZ2luYWxTaXplLnggKyB0aGlzLmZyb20ueCArIHhdO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSB1bmRlcmx5aW5nIGRhdGEgZnJvbSBhIGdpdmVuIHtJbWFnZVdyYXBwZXJ9XG4gKiBAcGFyYW0gaW1hZ2Uge0ltYWdlV3JhcHBlcn0gVGhlIHVwZGF0ZWQgaW1hZ2VcbiAqL1xuU3ViSW1hZ2UucHJvdG90eXBlLnVwZGF0ZURhdGEgPSBmdW5jdGlvbihpbWFnZSkge1xuICAgIHRoaXMub3JpZ2luYWxTaXplID0gaW1hZ2Uuc2l6ZTtcbiAgICB0aGlzLmRhdGEgPSBpbWFnZS5kYXRhO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgc2hhcmVkIGFyZWFcbiAqIEBwYXJhbSBmcm9tIHt4LHl9IFRoZSBuZXcgbG9jYXRpb25cbiAqIEByZXR1cm5zIHtTdWJJbWFnZX0gcmV0dXJucyB7dGhpc30gZm9yIHBvc3NpYmxlIGNoYWluaW5nXG4gKi9cblN1YkltYWdlLnByb3RvdHlwZS51cGRhdGVGcm9tID0gZnVuY3Rpb24oZnJvbSkge1xuICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5leHBvcnQgZGVmYXVsdCAoU3ViSW1hZ2UpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbW1vbi9zdWJJbWFnZS5qcyIsIi8qXG4gKiB0eXBlZGVmcy5qc1xuICogTm9ybWFsaXplcyBicm93c2VyLXNwZWNpZmljIHByZWZpeGVzXG4gKi9cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LnJlcXVlc3RBbmltRnJhbWUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKC8qIGZ1bmN0aW9uIEZyYW1lUmVxdWVzdENhbGxiYWNrICovIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gICAgICAgICAgICB9O1xuICAgIH0pKCk7XG59XG5NYXRoLmltdWwgPSBNYXRoLmltdWwgfHwgZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBhaCA9IChhID4+PiAxNikgJiAweGZmZmYsXG4gICAgICAgIGFsID0gYSAmIDB4ZmZmZixcbiAgICAgICAgYmggPSAoYiA+Pj4gMTYpICYgMHhmZmZmLFxuICAgICAgICBibCA9IGIgJiAweGZmZmY7XG4gICAgLy8gdGhlIHNoaWZ0IGJ5IDAgZml4ZXMgdGhlIHNpZ24gb24gdGhlIGhpZ2ggcGFydFxuICAgIC8vIHRoZSBmaW5hbCB8MCBjb252ZXJ0cyB0aGUgdW5zaWduZWQgdmFsdWUgaW50byBhIHNpZ25lZCB2YWx1ZVxuICAgIHJldHVybiAoKGFsICogYmwpICsgKCgoYWggKiBibCArIGFsICogYmgpIDw8IDE2KSA+Pj4gMCkgfCAwKTtcbn07XG5cbmlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIE9iamVjdC5hc3NpZ24gPSBmdW5jdGlvbih0YXJnZXQpIHsgLy8gLmxlbmd0aCBvZiBmdW5jdGlvbiBpcyAyXG4gICAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gbnVsbCkgeyAvLyBUeXBlRXJyb3IgaWYgdW5kZWZpbmVkIG9yIG51bGxcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvID0gT2JqZWN0KHRhcmdldCk7XG5cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBuZXh0U291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcblxuICAgICAgICAgICAgaWYgKG5leHRTb3VyY2UgIT09IG51bGwpIHsgLy8gU2tpcCBvdmVyIGlmIHVuZGVmaW5lZCBvciBudWxsXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBuZXh0U291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEF2b2lkIGJ1Z3Mgd2hlbiBoYXNPd25Qcm9wZXJ0eSBpcyBzaGFkb3dlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5leHRTb3VyY2UsIG5leHRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tbW9uL3R5cGVkZWZzLmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaW5wdXRTdHJlYW06IHtcbiAgICAgICAgbmFtZTogXCJMaXZlXCIsXG4gICAgICAgIHR5cGU6IFwiTGl2ZVN0cmVhbVwiLFxuICAgICAgICBjb25zdHJhaW50czoge1xuICAgICAgICAgICAgd2lkdGg6IDY0MCxcbiAgICAgICAgICAgIGhlaWdodDogNDgwLFxuICAgICAgICAgICAgLy8gYXNwZWN0UmF0aW86IDY0MC80ODAsIC8vIG9wdGlvbmFsXG4gICAgICAgICAgICBmYWNpbmdNb2RlOiBcImVudmlyb25tZW50XCIsIC8vIG9yIHVzZXJcbiAgICAgICAgICAgIC8vIGRldmljZUlkOiBcIjM4NzQ1OTgzNDU3Mzg3NTk4Mzc1OTgzNzU5ODM0XCJcbiAgICAgICAgfSxcbiAgICAgICAgYXJlYToge1xuICAgICAgICAgICAgdG9wOiBcIjAlXCIsXG4gICAgICAgICAgICByaWdodDogXCIwJVwiLFxuICAgICAgICAgICAgbGVmdDogXCIwJVwiLFxuICAgICAgICAgICAgYm90dG9tOiBcIjAlXCJcbiAgICAgICAgfSxcbiAgICAgICAgc2luZ2xlQ2hhbm5lbDogZmFsc2UgLy8gdHJ1ZTogb25seSB0aGUgcmVkIGNvbG9yLWNoYW5uZWwgaXMgcmVhZFxuICAgIH0sXG4gICAgbG9jYXRlOiB0cnVlLFxuICAgIG51bU9mV29ya2VyczogMCxcbiAgICBkZWNvZGVyOiB7XG4gICAgICAgIHJlYWRlcnM6IFtcbiAgICAgICAgICAgICdjb2RlXzEyOF9yZWFkZXInXG4gICAgICAgIF0sXG4gICAgICAgIGRlYnVnOiB7XG4gICAgICAgICAgICBkcmF3Qm91bmRpbmdCb3g6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd0ZyZXF1ZW5jeTogZmFsc2UsXG4gICAgICAgICAgICBkcmF3U2NhbmxpbmU6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd1BhdHRlcm46IGZhbHNlXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGxvY2F0b3I6IHtcbiAgICAgICAgaGFsZlNhbXBsZTogdHJ1ZSxcbiAgICAgICAgcGF0Y2hTaXplOiBcIm1lZGl1bVwiLCAvLyB4LXNtYWxsLCBzbWFsbCwgbWVkaXVtLCBsYXJnZSwgeC1sYXJnZVxuICAgICAgICBkZWJ1Zzoge1xuICAgICAgICAgICAgc2hvd0NhbnZhczogZmFsc2UsXG4gICAgICAgICAgICBzaG93UGF0Y2hlczogZmFsc2UsXG4gICAgICAgICAgICBzaG93Rm91bmRQYXRjaGVzOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dTa2VsZXRvbjogZmFsc2UsXG4gICAgICAgICAgICBzaG93TGFiZWxzOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dQYXRjaExhYmVsczogZmFsc2UsXG4gICAgICAgICAgICBzaG93UmVtYWluaW5nUGF0Y2hMYWJlbHM6IGZhbHNlLFxuICAgICAgICAgICAgYm94RnJvbVBhdGNoZXM6IHtcbiAgICAgICAgICAgICAgICBzaG93VHJhbnNmb3JtZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dUcmFuc2Zvcm1lZEJveDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd0JCOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb25maWcvY29uZmlnLmRldi5qcyIsImxldCBjb25maWc7XG5cbmlmIChFTlYuZGV2ZWxvcG1lbnQpe1xuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnLmRldi5qcycpO1xufSBlbHNlIGlmIChFTlYubm9kZSkge1xuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnLm5vZGUuanMnKTtcbn0gZWxzZSB7XG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcucHJvZC5qcycpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb25maWc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29uZmlnL2NvbmZpZy5qcyIsImltcG9ydCBCcmVzZW5oYW0gZnJvbSAnLi9icmVzZW5oYW0nO1xuaW1wb3J0IEltYWdlRGVidWcgZnJvbSAnLi4vY29tbW9uL2ltYWdlX2RlYnVnJztcbmltcG9ydCBDb2RlMTI4UmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzEyOF9yZWFkZXInO1xuaW1wb3J0IEVBTlJlYWRlciBmcm9tICcuLi9yZWFkZXIvZWFuX3JlYWRlcic7XG5pbXBvcnQgQ29kZTM5UmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzM5X3JlYWRlcic7XG5pbXBvcnQgQ29kZTM5VklOUmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzM5X3Zpbl9yZWFkZXInO1xuaW1wb3J0IENvZGFiYXJSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGFiYXJfcmVhZGVyJztcbmltcG9ydCBVUENSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL3VwY19yZWFkZXInO1xuaW1wb3J0IEVBTjhSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2Vhbl84X3JlYWRlcic7XG5pbXBvcnQgRUFOMlJlYWRlciBmcm9tICcuLi9yZWFkZXIvZWFuXzJfcmVhZGVyJztcbmltcG9ydCBFQU41UmVhZGVyIGZyb20gJy4uL3JlYWRlci9lYW5fNV9yZWFkZXInO1xuaW1wb3J0IFVQQ0VSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL3VwY19lX3JlYWRlcic7XG5pbXBvcnQgSTJvZjVSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2kyb2Y1X3JlYWRlcic7XG5pbXBvcnQgVHdvT2ZGaXZlUmVhZGVyIGZyb20gJy4uL3JlYWRlci8yb2Y1X3JlYWRlcic7XG5pbXBvcnQgQ29kZTkzUmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzkzX3JlYWRlcic7XG5cbmNvbnN0IFJFQURFUlMgPSB7XG4gICAgY29kZV8xMjhfcmVhZGVyOiBDb2RlMTI4UmVhZGVyLFxuICAgIGVhbl9yZWFkZXI6IEVBTlJlYWRlcixcbiAgICBlYW5fNV9yZWFkZXI6IEVBTjVSZWFkZXIsXG4gICAgZWFuXzJfcmVhZGVyOiBFQU4yUmVhZGVyLFxuICAgIGVhbl84X3JlYWRlcjogRUFOOFJlYWRlcixcbiAgICBjb2RlXzM5X3JlYWRlcjogQ29kZTM5UmVhZGVyLFxuICAgIGNvZGVfMzlfdmluX3JlYWRlcjogQ29kZTM5VklOUmVhZGVyLFxuICAgIGNvZGFiYXJfcmVhZGVyOiBDb2RhYmFyUmVhZGVyLFxuICAgIHVwY19yZWFkZXI6IFVQQ1JlYWRlcixcbiAgICB1cGNfZV9yZWFkZXI6IFVQQ0VSZWFkZXIsXG4gICAgaTJvZjVfcmVhZGVyOiBJMm9mNVJlYWRlcixcbiAgICAnMm9mNV9yZWFkZXInOiBUd29PZkZpdmVSZWFkZXIsXG4gICAgY29kZV85M19yZWFkZXI6IENvZGU5M1JlYWRlclxufTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKGNvbmZpZywgaW5wdXRJbWFnZVdyYXBwZXIpIHtcbiAgICAgICAgdmFyIF9jYW52YXMgPSB7XG4gICAgICAgICAgICAgICAgY3R4OiB7XG4gICAgICAgICAgICAgICAgICAgIGZyZXF1ZW5jeTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheTogbnVsbFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZG9tOiB7XG4gICAgICAgICAgICAgICAgICAgIGZyZXF1ZW5jeTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheTogbnVsbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfYmFyY29kZVJlYWRlcnMgPSBbXTtcblxuICAgICAgICBpbml0Q2FudmFzKCk7XG4gICAgICAgIGluaXRSZWFkZXJzKCk7XG4gICAgICAgIGluaXRDb25maWcoKTtcblxuICAgICAgICBmdW5jdGlvbiBpbml0Q2FudmFzKCkge1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdmFyICRkZWJ1ZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZGVidWcuZGV0ZWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLmZyZXF1ZW5jeSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJjYW52YXMuZnJlcXVlbmN5XCIpO1xuICAgICAgICAgICAgICAgIGlmICghX2NhbnZhcy5kb20uZnJlcXVlbmN5KSB7XG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLmZyZXF1ZW5jeSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLmZyZXF1ZW5jeS5jbGFzc05hbWUgPSBcImZyZXF1ZW5jeVwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoJGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkZGVidWcuYXBwZW5kQ2hpbGQoX2NhbnZhcy5kb20uZnJlcXVlbmN5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfY2FudmFzLmN0eC5mcmVxdWVuY3kgPSBfY2FudmFzLmRvbS5mcmVxdWVuY3kuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4gICAgICAgICAgICAgICAgX2NhbnZhcy5kb20ucGF0dGVybiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJjYW52YXMucGF0dGVybkJ1ZmZlclwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIV9jYW52YXMuZG9tLnBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhbnZhcy5kb20ucGF0dGVybiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLnBhdHRlcm4uY2xhc3NOYW1lID0gXCJwYXR0ZXJuQnVmZmVyXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRkZWJ1Zy5hcHBlbmRDaGlsZChfY2FudmFzLmRvbS5wYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfY2FudmFzLmN0eC5wYXR0ZXJuID0gX2NhbnZhcy5kb20ucGF0dGVybi5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5vdmVybGF5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImNhbnZhcy5kcmF3aW5nQnVmZmVyXCIpO1xuICAgICAgICAgICAgICAgIGlmIChfY2FudmFzLmRvbS5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuY3R4Lm92ZXJsYXkgPSBfY2FudmFzLmRvbS5vdmVybGF5LmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbml0UmVhZGVycygpIHtcbiAgICAgICAgICAgIGNvbmZpZy5yZWFkZXJzLmZvckVhY2goZnVuY3Rpb24ocmVhZGVyQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlYWRlcixcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbiA9IHt9LFxuICAgICAgICAgICAgICAgICAgICBzdXBwbGVtZW50cyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZWFkZXJDb25maWcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IHJlYWRlckNvbmZpZy5mb3JtYXQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24gPSByZWFkZXJDb25maWcuY29uZmlnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlYWRlckNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gcmVhZGVyQ29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQmVmb3JlIHJlZ2lzdGVyaW5nIHJlYWRlcjogXCIsIHJlYWRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uLnN1cHBsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cHBsZW1lbnRzID0gY29uZmlndXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLnN1cHBsZW1lbnRzLm1hcCgoc3VwcGxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUkVBREVSU1tzdXBwbGVtZW50XSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9iYXJjb2RlUmVhZGVycy5wdXNoKG5ldyBSRUFERVJTW3JlYWRlcl0oY29uZmlndXJhdGlvbiwgc3VwcGxlbWVudHMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVnaXN0ZXJlZCBSZWFkZXJzOiBcIiArIF9iYXJjb2RlUmVhZGVyc1xuICAgICAgICAgICAgICAgICAgICAubWFwKChyZWFkZXIpID0+IEpTT04uc3RyaW5naWZ5KHtmb3JtYXQ6IHJlYWRlci5GT1JNQVQsIGNvbmZpZzogcmVhZGVyLmNvbmZpZ30pKVxuICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbml0Q29uZmlnKCkge1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgICAgIHZpcyA9IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlOiBfY2FudmFzLmRvbS5mcmVxdWVuY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wOiBjb25maWcuZGVidWcuc2hvd0ZyZXF1ZW5jeVxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlOiBfY2FudmFzLmRvbS5wYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcDogY29uZmlnLmRlYnVnLnNob3dQYXR0ZXJuXG4gICAgICAgICAgICAgICAgICAgIH1dO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlzW2ldLnByb3AgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc1tpXS5ub2RlLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNbaV0ubm9kZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogZXh0ZW5kIHRoZSBsaW5lIG9uIGJvdGggZW5kc1xuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBsaW5lXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZ2V0RXh0ZW5kZWRMaW5lKGxpbmUsIGFuZ2xlLCBleHQpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGV4dGVuZExpbmUoYW1vdW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4dGVuc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeTogYW1vdW50ICogTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgICAgICAgICAgICB4OiBhbW91bnQgKiBNYXRoLmNvcyhhbmdsZSlcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbGluZVswXS55IC09IGV4dGVuc2lvbi55O1xuICAgICAgICAgICAgICAgIGxpbmVbMF0ueCAtPSBleHRlbnNpb24ueDtcbiAgICAgICAgICAgICAgICBsaW5lWzFdLnkgKz0gZXh0ZW5zaW9uLnk7XG4gICAgICAgICAgICAgICAgbGluZVsxXS54ICs9IGV4dGVuc2lvbi54O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBpbnNpZGUgaW1hZ2VcbiAgICAgICAgICAgIGV4dGVuZExpbmUoZXh0KTtcbiAgICAgICAgICAgIHdoaWxlIChleHQgPiAxICYmICghaW5wdXRJbWFnZVdyYXBwZXIuaW5JbWFnZVdpdGhCb3JkZXIobGluZVswXSwgMClcbiAgICAgICAgICAgICAgICAgICAgfHwgIWlucHV0SW1hZ2VXcmFwcGVyLmluSW1hZ2VXaXRoQm9yZGVyKGxpbmVbMV0sIDApKSkge1xuICAgICAgICAgICAgICAgIGV4dCAtPSBNYXRoLmNlaWwoZXh0IC8gMik7XG4gICAgICAgICAgICAgICAgZXh0ZW5kTGluZSgtZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0TGluZShib3gpIHtcbiAgICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgIHg6IChib3hbMV1bMF0gLSBib3hbMF1bMF0pIC8gMiArIGJveFswXVswXSxcbiAgICAgICAgICAgICAgICB5OiAoYm94WzFdWzFdIC0gYm94WzBdWzFdKSAvIDIgKyBib3hbMF1bMV1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB4OiAoYm94WzNdWzBdIC0gYm94WzJdWzBdKSAvIDIgKyBib3hbMl1bMF0sXG4gICAgICAgICAgICAgICAgeTogKGJveFszXVsxXSAtIGJveFsyXVsxXSkgLyAyICsgYm94WzJdWzFdXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHRyeURlY29kZShsaW5lKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbCxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGJhcmNvZGVMaW5lID0gQnJlc2VuaGFtLmdldEJhcmNvZGVMaW5lKGlucHV0SW1hZ2VXcmFwcGVyLCBsaW5lWzBdLCBsaW5lWzFdKTtcblxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBjb25maWcuZGVidWcuc2hvd0ZyZXF1ZW5jeSkge1xuICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgobGluZSwge3g6ICd4JywgeTogJ3knfSwgX2NhbnZhcy5jdHgub3ZlcmxheSwge2NvbG9yOiAncmVkJywgbGluZVdpZHRoOiAzfSk7XG4gICAgICAgICAgICAgICAgQnJlc2VuaGFtLmRlYnVnLnByaW50RnJlcXVlbmN5KGJhcmNvZGVMaW5lLmxpbmUsIF9jYW52YXMuZG9tLmZyZXF1ZW5jeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEJyZXNlbmhhbS50b0JpbmFyeUxpbmUoYmFyY29kZUxpbmUpO1xuXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIGNvbmZpZy5kZWJ1Zy5zaG93UGF0dGVybikge1xuICAgICAgICAgICAgICAgIEJyZXNlbmhhbS5kZWJ1Zy5wcmludFBhdHRlcm4oYmFyY29kZUxpbmUubGluZSwgX2NhbnZhcy5kb20ucGF0dGVybik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgX2JhcmNvZGVSZWFkZXJzLmxlbmd0aCAmJiByZXN1bHQgPT09IG51bGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9iYXJjb2RlUmVhZGVyc1tpXS5kZWNvZGVQYXR0ZXJuKGJhcmNvZGVMaW5lLmxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvZGVSZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICBiYXJjb2RlTGluZTogYmFyY29kZUxpbmVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgc2xpY2VzIHRoZSBnaXZlbiBhcmVhIGFwYXJ0IGFuZCB0cmllcyB0byBkZXRlY3QgYSBiYXJjb2RlLXBhdHRlcm5cbiAgICAgICAgICogZm9yIGVhY2ggc2xpY2UuIEl0IHJldHVybnMgdGhlIGRlY29kZWQgYmFyY29kZSwgb3IgbnVsbCBpZiBub3RoaW5nIHdhcyBmb3VuZFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBib3hcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbGluZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUFuZ2xlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB0cnlEZWNvZGVCcnV0ZUZvcmNlKGJveCwgbGluZSwgbGluZUFuZ2xlKSB7XG4gICAgICAgICAgICB2YXIgc2lkZUxlbmd0aCA9IE1hdGguc3FydChNYXRoLnBvdyhib3hbMV1bMF0gLSBib3hbMF1bMF0sIDIpICsgTWF0aC5wb3coKGJveFsxXVsxXSAtIGJveFswXVsxXSksIDIpKSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIHNsaWNlcyA9IDE2LFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG51bGwsXG4gICAgICAgICAgICAgICAgZGlyLFxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgICAgICAgICB4ZGlyID0gTWF0aC5zaW4obGluZUFuZ2xlKSxcbiAgICAgICAgICAgICAgICB5ZGlyID0gTWF0aC5jb3MobGluZUFuZ2xlKTtcblxuICAgICAgICAgICAgZm9yICggaSA9IDE7IGkgPCBzbGljZXMgJiYgcmVzdWx0ID09PSBudWxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIGxpbmUgcGVycGVuZGljdWxhciB0byBhbmdsZVxuICAgICAgICAgICAgICAgIGRpciA9IHNpZGVMZW5ndGggLyBzbGljZXMgKiBpICogKGkgJSAyID09PSAwID8gLTEgOiAxKTtcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHk6IGRpciAqIHhkaXIsXG4gICAgICAgICAgICAgICAgICAgIHg6IGRpciAqIHlkaXJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGxpbmVbMF0ueSArPSBleHRlbnNpb24ueDtcbiAgICAgICAgICAgICAgICBsaW5lWzBdLnggLT0gZXh0ZW5zaW9uLnk7XG4gICAgICAgICAgICAgICAgbGluZVsxXS55ICs9IGV4dGVuc2lvbi54O1xuICAgICAgICAgICAgICAgIGxpbmVbMV0ueCAtPSBleHRlbnNpb24ueTtcblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRyeURlY29kZShsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRMaW5lTGVuZ3RoKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgICAgTWF0aC5wb3coTWF0aC5hYnMobGluZVsxXS55IC0gbGluZVswXS55KSwgMikgK1xuICAgICAgICAgICAgICAgIE1hdGgucG93KE1hdGguYWJzKGxpbmVbMV0ueCAtIGxpbmVbMF0ueCksIDIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaXRoIHRoZSBoZWxwIG9mIHRoZSBjb25maWd1cmVkIHJlYWRlcnMgKENvZGUxMjggb3IgRUFOKSB0aGlzIGZ1bmN0aW9uIHRyaWVzIHRvIGRldGVjdCBhXG4gICAgICAgICAqIHZhbGlkIGJhcmNvZGUgcGF0dGVybiB3aXRoaW4gdGhlIGdpdmVuIGFyZWEuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBib3ggVGhlIGFyZWEgdG8gc2VhcmNoIGluXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSByZXN1bHQge2NvZGVSZXN1bHQsIGxpbmUsIGFuZ2xlLCBwYXR0ZXJuLCB0aHJlc2hvbGR9XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBkZWNvZGVGcm9tQm91bmRpbmdCb3goYm94KSB7XG4gICAgICAgICAgICB2YXIgbGluZSxcbiAgICAgICAgICAgICAgICBsaW5lQW5nbGUsXG4gICAgICAgICAgICAgICAgY3R4ID0gX2NhbnZhcy5jdHgub3ZlcmxheSxcbiAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICAgbGluZUxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcuZGVidWcuZHJhd0JvdW5kaW5nQm94ICYmIGN0eCkge1xuICAgICAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGJveCwge3g6IDAsIHk6IDF9LCBjdHgsIHtjb2xvcjogXCJibHVlXCIsIGxpbmVXaWR0aDogMn0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGluZSA9IGdldExpbmUoYm94KTtcbiAgICAgICAgICAgIGxpbmVMZW5ndGggPSBnZXRMaW5lTGVuZ3RoKGxpbmUpO1xuICAgICAgICAgICAgbGluZUFuZ2xlID0gTWF0aC5hdGFuMihsaW5lWzFdLnkgLSBsaW5lWzBdLnksIGxpbmVbMV0ueCAtIGxpbmVbMF0ueCk7XG4gICAgICAgICAgICBsaW5lID0gZ2V0RXh0ZW5kZWRMaW5lKGxpbmUsIGxpbmVBbmdsZSwgTWF0aC5mbG9vcihsaW5lTGVuZ3RoICogMC4xKSk7XG4gICAgICAgICAgICBpZiAobGluZSA9PT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IHRyeURlY29kZShsaW5lKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnlEZWNvZGVCcnV0ZUZvcmNlKGJveCwgbGluZSwgbGluZUFuZ2xlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIHJlc3VsdCAmJiBjb25maWcuZGVidWcuZHJhd1NjYW5saW5lICYmIGN0eCkge1xuICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgobGluZSwge3g6ICd4JywgeTogJ3knfSwgY3R4LCB7Y29sb3I6ICdyZWQnLCBsaW5lV2lkdGg6IDN9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb2RlUmVzdWx0OiByZXN1bHQuY29kZVJlc3VsdCxcbiAgICAgICAgICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICAgICAgICAgIGFuZ2xlOiBsaW5lQW5nbGUsXG4gICAgICAgICAgICAgICAgcGF0dGVybjogcmVzdWx0LmJhcmNvZGVMaW5lLmxpbmUsXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkOiByZXN1bHQuYmFyY29kZUxpbmUudGhyZXNob2xkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlY29kZUZyb21Cb3VuZGluZ0JveDogZnVuY3Rpb24oYm94KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZUZyb21Cb3VuZGluZ0JveChib3gpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY29kZUZyb21Cb3VuZGluZ0JveGVzOiBmdW5jdGlvbihib3hlcykge1xuICAgICAgICAgICAgICAgIHZhciBpLCByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIGJhcmNvZGVzID0gW10sXG4gICAgICAgICAgICAgICAgICAgIG11bHRpcGxlID0gY29uZmlnLm11bHRpcGxlO1xuXG4gICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBib3ggPSBib3hlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVjb2RlRnJvbUJvdW5kaW5nQm94KGJveCkgfHwge307XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ib3ggPSBib3g7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXJjb2Rlcy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmNvZGVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhcmNvZGVzXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldFJlYWRlcnM6IGZ1bmN0aW9uKHJlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBjb25maWcucmVhZGVycyA9IHJlYWRlcnM7XG4gICAgICAgICAgICAgICAgX2JhcmNvZGVSZWFkZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgaW5pdFJlYWRlcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2RlY29kZXIvYmFyY29kZV9kZWNvZGVyLmpzIiwiaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tICcuLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XG5cbnZhciBCcmVzZW5oYW0gPSB7fTtcblxudmFyIFNsb3BlID0ge1xuICAgIERJUjoge1xuICAgICAgICBVUDogMSxcbiAgICAgICAgRE9XTjogLTFcbiAgICB9XG59O1xuLyoqXG4gKiBTY2FucyBhIGxpbmUgb2YgdGhlIGdpdmVuIGltYWdlIGZyb20gcG9pbnQgcDEgdG8gcDIgYW5kIHJldHVybnMgYSByZXN1bHQgb2JqZWN0IGNvbnRhaW5pbmdcbiAqIGdyYXktc2NhbGUgdmFsdWVzICgwLTI1NSkgb2YgdGhlIHVuZGVybHlpbmcgcGl4ZWxzIGluIGFkZGl0aW9uIHRvIHRoZSBtaW5cbiAqIGFuZCBtYXggdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IGltYWdlV3JhcHBlclxuICogQHBhcmFtIHtPYmplY3R9IHAxIFRoZSBzdGFydCBwb2ludCB7eCx5fVxuICogQHBhcmFtIHtPYmplY3R9IHAyIFRoZSBlbmQgcG9pbnQge3gseX1cbiAqIEByZXR1cm5zIHtsaW5lLCBtaW4sIG1heH1cbiAqL1xuQnJlc2VuaGFtLmdldEJhcmNvZGVMaW5lID0gZnVuY3Rpb24oaW1hZ2VXcmFwcGVyLCBwMSwgcDIpIHtcbiAgICB2YXIgeDAgPSBwMS54IHwgMCxcbiAgICAgICAgeTAgPSBwMS55IHwgMCxcbiAgICAgICAgeDEgPSBwMi54IHwgMCxcbiAgICAgICAgeTEgPSBwMi55IHwgMCxcbiAgICAgICAgc3RlZXAgPSBNYXRoLmFicyh5MSAtIHkwKSA+IE1hdGguYWJzKHgxIC0geDApLFxuICAgICAgICBkZWx0YXgsXG4gICAgICAgIGRlbHRheSxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHlzdGVwLFxuICAgICAgICB5LFxuICAgICAgICB0bXAsXG4gICAgICAgIHgsXG4gICAgICAgIGxpbmUgPSBbXSxcbiAgICAgICAgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGEsXG4gICAgICAgIHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueCxcbiAgICAgICAgc3VtID0gMCxcbiAgICAgICAgdmFsLFxuICAgICAgICBtaW4gPSAyNTUsXG4gICAgICAgIG1heCA9IDA7XG5cbiAgICBmdW5jdGlvbiByZWFkKGEsIGIpIHtcbiAgICAgICAgdmFsID0gaW1hZ2VEYXRhW2IgKiB3aWR0aCArIGFdO1xuICAgICAgICBzdW0gKz0gdmFsO1xuICAgICAgICBtaW4gPSB2YWwgPCBtaW4gPyB2YWwgOiBtaW47XG4gICAgICAgIG1heCA9IHZhbCA+IG1heCA/IHZhbCA6IG1heDtcbiAgICAgICAgbGluZS5wdXNoKHZhbCk7XG4gICAgfVxuXG4gICAgaWYgKHN0ZWVwKSB7XG4gICAgICAgIHRtcCA9IHgwO1xuICAgICAgICB4MCA9IHkwO1xuICAgICAgICB5MCA9IHRtcDtcblxuICAgICAgICB0bXAgPSB4MTtcbiAgICAgICAgeDEgPSB5MTtcbiAgICAgICAgeTEgPSB0bXA7XG4gICAgfVxuICAgIGlmICh4MCA+IHgxKSB7XG4gICAgICAgIHRtcCA9IHgwO1xuICAgICAgICB4MCA9IHgxO1xuICAgICAgICB4MSA9IHRtcDtcblxuICAgICAgICB0bXAgPSB5MDtcbiAgICAgICAgeTAgPSB5MTtcbiAgICAgICAgeTEgPSB0bXA7XG4gICAgfVxuICAgIGRlbHRheCA9IHgxIC0geDA7XG4gICAgZGVsdGF5ID0gTWF0aC5hYnMoeTEgLSB5MCk7XG4gICAgZXJyb3IgPSAoZGVsdGF4IC8gMikgfCAwO1xuICAgIHkgPSB5MDtcbiAgICB5c3RlcCA9IHkwIDwgeTEgPyAxIDogLTE7XG4gICAgZm9yICggeCA9IHgwOyB4IDwgeDE7IHgrKykge1xuICAgICAgICBpZiAoc3RlZXApe1xuICAgICAgICAgICAgcmVhZCh5LCB4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlYWQoeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IgPSBlcnJvciAtIGRlbHRheTtcbiAgICAgICAgaWYgKGVycm9yIDwgMCkge1xuICAgICAgICAgICAgeSA9IHkgKyB5c3RlcDtcbiAgICAgICAgICAgIGVycm9yID0gZXJyb3IgKyBkZWx0YXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICBtaW46IG1pbixcbiAgICAgICAgbWF4OiBtYXhcbiAgICB9O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgcmVzdWx0IGZyb20gZ2V0QmFyY29kZUxpbmUgaW50byBhIGJpbmFyeSByZXByZXNlbnRhdGlvblxuICogYWxzbyBjb25zaWRlcmluZyB0aGUgZnJlcXVlbmN5IGFuZCBzbG9wZSBvZiB0aGUgc2lnbmFsIGZvciBtb3JlIHJvYnVzdCByZXN1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0IHtsaW5lLCBtaW4sIG1heH1cbiAqL1xuQnJlc2VuaGFtLnRvQmluYXJ5TGluZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIHZhciBtaW4gPSByZXN1bHQubWluLFxuICAgICAgICBtYXggPSByZXN1bHQubWF4LFxuICAgICAgICBsaW5lID0gcmVzdWx0LmxpbmUsXG4gICAgICAgIHNsb3BlLFxuICAgICAgICBzbG9wZTIsXG4gICAgICAgIGNlbnRlciA9IG1pbiArIChtYXggLSBtaW4pIC8gMixcbiAgICAgICAgZXh0cmVtYSA9IFtdLFxuICAgICAgICBjdXJyZW50RGlyLFxuICAgICAgICBkaXIsXG4gICAgICAgIHRocmVzaG9sZCA9IChtYXggLSBtaW4pIC8gMTIsXG4gICAgICAgIHJUaHJlc2hvbGQgPSAtdGhyZXNob2xkLFxuICAgICAgICBpLFxuICAgICAgICBqO1xuXG4gICAgLy8gMS4gZmluZCBleHRyZW1hXG4gICAgY3VycmVudERpciA9IGxpbmVbMF0gPiBjZW50ZXIgPyBTbG9wZS5ESVIuVVAgOiBTbG9wZS5ESVIuRE9XTjtcbiAgICBleHRyZW1hLnB1c2goe1xuICAgICAgICBwb3M6IDAsXG4gICAgICAgIHZhbDogbGluZVswXVxuICAgIH0pO1xuICAgIGZvciAoIGkgPSAwOyBpIDwgbGluZS5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgc2xvcGUgPSAobGluZVtpICsgMV0gLSBsaW5lW2ldKTtcbiAgICAgICAgc2xvcGUyID0gKGxpbmVbaSArIDJdIC0gbGluZVtpICsgMV0pO1xuICAgICAgICBpZiAoKHNsb3BlICsgc2xvcGUyKSA8IHJUaHJlc2hvbGQgJiYgbGluZVtpICsgMV0gPCAoY2VudGVyICogMS41KSkge1xuICAgICAgICAgICAgZGlyID0gU2xvcGUuRElSLkRPV047XG4gICAgICAgIH0gZWxzZSBpZiAoKHNsb3BlICsgc2xvcGUyKSA+IHRocmVzaG9sZCAmJiBsaW5lW2kgKyAxXSA+IChjZW50ZXIgKiAwLjUpKSB7XG4gICAgICAgICAgICBkaXIgPSBTbG9wZS5ESVIuVVA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXIgPSBjdXJyZW50RGlyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnREaXIgIT09IGRpcikge1xuICAgICAgICAgICAgZXh0cmVtYS5wdXNoKHtcbiAgICAgICAgICAgICAgICBwb3M6IGksXG4gICAgICAgICAgICAgICAgdmFsOiBsaW5lW2ldXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN1cnJlbnREaXIgPSBkaXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXh0cmVtYS5wdXNoKHtcbiAgICAgICAgcG9zOiBsaW5lLmxlbmd0aCxcbiAgICAgICAgdmFsOiBsaW5lW2xpbmUubGVuZ3RoIC0gMV1cbiAgICB9KTtcblxuICAgIGZvciAoIGogPSBleHRyZW1hWzBdLnBvczsgaiA8IGV4dHJlbWFbMV0ucG9zOyBqKyspIHtcbiAgICAgICAgbGluZVtqXSA9IGxpbmVbal0gPiBjZW50ZXIgPyAwIDogMTtcbiAgICB9XG5cbiAgICAvLyBpdGVyYXRlIG92ZXIgZXh0cmVtYSBhbmQgY29udmVydCB0byBiaW5hcnkgYmFzZWQgb24gYXZnIGJldHdlZW4gbWlubWF4XG4gICAgZm9yICggaSA9IDE7IGkgPCBleHRyZW1hLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAoZXh0cmVtYVtpICsgMV0udmFsID4gZXh0cmVtYVtpXS52YWwpIHtcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IChleHRyZW1hW2ldLnZhbCArICgoZXh0cmVtYVtpICsgMV0udmFsIC0gZXh0cmVtYVtpXS52YWwpIC8gMykgKiAyKSB8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSAoZXh0cmVtYVtpICsgMV0udmFsICsgKChleHRyZW1hW2ldLnZhbCAtIGV4dHJlbWFbaSArIDFdLnZhbCkgLyAzKSkgfCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggaiA9IGV4dHJlbWFbaV0ucG9zOyBqIDwgZXh0cmVtYVtpICsgMV0ucG9zOyBqKyspIHtcbiAgICAgICAgICAgIGxpbmVbal0gPSBsaW5lW2pdID4gdGhyZXNob2xkID8gMCA6IDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICB0aHJlc2hvbGQ6IHRocmVzaG9sZFxuICAgIH07XG59O1xuXG4vKipcbiAqIFVzZWQgZm9yIGRldmVsb3BtZW50IG9ubHlcbiAqL1xuQnJlc2VuaGFtLmRlYnVnID0ge1xuICAgIHByaW50RnJlcXVlbmN5OiBmdW5jdGlvbihsaW5lLCBjYW52YXMpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICBjYW52YXMud2lkdGggPSBsaW5lLmxlbmd0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IDI1NjtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiYmx1ZVwiO1xuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oaSwgMjU1KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oaSwgMjU1IC0gbGluZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIHByaW50UGF0dGVybjogZnVuY3Rpb24obGluZSwgY2FudmFzKSB7XG4gICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLCBpO1xuXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGxpbmUubGVuZ3RoO1xuICAgICAgICBjdHguZmlsbENvbG9yID0gXCJibGFja1wiO1xuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsaW5lW2ldID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGksIDAsIDEsIDEwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBCcmVzZW5oYW07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZGVjb2Rlci9icmVzZW5oYW0uanMiLCJpbXBvcnQge29taXQsIHBpY2t9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQge2dldFVzZXJNZWRpYSwgZW51bWVyYXRlRGV2aWNlc30gZnJvbSAnbWVkaWFEZXZpY2VzJztcblxuY29uc3QgZmFjaW5nTWF0Y2hpbmcgPSB7XG4gICAgXCJ1c2VyXCI6IC9mcm9udC9pLFxuICAgIFwiZW52aXJvbm1lbnRcIjogL2JhY2svaVxufTtcblxudmFyIHN0cmVhbVJlZjtcblxuZnVuY3Rpb24gd2FpdEZvclZpZGVvKHZpZGVvKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbGV0IGF0dGVtcHRzID0gMTA7XG5cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tWaWRlbygpIHtcbiAgICAgICAgICAgIGlmIChhdHRlbXB0cyA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodmlkZW8udmlkZW9XaWR0aCA+IDEwICYmIHZpZGVvLnZpZGVvSGVpZ2h0ID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2codmlkZW8udmlkZW9XaWR0aCArIFwicHggeCBcIiArIHZpZGVvLnZpZGVvSGVpZ2h0ICsgXCJweFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2hlY2tWaWRlbywgNTAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdCgnVW5hYmxlIHRvIHBsYXkgdmlkZW8gc3RyZWFtLiBJcyB3ZWJjYW0gd29ya2luZz8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF0dGVtcHRzLS07XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tWaWRlbygpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFRyaWVzIHRvIGF0dGFjaCB0aGUgY2FtZXJhLXN0cmVhbSB0byBhIGdpdmVuIHZpZGVvLWVsZW1lbnRcbiAqIGFuZCBjYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiB0aGUgY29udGVudCBpcyByZWFkeVxuICogQHBhcmFtIHtPYmplY3R9IGNvbnN0cmFpbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gdmlkZW9cbiAqL1xuZnVuY3Rpb24gaW5pdENhbWVyYSh2aWRlbywgY29uc3RyYWludHMpIHtcbiAgICByZXR1cm4gZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKVxuICAgIC50aGVuKChzdHJlYW0pID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBzdHJlYW1SZWYgPSBzdHJlYW07XG4gICAgICAgICAgICB2aWRlby5zZXRBdHRyaWJ1dGUoXCJhdXRvcGxheVwiLCB0cnVlKTtcbiAgICAgICAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgnbXV0ZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgncGxheXNpbmxpbmUnLCB0cnVlKTtcbiAgICAgICAgICAgIHZpZGVvLnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgICAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZG1ldGFkYXRhJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZpZGVvLnBsYXkoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAudGhlbih3YWl0Rm9yVmlkZW8uYmluZChudWxsLCB2aWRlbykpO1xufVxuXG5mdW5jdGlvbiBkZXByZWNhdGVkQ29uc3RyYWludHModmlkZW9Db25zdHJhaW50cykge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBwaWNrKHZpZGVvQ29uc3RyYWludHMsIFtcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwiZmFjaW5nTW9kZVwiLFxuICAgICAgICAgICAgXCJhc3BlY3RSYXRpb1wiLCBcImRldmljZUlkXCJdKTtcblxuICAgIGlmICh0eXBlb2YgdmlkZW9Db25zdHJhaW50cy5taW5Bc3BlY3RSYXRpbyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIHZpZGVvQ29uc3RyYWludHMubWluQXNwZWN0UmF0aW8gPiAwKSB7XG4gICAgICAgIG5vcm1hbGl6ZWQuYXNwZWN0UmF0aW8gPSB2aWRlb0NvbnN0cmFpbnRzLm1pbkFzcGVjdFJhdGlvO1xuICAgICAgICBjb25zb2xlLmxvZyhcIldBUk5JTkc6IENvbnN0cmFpbnQgJ21pbkFzcGVjdFJhdGlvJyBpcyBkZXByZWNhdGVkOyBVc2UgJ2FzcGVjdFJhdGlvJyBpbnN0ZWFkXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZpZGVvQ29uc3RyYWludHMuZmFjaW5nICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBub3JtYWxpemVkLmZhY2luZ01vZGUgPSB2aWRlb0NvbnN0cmFpbnRzLmZhY2luZztcbiAgICAgICAgY29uc29sZS5sb2coXCJXQVJOSU5HOiBDb25zdHJhaW50ICdmYWNpbmcnIGlzIGRlcHJlY2F0ZWQuIFVzZSAnZmFjaW5nTW9kZScgaW5zdGVhZCdcIik7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGlja0NvbnN0cmFpbnRzKHZpZGVvQ29uc3RyYWludHMpIHtcbiAgICBjb25zdCBub3JtYWxpemVkQ29uc3RyYWludHMgPSB7XG4gICAgICAgIGF1ZGlvOiBmYWxzZSxcbiAgICAgICAgdmlkZW86IGRlcHJlY2F0ZWRDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzKVxuICAgIH07XG5cbiAgICBpZiAobm9ybWFsaXplZENvbnN0cmFpbnRzLnZpZGVvLmRldmljZUlkXG4gICAgICAgICAgICAmJiBub3JtYWxpemVkQ29uc3RyYWludHMudmlkZW8uZmFjaW5nTW9kZSkge1xuICAgICAgICBkZWxldGUgbm9ybWFsaXplZENvbnN0cmFpbnRzLnZpZGVvLmZhY2luZ01vZGU7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobm9ybWFsaXplZENvbnN0cmFpbnRzKTtcbn1cblxuZnVuY3Rpb24gZW51bWVyYXRlVmlkZW9EZXZpY2VzKCkge1xuICAgIHJldHVybiBlbnVtZXJhdGVEZXZpY2VzKClcbiAgICAudGhlbihkZXZpY2VzID0+IGRldmljZXMuZmlsdGVyKGRldmljZSA9PiBkZXZpY2Uua2luZCA9PT0gJ3ZpZGVvaW5wdXQnKSk7XG59XG5cbmZ1bmN0aW9uIGdldEFjdGl2ZVRyYWNrKCkge1xuICAgIGlmIChzdHJlYW1SZWYpIHtcbiAgICAgICAgY29uc3QgdHJhY2tzID0gc3RyZWFtUmVmLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgICAgIGlmICh0cmFja3MgJiYgdHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNrc1swXTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIHJlcXVlc3Q6IGZ1bmN0aW9uKHZpZGVvLCB2aWRlb0NvbnN0cmFpbnRzKSB7XG4gICAgICAgIHJldHVybiBwaWNrQ29uc3RyYWludHModmlkZW9Db25zdHJhaW50cylcbiAgICAgICAgICAgIC50aGVuKGluaXRDYW1lcmEuYmluZChudWxsLCB2aWRlbykpO1xuICAgIH0sXG4gICAgcmVsZWFzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0cmFja3MgPSBzdHJlYW1SZWYgJiYgc3RyZWFtUmVmLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgICAgIGlmICh0cmFja3MgJiYgdHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgdHJhY2tzWzBdLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW1SZWYgPSBudWxsO1xuICAgIH0sXG4gICAgZW51bWVyYXRlVmlkZW9EZXZpY2VzLFxuICAgIGdldEFjdGl2ZVN0cmVhbUxhYmVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSBnZXRBY3RpdmVUcmFjaygpO1xuICAgICAgICByZXR1cm4gdHJhY2sgPyB0cmFjay5sYWJlbCA6ICcnO1xuICAgIH0sXG4gICAgZ2V0QWN0aXZlVHJhY2tcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaW5wdXQvY2FtZXJhX2FjY2Vzcy5qcyIsIi8vIFNjcmFwZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXhpZi1qcy9leGlmLWpzXG5cbmNvbnN0IEV4aWZUYWdzID0gezB4MDExMjogXCJvcmllbnRhdGlvblwifTtcbmV4cG9ydCBjb25zdCBBdmFpbGFibGVUYWdzID0gT2JqZWN0LmtleXMoRXhpZlRhZ3MpLm1hcChrZXkgPT4gRXhpZlRhZ3Nba2V5XSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kVGFnc0luT2JqZWN0VVJMKHNyYywgdGFncyA9IEF2YWlsYWJsZVRhZ3MpIHtcbiAgICBpZiAoL15ibG9iXFw6L2kudGVzdChzcmMpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3RVUkxUb0Jsb2Ioc3JjKVxuICAgICAgICAgICAgLnRoZW4ocmVhZFRvQnVmZmVyKVxuICAgICAgICAgICAgLnRoZW4oYnVmZmVyID0+IGZpbmRUYWdzSW5CdWZmZXIoYnVmZmVyLCB0YWdzKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYXNlNjRUb0FycmF5QnVmZmVyKGRhdGFVcmwpIHtcbiAgICBjb25zdCBiYXNlNjQgPSBkYXRhVXJsLnJlcGxhY2UoL15kYXRhXFw6KFteXFw7XSspXFw7YmFzZTY0LC9nbWksICcnKSxcbiAgICAgICAgYmluYXJ5ID0gYXRvYihiYXNlNjQpLFxuICAgICAgICBsZW4gPSBiaW5hcnkubGVuZ3RoLFxuICAgICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIobGVuKSxcbiAgICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZpZXdbaV0gPSBiaW5hcnkuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gcmVhZFRvQnVmZmVyKGJsb2IpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG9iamVjdFVSTFRvQmxvYih1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBodHRwID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIGh0dHAub3BlbihcIkdFVFwiLCB1cmwsIHRydWUpO1xuICAgICAgICBodHRwLnJlc3BvbnNlVHlwZSA9IFwiYmxvYlwiO1xuICAgICAgICBodHRwLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChodHRwLnJlYWR5U3RhdGUgPT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUgJiYgKGh0dHAuc3RhdHVzID09PSAyMDAgfHwgaHR0cC5zdGF0dXMgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaHR0cC5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICBodHRwLnNlbmQoKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRUYWdzSW5CdWZmZXIoZmlsZSwgc2VsZWN0ZWRUYWdzID0gQXZhaWxhYmxlVGFncykge1xuICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGZpbGUpLFxuICAgICAgICBsZW5ndGggPSBmaWxlLmJ5dGVMZW5ndGgsXG4gICAgICAgIGV4aWZUYWdzID0gc2VsZWN0ZWRUYWdzLnJlZHVjZSgocmVzdWx0LCBzZWxlY3RlZFRhZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhpZlRhZyA9IE9iamVjdC5rZXlzKEV4aWZUYWdzKS5maWx0ZXIodGFnID0+IEV4aWZUYWdzW3RhZ10gPT09IHNlbGVjdGVkVGFnKVswXTtcbiAgICAgICAgICAgIGlmIChleGlmVGFnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2V4aWZUYWddID0gc2VsZWN0ZWRUYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LCB7fSk7XG4gICAgbGV0IG9mZnNldCA9IDIsXG4gICAgICAgIG1hcmtlcjtcblxuICAgIGlmICgoZGF0YVZpZXcuZ2V0VWludDgoMCkgIT09IDB4RkYpIHx8IChkYXRhVmlldy5nZXRVaW50OCgxKSAhPT0gMHhEOCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCkgIT09IDB4RkYpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcmtlciA9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIDEpO1xuICAgICAgICBpZiAobWFya2VyID09PSAweEUxKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZEVYSUZEYXRhKGRhdGFWaWV3LCBvZmZzZXQgKyA0LCBleGlmVGFncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMiArIGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQgKyAyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVhZEVYSUZEYXRhKGZpbGUsIHN0YXJ0LCBleGlmVGFncykge1xuICAgIGlmIChnZXRTdHJpbmdGcm9tQnVmZmVyKGZpbGUsIHN0YXJ0LCA0KSAhPT0gXCJFeGlmXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHRpZmZPZmZzZXQgPSBzdGFydCArIDY7XG4gICAgbGV0IGJpZ0VuZCxcbiAgICAgICAgdGFncztcblxuICAgIGlmIChmaWxlLmdldFVpbnQxNih0aWZmT2Zmc2V0KSA9PT0gMHg0OTQ5KSB7XG4gICAgICAgIGJpZ0VuZCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoZmlsZS5nZXRVaW50MTYodGlmZk9mZnNldCkgPT09IDB4NEQ0RCkge1xuICAgICAgICBiaWdFbmQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZmlsZS5nZXRVaW50MTYodGlmZk9mZnNldCArIDIsICFiaWdFbmQpICE9PSAweDAwMkEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGZpcnN0SUZET2Zmc2V0ID0gZmlsZS5nZXRVaW50MzIodGlmZk9mZnNldCArIDQsICFiaWdFbmQpO1xuICAgIGlmIChmaXJzdElGRE9mZnNldCA8IDB4MDAwMDAwMDgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRhZ3MgPSByZWFkVGFncyhmaWxlLCB0aWZmT2Zmc2V0LCB0aWZmT2Zmc2V0ICsgZmlyc3RJRkRPZmZzZXQsIGV4aWZUYWdzLCBiaWdFbmQpO1xuICAgIHJldHVybiB0YWdzO1xufVxuXG5mdW5jdGlvbiByZWFkVGFncyhmaWxlLCB0aWZmU3RhcnQsIGRpclN0YXJ0LCBzdHJpbmdzLCBiaWdFbmQpIHtcbiAgICBjb25zdCBlbnRyaWVzID0gZmlsZS5nZXRVaW50MTYoZGlyU3RhcnQsICFiaWdFbmQpLFxuICAgICAgICB0YWdzID0ge307XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVudHJpZXM7IGkrKykge1xuICAgICAgICBjb25zdCBlbnRyeU9mZnNldCA9IGRpclN0YXJ0ICsgaSAqIDEyICsgMixcbiAgICAgICAgICAgIHRhZyA9IHN0cmluZ3NbZmlsZS5nZXRVaW50MTYoZW50cnlPZmZzZXQsICFiaWdFbmQpXTtcbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgdGFnc1t0YWddID0gcmVhZFRhZ1ZhbHVlKGZpbGUsIGVudHJ5T2Zmc2V0LCB0aWZmU3RhcnQsIGRpclN0YXJ0LCBiaWdFbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWdzO1xufVxuXG5mdW5jdGlvbiByZWFkVGFnVmFsdWUoZmlsZSwgZW50cnlPZmZzZXQsIHRpZmZTdGFydCwgZGlyU3RhcnQsIGJpZ0VuZCkge1xuICAgIGNvbnN0IHR5cGUgPSBmaWxlLmdldFVpbnQxNihlbnRyeU9mZnNldCArIDIsICFiaWdFbmQpLFxuICAgICAgICBudW1WYWx1ZXMgPSBmaWxlLmdldFVpbnQzMihlbnRyeU9mZnNldCArIDQsICFiaWdFbmQpO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAzOlxuICAgICAgICBpZiAobnVtVmFsdWVzID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsZS5nZXRVaW50MTYoZW50cnlPZmZzZXQgKyA4LCAhYmlnRW5kKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0U3RyaW5nRnJvbUJ1ZmZlcihidWZmZXIsIHN0YXJ0LCBsZW5ndGgpIHtcbiAgICBsZXQgb3V0c3RyID0gXCJcIjtcbiAgICBmb3IgKGxldCBuID0gc3RhcnQ7IG4gPCBzdGFydCArIGxlbmd0aDsgbisrKSB7XG4gICAgICAgIG91dHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZlci5nZXRVaW50OChuKSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRzdHI7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaW5wdXQvZXhpZl9oZWxwZXIuanMiLCJpbXBvcnQge1xuICAgIGltYWdlUmVmLFxuICAgIGdyYXlBbmRIYWxmU2FtcGxlRnJvbUNhbnZhc0RhdGEsXG4gICAgY29tcHV0ZUdyYXlcbn0gZnJvbSAnLi4vY29tbW9uL2N2X3V0aWxzJztcblxuY29uc3QgVE9fUkFESUFOUyA9IE1hdGguUEkgLyAxODA7XG5cbmZ1bmN0aW9uIGFkanVzdENhbnZhc1NpemUoY2FudmFzLCB0YXJnZXRTaXplKSB7XG4gICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gdGFyZ2V0U2l6ZS54KSB7XG4gICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV0FSTklORzogY2FudmFzLXNpemUgbmVlZHMgdG8gYmUgYWRqdXN0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY2FudmFzLndpZHRoID0gdGFyZ2V0U2l6ZS54O1xuICAgIH1cbiAgICBpZiAoY2FudmFzLmhlaWdodCAhPT0gdGFyZ2V0U2l6ZS55KSB7XG4gICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV0FSTklORzogY2FudmFzLXNpemUgbmVlZHMgdG8gYmUgYWRqdXN0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRhcmdldFNpemUueTtcbiAgICB9XG59XG5cbnZhciBGcmFtZUdyYWJiZXIgPSB7fTtcblxuRnJhbWVHcmFiYmVyLmNyZWF0ZSA9IGZ1bmN0aW9uKGlucHV0U3RyZWFtLCBjYW52YXMpIHtcbiAgICB2YXIgX3RoYXQgPSB7fSxcbiAgICAgICAgX3N0cmVhbUNvbmZpZyA9IGlucHV0U3RyZWFtLmdldENvbmZpZygpLFxuICAgICAgICBfdmlkZW9fc2l6ZSA9IGltYWdlUmVmKGlucHV0U3RyZWFtLmdldFJlYWxXaWR0aCgpLCBpbnB1dFN0cmVhbS5nZXRSZWFsSGVpZ2h0KCkpLFxuICAgICAgICBfY2FudmFzU2l6ZSA9IGlucHV0U3RyZWFtLmdldENhbnZhc1NpemUoKSxcbiAgICAgICAgX3NpemUgPSBpbWFnZVJlZihpbnB1dFN0cmVhbS5nZXRXaWR0aCgpLCBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKSksXG4gICAgICAgIHRvcFJpZ2h0ID0gaW5wdXRTdHJlYW0uZ2V0VG9wUmlnaHQoKSxcbiAgICAgICAgX3N4ID0gdG9wUmlnaHQueCxcbiAgICAgICAgX3N5ID0gdG9wUmlnaHQueSxcbiAgICAgICAgX2NhbnZhcyxcbiAgICAgICAgX2N0eCA9IG51bGwsXG4gICAgICAgIF9kYXRhID0gbnVsbDtcblxuICAgIF9jYW52YXMgPSBjYW52YXMgPyBjYW52YXMgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIF9jYW52YXMud2lkdGggPSBfY2FudmFzU2l6ZS54O1xuICAgIF9jYW52YXMuaGVpZ2h0ID0gX2NhbnZhc1NpemUueTtcbiAgICBfY3R4ID0gX2NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgX2RhdGEgPSBuZXcgVWludDhBcnJheShfc2l6ZS54ICogX3NpemUueSk7XG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkZyYW1lR3JhYmJlclwiLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBzaXplOiBfc2l6ZSxcbiAgICAgICAgICAgIHRvcFJpZ2h0OiB0b3BSaWdodCxcbiAgICAgICAgICAgIHZpZGVvU2l6ZTogX3ZpZGVvX3NpemUsXG4gICAgICAgICAgICBjYW52YXNTaXplOiBfY2FudmFzU2l6ZVxuICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyB0aGUgZ2l2ZW4gYXJyYXkgYXMgZnJhbWUtYnVmZmVyXG4gICAgICovXG4gICAgX3RoYXQuYXR0YWNoRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgX2RhdGEgPSBkYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB1c2VkIGZyYW1lLWJ1ZmZlclxuICAgICAqL1xuICAgIF90aGF0LmdldERhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9kYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGEgZnJhbWUgZnJvbSB0aGUgaW5wdXQtc3RyZWFtIGFuZCBwdXRzIGludG8gdGhlIGZyYW1lLWJ1ZmZlci5cbiAgICAgKiBUaGUgaW1hZ2UtZGF0YSBpcyBjb252ZXJ0ZWQgdG8gZ3JheS1zY2FsZSBhbmQgdGhlbiBoYWxmLXNhbXBsZWQgaWYgY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBfdGhhdC5ncmFiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkb0hhbGZTYW1wbGUgPSBfc3RyZWFtQ29uZmlnLmhhbGZTYW1wbGUsXG4gICAgICAgICAgICBmcmFtZSA9IGlucHV0U3RyZWFtLmdldEZyYW1lKCksXG4gICAgICAgICAgICBkcmF3YWJsZSA9IGZyYW1lLFxuICAgICAgICAgICAgZHJhd0FuZ2xlID0gMCxcbiAgICAgICAgICAgIGN0eERhdGE7XG4gICAgICAgIGlmIChkcmF3YWJsZSkge1xuICAgICAgICAgICAgYWRqdXN0Q2FudmFzU2l6ZShfY2FudmFzLCBfY2FudmFzU2l6ZSk7XG4gICAgICAgICAgICBpZiAoX3N0cmVhbUNvbmZpZy50eXBlID09PSAnSW1hZ2VTdHJlYW0nKSB7XG4gICAgICAgICAgICAgICAgZHJhd2FibGUgPSBmcmFtZS5pbWc7XG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lLnRhZ3MgJiYgZnJhbWUudGFncy5vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGZyYW1lLnRhZ3Mub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0FuZ2xlID0gOTAgKiBUT19SQURJQU5TO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdBbmdsZSA9IC05MCAqIFRPX1JBRElBTlM7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRyYXdBbmdsZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIF9jdHgudHJhbnNsYXRlKF9jYW52YXNTaXplLnggLyAyLCBfY2FudmFzU2l6ZS55IC8gMik7XG4gICAgICAgICAgICAgICAgX2N0eC5yb3RhdGUoZHJhd0FuZ2xlKTtcbiAgICAgICAgICAgICAgICBfY3R4LmRyYXdJbWFnZShkcmF3YWJsZSwgLV9jYW52YXNTaXplLnkgLyAyLCAtX2NhbnZhc1NpemUueCAvIDIsIF9jYW52YXNTaXplLnksIF9jYW52YXNTaXplLngpO1xuICAgICAgICAgICAgICAgIF9jdHgucm90YXRlKC1kcmF3QW5nbGUpO1xuICAgICAgICAgICAgICAgIF9jdHgudHJhbnNsYXRlKC1fY2FudmFzU2l6ZS54IC8gMiwgLV9jYW52YXNTaXplLnkgLyAyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2N0eC5kcmF3SW1hZ2UoZHJhd2FibGUsIDAsIDAsIF9jYW52YXNTaXplLngsIF9jYW52YXNTaXplLnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHhEYXRhID0gX2N0eC5nZXRJbWFnZURhdGEoX3N4LCBfc3ksIF9zaXplLngsIF9zaXplLnkpLmRhdGE7XG4gICAgICAgICAgICBpZiAoZG9IYWxmU2FtcGxlKXtcbiAgICAgICAgICAgICAgICBncmF5QW5kSGFsZlNhbXBsZUZyb21DYW52YXNEYXRhKGN0eERhdGEsIF9zaXplLCBfZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVHcmF5KGN0eERhdGEsIF9kYXRhLCBfc3RyZWFtQ29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIF90aGF0LmdldFNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zaXplO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoYXQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBGcmFtZUdyYWJiZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaW5wdXQvZnJhbWVfZ3JhYmJlci5qcyIsImltcG9ydCB7ZmluZFRhZ3NJbk9iamVjdFVSTH0gZnJvbSAnLi9leGlmX2hlbHBlcic7XG5cbnZhciBJbWFnZUxvYWRlciA9IHt9O1xuSW1hZ2VMb2FkZXIubG9hZCA9IGZ1bmN0aW9uKGRpcmVjdG9yeSwgY2FsbGJhY2ssIG9mZnNldCwgc2l6ZSwgc2VxdWVuY2UpIHtcbiAgICB2YXIgaHRtbEltYWdlc1NyY0FycmF5ID0gbmV3IEFycmF5KHNpemUpLFxuICAgICAgICBodG1sSW1hZ2VzQXJyYXkgPSBuZXcgQXJyYXkoaHRtbEltYWdlc1NyY0FycmF5Lmxlbmd0aCksXG4gICAgICAgIGksXG4gICAgICAgIGltZyxcbiAgICAgICAgbnVtO1xuXG4gICAgaWYgKHNlcXVlbmNlID09PSBmYWxzZSkge1xuICAgICAgICBodG1sSW1hZ2VzU3JjQXJyYXlbMF0gPSBkaXJlY3Rvcnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBodG1sSW1hZ2VzU3JjQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG51bSA9IChvZmZzZXQgKyBpKTtcbiAgICAgICAgICAgIGh0bWxJbWFnZXNTcmNBcnJheVtpXSA9IGRpcmVjdG9yeSArIFwiaW1hZ2UtXCIgKyAoXCIwMFwiICsgbnVtKS5zbGljZSgtMykgKyBcIi5qcGdcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBodG1sSW1hZ2VzQXJyYXkubm90TG9hZGVkID0gW107XG4gICAgaHRtbEltYWdlc0FycmF5LmFkZEltYWdlID0gZnVuY3Rpb24oaW1hZ2UpIHtcbiAgICAgICAgaHRtbEltYWdlc0FycmF5Lm5vdExvYWRlZC5wdXNoKGltYWdlKTtcbiAgICB9O1xuICAgIGh0bWxJbWFnZXNBcnJheS5sb2FkZWQgPSBmdW5jdGlvbihsb2FkZWRJbWcpIHtcbiAgICAgICAgdmFyIG5vdGxvYWRlZEltZ3MgPSBodG1sSW1hZ2VzQXJyYXkubm90TG9hZGVkO1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IG5vdGxvYWRlZEltZ3MubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgIGlmIChub3Rsb2FkZWRJbWdzW3hdID09PSBsb2FkZWRJbWcpIHtcbiAgICAgICAgICAgICAgICBub3Rsb2FkZWRJbWdzLnNwbGljZSh4LCAxKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGh0bWxJbWFnZXNTcmNBcnJheS5sZW5ndGg7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW1nTmFtZSA9IGh0bWxJbWFnZXNTcmNBcnJheVt5XS5zdWJzdHIoaHRtbEltYWdlc1NyY0FycmF5W3ldLmxhc3RJbmRleE9mKFwiL1wiKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2FkZWRJbWcuc3JjLmxhc3RJbmRleE9mKGltZ05hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbEltYWdlc0FycmF5W3ldID0ge2ltZzogbG9hZGVkSW1nfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub3Rsb2FkZWRJbWdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSW1hZ2VzIGxvYWRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXF1ZW5jZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBmaW5kVGFnc0luT2JqZWN0VVJMKGRpcmVjdG9yeSwgWydvcmllbnRhdGlvbiddKVxuICAgICAgICAgICAgICAgICAgICAudGhlbih0YWdzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWxJbWFnZXNBcnJheVswXS50YWdzID0gdGFncztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGh0bWxJbWFnZXNBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhodG1sSW1hZ2VzQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soaHRtbEltYWdlc0FycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IGh0bWxJbWFnZXNTcmNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaHRtbEltYWdlc0FycmF5LmFkZEltYWdlKGltZyk7XG4gICAgICAgIGFkZE9ubG9hZEhhbmRsZXIoaW1nLCBodG1sSW1hZ2VzQXJyYXkpO1xuICAgICAgICBpbWcuc3JjID0gaHRtbEltYWdlc1NyY0FycmF5W2ldO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGFkZE9ubG9hZEhhbmRsZXIoaW1nLCBodG1sSW1hZ2VzQXJyYXkpIHtcbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGh0bWxJbWFnZXNBcnJheS5sb2FkZWQodGhpcyk7XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgKEltYWdlTG9hZGVyKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbnB1dC9pbWFnZV9sb2FkZXIuanMiLCJpbXBvcnQgSW1hZ2VMb2FkZXIgZnJvbSAnLi9pbWFnZV9sb2FkZXInO1xuXG52YXIgSW5wdXRTdHJlYW0gPSB7fTtcbklucHV0U3RyZWFtLmNyZWF0ZVZpZGVvU3RyZWFtID0gZnVuY3Rpb24odmlkZW8pIHtcbiAgICB2YXIgdGhhdCA9IHt9LFxuICAgICAgICBfY29uZmlnID0gbnVsbCxcbiAgICAgICAgX2V2ZW50TmFtZXMgPSBbJ2NhbnJlY29yZCcsICdlbmRlZCddLFxuICAgICAgICBfZXZlbnRIYW5kbGVycyA9IHt9LFxuICAgICAgICBfY2FsY3VsYXRlZFdpZHRoLFxuICAgICAgICBfY2FsY3VsYXRlZEhlaWdodCxcbiAgICAgICAgX3RvcFJpZ2h0ID0ge3g6IDAsIHk6IDB9LFxuICAgICAgICBfY2FudmFzU2l6ZSA9IHt4OiAwLCB5OiAwfTtcblxuICAgIGZ1bmN0aW9uIGluaXRTaXplKCkge1xuICAgICAgICB2YXIgd2lkdGggPSB2aWRlby52aWRlb1dpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gdmlkZW8udmlkZW9IZWlnaHQ7XG5cbiAgICAgICAgX2NhbGN1bGF0ZWRXaWR0aCA9XG4gICAgICAgICAgICBfY29uZmlnLnNpemUgPyB3aWR0aCAvIGhlaWdodCA+IDEgPyBfY29uZmlnLnNpemUgOiBNYXRoLmZsb29yKCh3aWR0aCAvIGhlaWdodCkgKiBfY29uZmlnLnNpemUpIDogd2lkdGg7XG4gICAgICAgIF9jYWxjdWxhdGVkSGVpZ2h0ID1cbiAgICAgICAgICAgIF9jb25maWcuc2l6ZSA/IHdpZHRoIC8gaGVpZ2h0ID4gMSA/IE1hdGguZmxvb3IoKGhlaWdodCAvIHdpZHRoKSAqIF9jb25maWcuc2l6ZSkgOiBfY29uZmlnLnNpemUgOiBoZWlnaHQ7XG5cbiAgICAgICAgX2NhbnZhc1NpemUueCA9IF9jYWxjdWxhdGVkV2lkdGg7XG4gICAgICAgIF9jYW52YXNTaXplLnkgPSBfY2FsY3VsYXRlZEhlaWdodDtcbiAgICB9XG5cbiAgICB0aGF0LmdldFJlYWxXaWR0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmlkZW8udmlkZW9XaWR0aDtcbiAgICB9O1xuXG4gICAgdGhhdC5nZXRSZWFsSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2aWRlby52aWRlb0hlaWdodDtcbiAgICB9O1xuXG4gICAgdGhhdC5nZXRXaWR0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2NhbGN1bGF0ZWRXaWR0aDtcbiAgICB9O1xuXG4gICAgdGhhdC5nZXRIZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9jYWxjdWxhdGVkSGVpZ2h0O1xuICAgIH07XG5cbiAgICB0aGF0LnNldFdpZHRoID0gZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgICAgX2NhbGN1bGF0ZWRXaWR0aCA9IHdpZHRoO1xuICAgIH07XG5cbiAgICB0aGF0LnNldEhlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgICBfY2FsY3VsYXRlZEhlaWdodCA9IGhlaWdodDtcbiAgICB9O1xuXG4gICAgdGhhdC5zZXRJbnB1dFN0cmVhbSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICBfY29uZmlnID0gY29uZmlnO1xuICAgICAgICB2aWRlby5zcmMgPSAodHlwZW9mIGNvbmZpZy5zcmMgIT09ICd1bmRlZmluZWQnKSA/IGNvbmZpZy5zcmMgOiAnJztcbiAgICB9O1xuXG4gICAgdGhhdC5lbmRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmlkZW8uZW5kZWQ7XG4gICAgfTtcblxuICAgIHRoYXQuZ2V0Q29uZmlnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfY29uZmlnO1xuICAgIH07XG5cbiAgICB0aGF0LnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIHRoYXQucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmlkZW8ucGF1c2UoKTtcbiAgICB9O1xuXG4gICAgdGhhdC5wbGF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZpZGVvLnBsYXkoKTtcbiAgICB9O1xuXG4gICAgdGhhdC5zZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgICAgaWYgKF9jb25maWcudHlwZSAhPT0gXCJMaXZlU3RyZWFtXCIpIHtcbiAgICAgICAgICAgIHZpZGVvLmN1cnJlbnRUaW1lID0gdGltZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGF0LmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZiwgYm9vbCkge1xuICAgICAgICBpZiAoX2V2ZW50TmFtZXMuaW5kZXhPZihldmVudCkgIT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoIV9ldmVudEhhbmRsZXJzW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2V2ZW50SGFuZGxlcnNbZXZlbnRdLnB1c2goZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aWRlby5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmLCBib29sKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGF0LmNsZWFyRXZlbnRIYW5kbGVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBfZXZlbnROYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXJzID0gX2V2ZW50SGFuZGxlcnNbZXZlbnROYW1lXTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZGVvLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoYXQudHJpZ2dlciA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgYXJncykge1xuICAgICAgICB2YXIgaixcbiAgICAgICAgICAgIGhhbmRsZXJzID0gX2V2ZW50SGFuZGxlcnNbZXZlbnROYW1lXTtcblxuICAgICAgICBpZiAoZXZlbnROYW1lID09PSAnY2FucmVjb3JkJykge1xuICAgICAgICAgICAgaW5pdFNpemUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFuZGxlcnMgJiYgaGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yICggaiA9IDA7IGogPCBoYW5kbGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzW2pdLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoYXQuc2V0VG9wUmlnaHQgPSBmdW5jdGlvbih0b3BSaWdodCkge1xuICAgICAgICBfdG9wUmlnaHQueCA9IHRvcFJpZ2h0Lng7XG4gICAgICAgIF90b3BSaWdodC55ID0gdG9wUmlnaHQueTtcbiAgICB9O1xuXG4gICAgdGhhdC5nZXRUb3BSaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3RvcFJpZ2h0O1xuICAgIH07XG5cbiAgICB0aGF0LnNldENhbnZhc1NpemUgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIF9jYW52YXNTaXplLnggPSBzaXplLng7XG4gICAgICAgIF9jYW52YXNTaXplLnkgPSBzaXplLnk7XG4gICAgfTtcblxuICAgIHRoYXQuZ2V0Q2FudmFzU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2NhbnZhc1NpemU7XG4gICAgfTtcblxuICAgIHRoYXQuZ2V0RnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZpZGVvO1xuICAgIH07XG5cbiAgICByZXR1cm4gdGhhdDtcbn07XG5cbklucHV0U3RyZWFtLmNyZWF0ZUxpdmVTdHJlYW0gPSBmdW5jdGlvbih2aWRlbykge1xuICAgIHZpZGVvLnNldEF0dHJpYnV0ZShcImF1dG9wbGF5XCIsIHRydWUpO1xuICAgIHZhciB0aGF0ID0gSW5wdXRTdHJlYW0uY3JlYXRlVmlkZW9TdHJlYW0odmlkZW8pO1xuXG4gICAgdGhhdC5lbmRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHJldHVybiB0aGF0O1xufTtcblxuSW5wdXRTdHJlYW0uY3JlYXRlSW1hZ2VTdHJlYW0gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHt9O1xuICAgIHZhciBfY29uZmlnID0gbnVsbDtcblxuICAgIHZhciB3aWR0aCA9IDAsXG4gICAgICAgIGhlaWdodCA9IDAsXG4gICAgICAgIGZyYW1lSWR4ID0gMCxcbiAgICAgICAgcGF1c2VkID0gdHJ1ZSxcbiAgICAgICAgbG9hZGVkID0gZmFsc2UsXG4gICAgICAgIGltZ0FycmF5ID0gbnVsbCxcbiAgICAgICAgc2l6ZSA9IDAsXG4gICAgICAgIG9mZnNldCA9IDEsXG4gICAgICAgIGJhc2VVcmwgPSBudWxsLFxuICAgICAgICBlbmRlZCA9IGZhbHNlLFxuICAgICAgICBjYWxjdWxhdGVkV2lkdGgsXG4gICAgICAgIGNhbGN1bGF0ZWRIZWlnaHQsXG4gICAgICAgIF9ldmVudE5hbWVzID0gWydjYW5yZWNvcmQnLCAnZW5kZWQnXSxcbiAgICAgICAgX2V2ZW50SGFuZGxlcnMgPSB7fSxcbiAgICAgICAgX3RvcFJpZ2h0ID0ge3g6IDAsIHk6IDB9LFxuICAgICAgICBfY2FudmFzU2l6ZSA9IHt4OiAwLCB5OiAwfTtcblxuICAgIGZ1bmN0aW9uIGxvYWRJbWFnZXMoKSB7XG4gICAgICAgIGxvYWRlZCA9IGZhbHNlO1xuICAgICAgICBJbWFnZUxvYWRlci5sb2FkKGJhc2VVcmwsIGZ1bmN0aW9uKGltZ3MpIHtcbiAgICAgICAgICAgIGltZ0FycmF5ID0gaW1ncztcbiAgICAgICAgICAgIGlmIChpbWdzWzBdLnRhZ3MgJiYgaW1nc1swXS50YWdzLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChpbWdzWzBdLnRhZ3Mub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGltZ3NbMF0uaW1nLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gaW1nc1swXS5pbWcud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gaW1nc1swXS5pbWcud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGltZ3NbMF0uaW1nLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdpZHRoID0gaW1nc1swXS5pbWcud2lkdGg7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gaW1nc1swXS5pbWcuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsY3VsYXRlZFdpZHRoID1cbiAgICAgICAgICAgICAgICBfY29uZmlnLnNpemUgPyB3aWR0aCAvIGhlaWdodCA+IDEgPyBfY29uZmlnLnNpemUgOiBNYXRoLmZsb29yKCh3aWR0aCAvIGhlaWdodCkgKiBfY29uZmlnLnNpemUpIDogd2lkdGg7XG4gICAgICAgICAgICBjYWxjdWxhdGVkSGVpZ2h0ID1cbiAgICAgICAgICAgICAgICBfY29uZmlnLnNpemUgPyB3aWR0aCAvIGhlaWdodCA+IDEgPyBNYXRoLmZsb29yKChoZWlnaHQgLyB3aWR0aCkgKiBfY29uZmlnLnNpemUpIDogX2NvbmZpZy5zaXplIDogaGVpZ2h0O1xuICAgICAgICAgICAgX2NhbnZhc1NpemUueCA9IGNhbGN1bGF0ZWRXaWR0aDtcbiAgICAgICAgICAgIF9jYW52YXNTaXplLnkgPSBjYWxjdWxhdGVkSGVpZ2h0O1xuICAgICAgICAgICAgbG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZyYW1lSWR4ID0gMDtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcHVibGlzaEV2ZW50KFwiY2FucmVjb3JkXCIsIFtdKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9LCBvZmZzZXQsIHNpemUsIF9jb25maWcuc2VxdWVuY2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1Ymxpc2hFdmVudChldmVudE5hbWUsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGosXG4gICAgICAgICAgICBoYW5kbGVycyA9IF9ldmVudEhhbmRsZXJzW2V2ZW50TmFtZV07XG5cbiAgICAgICAgaWYgKGhhbmRsZXJzICYmIGhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAoIGogPSAwOyBqIDwgaGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyc1tqXS5hcHBseSh0aGF0LCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgdGhhdC50cmlnZ2VyID0gcHVibGlzaEV2ZW50O1xuXG4gICAgdGhhdC5nZXRXaWR0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY2FsY3VsYXRlZFdpZHRoO1xuICAgIH07XG5cbiAgICB0aGF0LmdldEhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY2FsY3VsYXRlZEhlaWdodDtcbiAgICB9O1xuXG4gICAgdGhhdC5zZXRXaWR0aCA9IGZ1bmN0aW9uKG5ld1dpZHRoKSB7XG4gICAgICAgIGNhbGN1bGF0ZWRXaWR0aCA9IG5ld1dpZHRoO1xuICAgIH07XG5cbiAgICB0aGF0LnNldEhlaWdodCA9IGZ1bmN0aW9uKG5ld0hlaWdodCkge1xuICAgICAgICBjYWxjdWxhdGVkSGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgIH07XG5cbiAgICB0aGF0LmdldFJlYWxXaWR0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgfTtcblxuICAgIHRoYXQuZ2V0UmVhbEhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH07XG5cbiAgICB0aGF0LnNldElucHV0U3RyZWFtID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgIF9jb25maWcgPSBzdHJlYW07XG4gICAgICAgIGlmIChzdHJlYW0uc2VxdWVuY2UgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBiYXNlVXJsID0gc3RyZWFtLnNyYztcbiAgICAgICAgICAgIHNpemUgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFzZVVybCA9IHN0cmVhbS5zcmM7XG4gICAgICAgICAgICBzaXplID0gc3RyZWFtLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBsb2FkSW1hZ2VzKCk7XG4gICAgfTtcblxuICAgIHRoYXQuZW5kZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGVuZGVkO1xuICAgIH07XG5cbiAgICB0aGF0LnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCkge307XG5cbiAgICB0aGF0LmdldENvbmZpZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2NvbmZpZztcbiAgICB9O1xuXG4gICAgdGhhdC5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBwYXVzZWQgPSB0cnVlO1xuICAgIH07XG5cbiAgICB0aGF0LnBsYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHRoYXQuc2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbih0aW1lKSB7XG4gICAgICAgIGZyYW1lSWR4ID0gdGltZTtcbiAgICB9O1xuXG4gICAgdGhhdC5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGYpIHtcbiAgICAgICAgaWYgKF9ldmVudE5hbWVzLmluZGV4T2YoZXZlbnQpICE9PSAtMSkge1xuICAgICAgICAgICAgaWYgKCFfZXZlbnRIYW5kbGVyc1tldmVudF0pIHtcbiAgICAgICAgICAgICAgICBfZXZlbnRIYW5kbGVyc1tldmVudF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XS5wdXNoKGYpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoYXQuc2V0VG9wUmlnaHQgPSBmdW5jdGlvbih0b3BSaWdodCkge1xuICAgICAgICBfdG9wUmlnaHQueCA9IHRvcFJpZ2h0Lng7XG4gICAgICAgIF90b3BSaWdodC55ID0gdG9wUmlnaHQueTtcbiAgICB9O1xuXG4gICAgdGhhdC5nZXRUb3BSaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3RvcFJpZ2h0O1xuICAgIH07XG5cbiAgICB0aGF0LnNldENhbnZhc1NpemUgPSBmdW5jdGlvbihjYW52YXNTaXplKSB7XG4gICAgICAgIF9jYW52YXNTaXplLnggPSBjYW52YXNTaXplLng7XG4gICAgICAgIF9jYW52YXNTaXplLnkgPSBjYW52YXNTaXplLnk7XG4gICAgfTtcblxuICAgIHRoYXQuZ2V0Q2FudmFzU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2NhbnZhc1NpemU7XG4gICAgfTtcblxuICAgIHRoYXQuZ2V0RnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZyYW1lO1xuXG4gICAgICAgIGlmICghbG9hZGVkKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGF1c2VkKSB7XG4gICAgICAgICAgICBmcmFtZSA9IGltZ0FycmF5W2ZyYW1lSWR4XTtcbiAgICAgICAgICAgIGlmIChmcmFtZUlkeCA8IChzaXplIC0gMSkpIHtcbiAgICAgICAgICAgICAgICBmcmFtZUlkeCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHB1Ymxpc2hFdmVudChcImVuZGVkXCIsIFtdKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgfTtcblxuICAgIHJldHVybiB0aGF0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgSW5wdXRTdHJlYW07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaW5wdXQvaW5wdXRfc3RyZWFtLmpzIiwiaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tICcuLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XG5pbXBvcnQge1xuICAgIGNhbGN1bGF0ZVBhdGNoU2l6ZSxcbiAgICBvdHN1VGhyZXNob2xkLFxuICAgIGhzdjJyZ2IsXG4gICAgY2x1c3RlcixcbiAgICB0b3BHZW5lcmljLFxuICAgIGltYWdlUmVmLFxuICAgIGhhbGZTYW1wbGUsXG4gICAgY29tcHV0ZUltYWdlQXJlYVxufSBmcm9tICcuLi9jb21tb24vY3ZfdXRpbHMnO1xuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4uL2NvbW1vbi9hcnJheV9oZWxwZXInO1xuaW1wb3J0IEltYWdlRGVidWcgZnJvbSAnLi4vY29tbW9uL2ltYWdlX2RlYnVnJztcbmltcG9ydCBSYXN0ZXJpemVyIGZyb20gJy4vcmFzdGVyaXplcic7XG5pbXBvcnQgVHJhY2VyIGZyb20gJy4vdHJhY2VyJztcbmltcG9ydCBza2VsZXRvbml6ZXIgZnJvbSAnLi9za2VsZXRvbml6ZXInO1xuY29uc3QgdmVjMiA9IHtcbiAgICBjbG9uZTogcmVxdWlyZSgnZ2wtdmVjMi9jbG9uZScpLFxuICAgIGRvdDogIHJlcXVpcmUoJ2dsLXZlYzIvZG90JyksXG4gICAgc2NhbGU6IHJlcXVpcmUoJ2dsLXZlYzIvc2NhbGUnKSxcbiAgICB0cmFuc2Zvcm1NYXQyOiByZXF1aXJlKCdnbC12ZWMyL3RyYW5zZm9ybU1hdDInKVxufTtcbmNvbnN0IG1hdDIgPSB7XG4gICAgY29weTogcmVxdWlyZSgnZ2wtbWF0Mi9jb3B5JyksXG4gICAgY3JlYXRlOiByZXF1aXJlKCdnbC1tYXQyL2NyZWF0ZScpLFxuICAgIGludmVydDogcmVxdWlyZSgnZ2wtbWF0Mi9pbnZlcnQnKVxufVxuXG52YXIgX2NvbmZpZyxcbiAgICBfY3VycmVudEltYWdlV3JhcHBlcixcbiAgICBfc2tlbEltYWdlV3JhcHBlcixcbiAgICBfc3ViSW1hZ2VXcmFwcGVyLFxuICAgIF9sYWJlbEltYWdlV3JhcHBlcixcbiAgICBfcGF0Y2hHcmlkLFxuICAgIF9wYXRjaExhYmVsR3JpZCxcbiAgICBfaW1hZ2VUb1BhdGNoR3JpZCxcbiAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyLFxuICAgIF9wYXRjaFNpemUsXG4gICAgX2NhbnZhc0NvbnRhaW5lciA9IHtcbiAgICAgICAgY3R4OiB7XG4gICAgICAgICAgICBiaW5hcnk6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgZG9tOiB7XG4gICAgICAgICAgICBiaW5hcnk6IG51bGxcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX251bVBhdGNoZXMgPSB7eDogMCwgeTogMH0sXG4gICAgX2lucHV0SW1hZ2VXcmFwcGVyLFxuICAgIF9za2VsZXRvbml6ZXI7XG5cbmZ1bmN0aW9uIGluaXRCdWZmZXJzKCkge1xuICAgIHZhciBza2VsZXRvbkltYWdlRGF0YTtcblxuICAgIGlmIChfY29uZmlnLmhhbGZTYW1wbGUpIHtcbiAgICAgICAgX2N1cnJlbnRJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKHtcbiAgICAgICAgICAgIHg6IF9pbnB1dEltYWdlV3JhcHBlci5zaXplLnggLyAyIHwgMCxcbiAgICAgICAgICAgIHk6IF9pbnB1dEltYWdlV3JhcHBlci5zaXplLnkgLyAyIHwgMFxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBfY3VycmVudEltYWdlV3JhcHBlciA9IF9pbnB1dEltYWdlV3JhcHBlcjtcbiAgICB9XG5cbiAgICBfcGF0Y2hTaXplID0gY2FsY3VsYXRlUGF0Y2hTaXplKF9jb25maWcucGF0Y2hTaXplLCBfY3VycmVudEltYWdlV3JhcHBlci5zaXplKTtcblxuICAgIF9udW1QYXRjaGVzLnggPSBfY3VycmVudEltYWdlV3JhcHBlci5zaXplLnggLyBfcGF0Y2hTaXplLnggfCAwO1xuICAgIF9udW1QYXRjaGVzLnkgPSBfY3VycmVudEltYWdlV3JhcHBlci5zaXplLnkgLyBfcGF0Y2hTaXplLnkgfCAwO1xuXG4gICAgX2JpbmFyeUltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZSwgdW5kZWZpbmVkLCBVaW50OEFycmF5LCBmYWxzZSk7XG5cbiAgICBfbGFiZWxJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKF9wYXRjaFNpemUsIHVuZGVmaW5lZCwgQXJyYXksIHRydWUpO1xuXG4gICAgc2tlbGV0b25JbWFnZURhdGEgPSBuZXcgQXJyYXlCdWZmZXIoNjQgKiAxMDI0KTtcbiAgICBfc3ViSW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcihfcGF0Y2hTaXplLFxuICAgICAgICBuZXcgVWludDhBcnJheShza2VsZXRvbkltYWdlRGF0YSwgMCwgX3BhdGNoU2l6ZS54ICogX3BhdGNoU2l6ZS55KSk7XG4gICAgX3NrZWxJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKF9wYXRjaFNpemUsXG4gICAgICAgIG5ldyBVaW50OEFycmF5KHNrZWxldG9uSW1hZ2VEYXRhLCBfcGF0Y2hTaXplLnggKiBfcGF0Y2hTaXplLnkgKiAzLCBfcGF0Y2hTaXplLnggKiBfcGF0Y2hTaXplLnkpLFxuICAgICAgICB1bmRlZmluZWQsIHRydWUpO1xuICAgIF9za2VsZXRvbml6ZXIgPSBza2VsZXRvbml6ZXIoKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSA/IHdpbmRvdyA6ICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpID8gc2VsZiA6IGdsb2JhbCwge1xuICAgICAgICBzaXplOiBfcGF0Y2hTaXplLnhcbiAgICB9LCBza2VsZXRvbkltYWdlRGF0YSk7XG5cbiAgICBfaW1hZ2VUb1BhdGNoR3JpZCA9IG5ldyBJbWFnZVdyYXBwZXIoe1xuICAgICAgICB4OiAoX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZS54IC8gX3N1YkltYWdlV3JhcHBlci5zaXplLngpIHwgMCxcbiAgICAgICAgeTogKF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUueSAvIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS55KSB8IDBcbiAgICB9LCB1bmRlZmluZWQsIEFycmF5LCB0cnVlKTtcbiAgICBfcGF0Y2hHcmlkID0gbmV3IEltYWdlV3JhcHBlcihfaW1hZ2VUb1BhdGNoR3JpZC5zaXplLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgX3BhdGNoTGFiZWxHcmlkID0gbmV3IEltYWdlV3JhcHBlcihfaW1hZ2VUb1BhdGNoR3JpZC5zaXplLCB1bmRlZmluZWQsIEludDMyQXJyYXksIHRydWUpO1xufVxuXG5mdW5jdGlvbiBpbml0Q2FudmFzKCkge1xuICAgIGlmIChfY29uZmlnLnVzZVdvcmtlciB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkuY2xhc3NOYW1lID0gXCJiaW5hcnlCdWZmZXJcIjtcbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd0NhbnZhcyA9PT0gdHJ1ZSkge1xuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2RlYnVnXCIpLmFwcGVuZENoaWxkKF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSk7XG4gICAgfVxuICAgIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSA9IF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LndpZHRoID0gX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLng7XG4gICAgX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LmhlaWdodCA9IF9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS55O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBib3VuZGluZyBib3ggd2hpY2ggZW5jbG9zZXMgYWxsIHRoZSBnaXZlbiBwYXRjaGVzXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBtaW5pbWFsIGJvdW5kaW5nIGJveFxuICovXG5mdW5jdGlvbiBib3hGcm9tUGF0Y2hlcyhwYXRjaGVzKSB7XG4gICAgdmFyIG92ZXJBdmcsXG4gICAgICAgIGksXG4gICAgICAgIGosXG4gICAgICAgIHBhdGNoLFxuICAgICAgICB0cmFuc01hdCxcbiAgICAgICAgbWlueCA9XG4gICAgICAgIF9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS54LFxuICAgICAgICBtaW55ID0gX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLnksXG4gICAgICAgIG1heHggPSAtX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLngsXG4gICAgICAgIG1heHkgPSAtX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLnksXG4gICAgICAgIGJveCxcbiAgICAgICAgc2NhbGU7XG5cbiAgICAvLyBkcmF3IGFsbCBwYXRjaGVzIHdoaWNoIGFyZSB0byBiZSB0YWtlbiBpbnRvIGNvbnNpZGVyYXRpb25cbiAgICBvdmVyQXZnID0gMDtcbiAgICBmb3IgKCBpID0gMDsgaSA8IHBhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGF0Y2ggPSBwYXRjaGVzW2ldO1xuICAgICAgICBvdmVyQXZnICs9IHBhdGNoLnJhZDtcbiAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dQYXRjaGVzKSB7XG4gICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdSZWN0KHBhdGNoLnBvcywgX3N1YkltYWdlV3JhcHBlci5zaXplLCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHtjb2xvcjogXCJyZWRcIn0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3ZlckF2ZyAvPSBwYXRjaGVzLmxlbmd0aDtcbiAgICBvdmVyQXZnID0gKG92ZXJBdmcgKiAxODAgLyBNYXRoLlBJICsgOTApICUgMTgwIC0gOTA7XG4gICAgaWYgKG92ZXJBdmcgPCAwKSB7XG4gICAgICAgIG92ZXJBdmcgKz0gMTgwO1xuICAgIH1cblxuICAgIG92ZXJBdmcgPSAoMTgwIC0gb3ZlckF2ZykgKiBNYXRoLlBJIC8gMTgwO1xuICAgIHRyYW5zTWF0ID0gbWF0Mi5jb3B5KG1hdDIuY3JlYXRlKCksIFtNYXRoLmNvcyhvdmVyQXZnKSwgTWF0aC5zaW4ob3ZlckF2ZyksIC1NYXRoLnNpbihvdmVyQXZnKSwgTWF0aC5jb3Mob3ZlckF2ZyldKTtcblxuICAgIC8vIGl0ZXJhdGUgb3ZlciBwYXRjaGVzIGFuZCByb3RhdGUgYnkgYW5nbGVcbiAgICBmb3IgKCBpID0gMDsgaSA8IHBhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGF0Y2ggPSBwYXRjaGVzW2ldO1xuICAgICAgICBmb3IgKCBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgdmVjMi50cmFuc2Zvcm1NYXQyKHBhdGNoLmJveFtqXSwgcGF0Y2guYm94W2pdLCB0cmFuc01hdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuYm94RnJvbVBhdGNoZXMuc2hvd1RyYW5zZm9ybWVkKSB7XG4gICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKHBhdGNoLmJveCwge3g6IDAsIHk6IDF9LCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHtjb2xvcjogJyM5OWZmMDAnLCBsaW5lV2lkdGg6IDJ9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZpbmQgYm91bmRpbmcgYm94XG4gICAgZm9yICggaSA9IDA7IGkgPCBwYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhdGNoID0gcGF0Y2hlc1tpXTtcbiAgICAgICAgZm9yICggaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMF0gPCBtaW54KSB7XG4gICAgICAgICAgICAgICAgbWlueCA9IHBhdGNoLmJveFtqXVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMF0gPiBtYXh4KSB7XG4gICAgICAgICAgICAgICAgbWF4eCA9IHBhdGNoLmJveFtqXVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMV0gPCBtaW55KSB7XG4gICAgICAgICAgICAgICAgbWlueSA9IHBhdGNoLmJveFtqXVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMV0gPiBtYXh5KSB7XG4gICAgICAgICAgICAgICAgbWF4eSA9IHBhdGNoLmJveFtqXVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJveCA9IFtbbWlueCwgbWlueV0sIFttYXh4LCBtaW55XSwgW21heHgsIG1heHldLCBbbWlueCwgbWF4eV1dO1xuXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLmJveEZyb21QYXRjaGVzLnNob3dUcmFuc2Zvcm1lZEJveCkge1xuICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGJveCwge3g6IDAsIHk6IDF9LCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHtjb2xvcjogJyNmZjAwMDAnLCBsaW5lV2lkdGg6IDJ9KTtcbiAgICB9XG5cbiAgICBzY2FsZSA9IF9jb25maWcuaGFsZlNhbXBsZSA/IDIgOiAxO1xuICAgIC8vIHJldmVyc2Ugcm90YXRpb247XG4gICAgdHJhbnNNYXQgPSBtYXQyLmludmVydCh0cmFuc01hdCwgdHJhbnNNYXQpO1xuICAgIGZvciAoIGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgIHZlYzIudHJhbnNmb3JtTWF0Mihib3hbal0sIGJveFtqXSwgdHJhbnNNYXQpO1xuICAgIH1cblxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5ib3hGcm9tUGF0Y2hlcy5zaG93QkIpIHtcbiAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChib3gsIHt4OiAwLCB5OiAxfSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LCB7Y29sb3I6ICcjZmYwMDAwJywgbGluZVdpZHRoOiAyfSk7XG4gICAgfVxuXG4gICAgZm9yICggaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgdmVjMi5zY2FsZShib3hbal0sIGJveFtqXSwgc2NhbGUpO1xuICAgIH1cblxuICAgIHJldHVybiBib3g7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJpbmFyeSBpbWFnZSBvZiB0aGUgY3VycmVudCBpbWFnZVxuICovXG5mdW5jdGlvbiBiaW5hcml6ZUltYWdlKCkge1xuICAgIG90c3VUaHJlc2hvbGQoX2N1cnJlbnRJbWFnZVdyYXBwZXIsIF9iaW5hcnlJbWFnZVdyYXBwZXIpO1xuICAgIF9iaW5hcnlJbWFnZVdyYXBwZXIuemVyb0JvcmRlcigpO1xuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93Q2FudmFzKSB7XG4gICAgICAgIF9iaW5hcnlJbWFnZVdyYXBwZXIuc2hvdyhfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnksIDI1NSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciB0aGUgZW50aXJlIGltYWdlXG4gKiBleHRyYWN0IHBhdGNoZXNcbiAqL1xuZnVuY3Rpb24gZmluZFBhdGNoZXMoKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGosXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIG1vbWVudHMsXG4gICAgICAgIHBhdGNoZXNGb3VuZCA9IFtdLFxuICAgICAgICByYXN0ZXJpemVyLFxuICAgICAgICByYXN0ZXJSZXN1bHQsXG4gICAgICAgIHBhdGNoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBfbnVtUGF0Y2hlcy54OyBpKyspIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IF9udW1QYXRjaGVzLnk7IGorKykge1xuICAgICAgICAgICAgeCA9IF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS54ICogaTtcbiAgICAgICAgICAgIHkgPSBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueSAqIGo7XG5cbiAgICAgICAgICAgIC8vIHNlcGVyYXRlIHBhcnRzXG4gICAgICAgICAgICBza2VsZXRvbml6ZSh4LCB5KTtcblxuICAgICAgICAgICAgLy8gUmFzdGVyaXplLCBmaW5kIGluZGl2aWR1YWwgYmFyc1xuICAgICAgICAgICAgX3NrZWxJbWFnZVdyYXBwZXIuemVyb0JvcmRlcigpO1xuICAgICAgICAgICAgQXJyYXlIZWxwZXIuaW5pdChfbGFiZWxJbWFnZVdyYXBwZXIuZGF0YSwgMCk7XG4gICAgICAgICAgICByYXN0ZXJpemVyID0gUmFzdGVyaXplci5jcmVhdGUoX3NrZWxJbWFnZVdyYXBwZXIsIF9sYWJlbEltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICByYXN0ZXJSZXN1bHQgPSByYXN0ZXJpemVyLnJhc3Rlcml6ZSgwKTtcblxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dMYWJlbHMpIHtcbiAgICAgICAgICAgICAgICBfbGFiZWxJbWFnZVdyYXBwZXIub3ZlcmxheShfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnksIE1hdGguZmxvb3IoMzYwIC8gcmFzdGVyUmVzdWx0LmNvdW50KSxcbiAgICAgICAgICAgICAgICAgICAge3g6IHgsIHk6IHl9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIG1vbWVudHMgZnJvbSB0aGUgc2tlbGV0b25pemVkIHBhdGNoXG4gICAgICAgICAgICBtb21lbnRzID0gX2xhYmVsSW1hZ2VXcmFwcGVyLm1vbWVudHMocmFzdGVyUmVzdWx0LmNvdW50KTtcblxuICAgICAgICAgICAgLy8gZXh0cmFjdCBlbGlnaWJsZSBwYXRjaGVzXG4gICAgICAgICAgICBwYXRjaGVzRm91bmQgPSBwYXRjaGVzRm91bmQuY29uY2F0KGRlc2NyaWJlUGF0Y2gobW9tZW50cywgW2ksIGpdLCB4LCB5KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd0ZvdW5kUGF0Y2hlcykge1xuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IHBhdGNoZXNGb3VuZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGF0Y2ggPSBwYXRjaGVzRm91bmRbaV07XG4gICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdSZWN0KHBhdGNoLnBvcywgX3N1YkltYWdlV3JhcHBlci5zaXplLCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksXG4gICAgICAgICAgICAgICAge2NvbG9yOiBcIiM5OWZmMDBcIiwgbGluZVdpZHRoOiAyfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGF0Y2hlc0ZvdW5kO1xufVxuXG4vKipcbiAqIEZpbmRzIHRob3NlIGNvbm5lY3RlZCBhcmVhcyB3aGljaCBjb250YWluIGF0IGxlYXN0IDYgcGF0Y2hlc1xuICogYW5kIHJldHVybnMgdGhlbSBvcmRlcmVkIERFU0MgYnkgdGhlIG51bWJlciBvZiBjb250YWluZWQgcGF0Y2hlc1xuICogQHBhcmFtIHtOdW1iZXJ9IG1heExhYmVsXG4gKi9cbmZ1bmN0aW9uIGZpbmRCaWdnZXN0Q29ubmVjdGVkQXJlYXMobWF4TGFiZWwpe1xuICAgIHZhciBpLFxuICAgICAgICBzdW0sXG4gICAgICAgIGxhYmVsSGlzdCA9IFtdLFxuICAgICAgICB0b3BMYWJlbHMgPSBbXTtcblxuICAgIGZvciAoIGkgPSAwOyBpIDwgbWF4TGFiZWw7IGkrKykge1xuICAgICAgICBsYWJlbEhpc3QucHVzaCgwKTtcbiAgICB9XG4gICAgc3VtID0gX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoO1xuICAgIHdoaWxlIChzdW0tLSkge1xuICAgICAgICBpZiAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbc3VtXSA+IDApIHtcbiAgICAgICAgICAgIGxhYmVsSGlzdFtfcGF0Y2hMYWJlbEdyaWQuZGF0YVtzdW1dIC0gMV0rKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxhYmVsSGlzdCA9IGxhYmVsSGlzdC5tYXAoZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbDogdmFsLFxuICAgICAgICAgICAgbGFiZWw6IGlkeCArIDFcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGxhYmVsSGlzdC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIudmFsIC0gYS52YWw7XG4gICAgfSk7XG5cbiAgICAvLyBleHRyYWN0IHRvcCBhcmVhcyB3aXRoIGF0IGxlYXN0IDYgcGF0Y2hlcyBwcmVzZW50XG4gICAgdG9wTGFiZWxzID0gbGFiZWxIaXN0LmZpbHRlcihmdW5jdGlvbihlbCkge1xuICAgICAgICByZXR1cm4gZWwudmFsID49IDU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdG9wTGFiZWxzO1xufVxuXG4vKipcbiAqXG4gKi9cbmZ1bmN0aW9uIGZpbmRCb3hlcyh0b3BMYWJlbHMsIG1heExhYmVsKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGosXG4gICAgICAgIHN1bSxcbiAgICAgICAgcGF0Y2hlcyA9IFtdLFxuICAgICAgICBwYXRjaCxcbiAgICAgICAgYm94LFxuICAgICAgICBib3hlcyA9IFtdLFxuICAgICAgICBoc3YgPSBbMCwgMSwgMV0sXG4gICAgICAgIHJnYiA9IFswLCAwLCAwXTtcblxuICAgIGZvciAoIGkgPSAwOyBpIDwgdG9wTGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN1bSA9IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aDtcbiAgICAgICAgcGF0Y2hlcy5sZW5ndGggPSAwO1xuICAgICAgICB3aGlsZSAoc3VtLS0pIHtcbiAgICAgICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtzdW1dID09PSB0b3BMYWJlbHNbaV0ubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBwYXRjaCA9IF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbc3VtXTtcbiAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2gocGF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJveCA9IGJveEZyb21QYXRjaGVzKHBhdGNoZXMpO1xuICAgICAgICBpZiAoYm94KSB7XG4gICAgICAgICAgICBib3hlcy5wdXNoKGJveCk7XG5cbiAgICAgICAgICAgIC8vIGRyYXcgcGF0Y2gtbGFiZWxzIGlmIHJlcXVlc3RlZFxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dSZW1haW5pbmdQYXRjaExhYmVscykge1xuICAgICAgICAgICAgICAgIGZvciAoIGogPSAwOyBqIDwgcGF0Y2hlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBwYXRjaCA9IHBhdGNoZXNbal07XG4gICAgICAgICAgICAgICAgICAgIGhzdlswXSA9ICh0b3BMYWJlbHNbaV0ubGFiZWwgLyAobWF4TGFiZWwgKyAxKSkgKiAzNjA7XG4gICAgICAgICAgICAgICAgICAgIGhzdjJyZ2IoaHN2LCByZ2IpO1xuICAgICAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdSZWN0KHBhdGNoLnBvcywgX3N1YkltYWdlV3JhcHBlci5zaXplLCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksXG4gICAgICAgICAgICAgICAgICAgICAgICB7Y29sb3I6IFwicmdiKFwiICsgcmdiLmpvaW4oXCIsXCIpICsgXCIpXCIsIGxpbmVXaWR0aDogMn0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm94ZXM7XG59XG5cbi8qKlxuICogRmluZCBzaW1pbGFyIG1vbWVudHMgKHZpYSBjbHVzdGVyKVxuICogQHBhcmFtIHtPYmplY3R9IG1vbWVudHNcbiAqL1xuZnVuY3Rpb24gc2ltaWxhck1vbWVudHMobW9tZW50cykge1xuICAgIHZhciBjbHVzdGVycyA9IGNsdXN0ZXIobW9tZW50cywgMC45MCk7XG4gICAgdmFyIHRvcENsdXN0ZXIgPSB0b3BHZW5lcmljKGNsdXN0ZXJzLCAxLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiBlLmdldFBvaW50cygpLmxlbmd0aDtcbiAgICB9KTtcbiAgICB2YXIgcG9pbnRzID0gW10sIHJlc3VsdCA9IFtdO1xuICAgIGlmICh0b3BDbHVzdGVyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBwb2ludHMgPSB0b3BDbHVzdGVyWzBdLml0ZW0uZ2V0UG9pbnRzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwb2ludHNbaV0ucG9pbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHNrZWxldG9uaXplKHgsIHkpIHtcbiAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyLnN1YkltYWdlQXNDb3B5KF9zdWJJbWFnZVdyYXBwZXIsIGltYWdlUmVmKHgsIHkpKTtcbiAgICBfc2tlbGV0b25pemVyLnNrZWxldG9uaXplKCk7XG5cbiAgICAvLyBTaG93IHNrZWxldG9uIGlmIHJlcXVlc3RlZFxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93U2tlbGV0b24pIHtcbiAgICAgICAgX3NrZWxJbWFnZVdyYXBwZXIub3ZlcmxheShfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnksIDM2MCwgaW1hZ2VSZWYoeCwgeSkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0cyBhbmQgZGVzY3JpYmVzIHRob3NlIHBhdGNoZXMgd2hpY2ggc2VlbSB0byBjb250YWluIGEgYmFyY29kZSBwYXR0ZXJuXG4gKiBAcGFyYW0ge0FycmF5fSBtb21lbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gcGF0Y2hQb3MsXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm5zIHtBcnJheX0gbGlzdCBvZiBwYXRjaGVzXG4gKi9cbmZ1bmN0aW9uIGRlc2NyaWJlUGF0Y2gobW9tZW50cywgcGF0Y2hQb3MsIHgsIHkpIHtcbiAgICB2YXIgayxcbiAgICAgICAgYXZnLFxuICAgICAgICBlbGlnaWJsZU1vbWVudHMgPSBbXSxcbiAgICAgICAgbWF0Y2hpbmdNb21lbnRzLFxuICAgICAgICBwYXRjaCxcbiAgICAgICAgcGF0Y2hlc0ZvdW5kID0gW10sXG4gICAgICAgIG1pbkNvbXBvbmVudFdlaWdodCA9IE1hdGguY2VpbChfcGF0Y2hTaXplLnggLyAzKTtcblxuICAgIGlmIChtb21lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIC8vIG9ubHkgY29sbGVjdCBtb21lbnRzIHdoaWNoJ3MgYXJlYSBjb3ZlcnMgYXQgbGVhc3QgbWluQ29tcG9uZW50V2VpZ2h0IHBpeGVscy5cbiAgICAgICAgZm9yICggayA9IDA7IGsgPCBtb21lbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBpZiAobW9tZW50c1trXS5tMDAgPiBtaW5Db21wb25lbnRXZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBlbGlnaWJsZU1vbWVudHMucHVzaChtb21lbnRzW2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGF0IGxlYXN0IDIgbW9tZW50cyBhcmUgZm91bmQgd2hpY2ggaGF2ZSBhdCBsZWFzdCBtaW5Db21wb25lbnRXZWlnaHRzIGNvdmVyZWRcbiAgICAgICAgaWYgKGVsaWdpYmxlTW9tZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgbWF0Y2hpbmdNb21lbnRzID0gc2ltaWxhck1vbWVudHMoZWxpZ2libGVNb21lbnRzKTtcbiAgICAgICAgICAgIGF2ZyA9IDA7XG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIHNpbWlsYXJpdHkgb2YgdGhlIG1vbWVudHNcbiAgICAgICAgICAgIGZvciAoIGsgPSAwOyBrIDwgbWF0Y2hpbmdNb21lbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgYXZnICs9IG1hdGNoaW5nTW9tZW50c1trXS5yYWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9ubHkgdHdvIG9mIHRoZSBtb21lbnRzIGFyZSBhbGxvd2VkIG5vdCB0byBmaXQgaW50byB0aGUgZXF1YXRpb25cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgcGF0Y2ggdG8gdGhlIHNldFxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nTW9tZW50cy5sZW5ndGggPiAxXG4gICAgICAgICAgICAgICAgICAgICYmIG1hdGNoaW5nTW9tZW50cy5sZW5ndGggPj0gKGVsaWdpYmxlTW9tZW50cy5sZW5ndGggLyA0KSAqIDNcbiAgICAgICAgICAgICAgICAgICAgJiYgbWF0Y2hpbmdNb21lbnRzLmxlbmd0aCA+IG1vbWVudHMubGVuZ3RoIC8gNCkge1xuICAgICAgICAgICAgICAgIGF2ZyAvPSBtYXRjaGluZ01vbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHBhdGNoID0ge1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogcGF0Y2hQb3NbMV0gKiBfbnVtUGF0Y2hlcy54ICsgcGF0Y2hQb3NbMF0sXG4gICAgICAgICAgICAgICAgICAgIHBvczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYm94OiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLmNsb25lKFt4LCB5XSksXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLmNsb25lKFt4ICsgX3N1YkltYWdlV3JhcHBlci5zaXplLngsIHldKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUoW3ggKyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueCwgeSArIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS55XSksXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLmNsb25lKFt4LCB5ICsgX3N1YkltYWdlV3JhcHBlci5zaXplLnldKVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBtb21lbnRzOiBtYXRjaGluZ01vbWVudHMsXG4gICAgICAgICAgICAgICAgICAgIHJhZDogYXZnLFxuICAgICAgICAgICAgICAgICAgICB2ZWM6IHZlYzIuY2xvbmUoW01hdGguY29zKGF2ZyksIE1hdGguc2luKGF2ZyldKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcGF0Y2hlc0ZvdW5kLnB1c2gocGF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXRjaGVzRm91bmQ7XG59XG5cbi8qKlxuICogZmluZHMgcGF0Y2hlcyB3aGljaCBhcmUgY29ubmVjdGVkIGFuZCBzaGFyZSB0aGUgc2FtZSBvcmllbnRhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHBhdGNoZXNGb3VuZFxuICovXG5mdW5jdGlvbiByYXN0ZXJpemVBbmd1bGFyU2ltaWxhcml0eShwYXRjaGVzRm91bmQpIHtcbiAgICB2YXIgbGFiZWwgPSAwLFxuICAgICAgICB0aHJlc2hvbGQgPSAwLjk1LFxuICAgICAgICBjdXJySWR4ID0gMCxcbiAgICAgICAgaixcbiAgICAgICAgcGF0Y2gsXG4gICAgICAgIGhzdiA9IFswLCAxLCAxXSxcbiAgICAgICAgcmdiID0gWzAsIDAsIDBdO1xuXG4gICAgZnVuY3Rpb24gbm90WWV0UHJvY2Vzc2VkKCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW2ldID09PSAwICYmIF9wYXRjaEdyaWQuZGF0YVtpXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcGF0Y2hMYWJlbEdyaWQubGVuZ3RoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYWNlKGN1cnJlbnRJZHgpIHtcbiAgICAgICAgdmFyIHgsXG4gICAgICAgICAgICB5LFxuICAgICAgICAgICAgY3VycmVudFBhdGNoLFxuICAgICAgICAgICAgaWR4LFxuICAgICAgICAgICAgZGlyLFxuICAgICAgICAgICAgY3VycmVudCA9IHtcbiAgICAgICAgICAgICAgICB4OiBjdXJyZW50SWR4ICUgX3BhdGNoTGFiZWxHcmlkLnNpemUueCxcbiAgICAgICAgICAgICAgICB5OiAoY3VycmVudElkeCAvIF9wYXRjaExhYmVsR3JpZC5zaXplLngpIHwgMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNpbWlsYXJpdHk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRJZHggPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXRjaCA9IF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbY3VycmVudElkeF07XG4gICAgICAgICAgICAvLyBhc3NpZ24gbGFiZWxcbiAgICAgICAgICAgIF9wYXRjaExhYmVsR3JpZC5kYXRhW2N1cnJlbnRJZHhdID0gbGFiZWw7XG4gICAgICAgICAgICBmb3IgKCBkaXIgPSAwOyBkaXIgPCBUcmFjZXIuc2VhcmNoRGlyZWN0aW9ucy5sZW5ndGg7IGRpcisrKSB7XG4gICAgICAgICAgICAgICAgeSA9IGN1cnJlbnQueSArIFRyYWNlci5zZWFyY2hEaXJlY3Rpb25zW2Rpcl1bMF07XG4gICAgICAgICAgICAgICAgeCA9IGN1cnJlbnQueCArIFRyYWNlci5zZWFyY2hEaXJlY3Rpb25zW2Rpcl1bMV07XG4gICAgICAgICAgICAgICAgaWR4ID0geSAqIF9wYXRjaExhYmVsR3JpZC5zaXplLnggKyB4O1xuXG4gICAgICAgICAgICAgICAgLy8gY29udGludWUgaWYgcGF0Y2ggZW1wdHlcbiAgICAgICAgICAgICAgICBpZiAoX3BhdGNoR3JpZC5kYXRhW2lkeF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX3BhdGNoTGFiZWxHcmlkLmRhdGFbaWR4XSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtpZHhdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbWlsYXJpdHkgPSBNYXRoLmFicyh2ZWMyLmRvdChfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhW2lkeF0udmVjLCBjdXJyZW50UGF0Y2gudmVjKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaW1pbGFyaXR5ID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZShpZHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcHJlcGFyZSBmb3IgZmluZGluZyB0aGUgcmlnaHQgcGF0Y2hlc1xuICAgIEFycmF5SGVscGVyLmluaXQoX3BhdGNoR3JpZC5kYXRhLCAwKTtcbiAgICBBcnJheUhlbHBlci5pbml0KF9wYXRjaExhYmVsR3JpZC5kYXRhLCAwKTtcbiAgICBBcnJheUhlbHBlci5pbml0KF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGEsIG51bGwpO1xuXG4gICAgZm9yICggaiA9IDA7IGogPCBwYXRjaGVzRm91bmQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcGF0Y2ggPSBwYXRjaGVzRm91bmRbal07XG4gICAgICAgIF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbcGF0Y2guaW5kZXhdID0gcGF0Y2g7XG4gICAgICAgIF9wYXRjaEdyaWQuZGF0YVtwYXRjaC5pbmRleF0gPSAxO1xuICAgIH1cblxuICAgIC8vIHJhc3Rlcml6ZSB0aGUgcGF0Y2hlcyBmb3VuZCB0byBkZXRlcm1pbmUgYXJlYVxuICAgIF9wYXRjaEdyaWQuemVyb0JvcmRlcigpO1xuXG4gICAgd2hpbGUgKCggY3VycklkeCA9IG5vdFlldFByb2Nlc3NlZCgpKSA8IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICBsYWJlbCsrO1xuICAgICAgICB0cmFjZShjdXJySWR4KTtcbiAgICB9XG5cbiAgICAvLyBkcmF3IHBhdGNoLWxhYmVscyBpZiByZXF1ZXN0ZWRcbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd1BhdGNoTGFiZWxzKSB7XG4gICAgICAgIGZvciAoIGogPSAwOyBqIDwgX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtqXSA+IDAgJiYgX3BhdGNoTGFiZWxHcmlkLmRhdGFbal0gPD0gbGFiZWwpIHtcbiAgICAgICAgICAgICAgICBwYXRjaCA9IF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbal07XG4gICAgICAgICAgICAgICAgaHN2WzBdID0gKF9wYXRjaExhYmVsR3JpZC5kYXRhW2pdIC8gKGxhYmVsICsgMSkpICogMzYwO1xuICAgICAgICAgICAgICAgIGhzdjJyZ2IoaHN2LCByZ2IpO1xuICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSxcbiAgICAgICAgICAgICAgICAgICAge2NvbG9yOiBcInJnYihcIiArIHJnYi5qb2luKFwiLFwiKSArIFwiKVwiLCBsaW5lV2lkdGg6IDJ9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsYWJlbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGluaXQ6IGZ1bmN0aW9uKGlucHV0SW1hZ2VXcmFwcGVyLCBjb25maWcpIHtcbiAgICAgICAgX2NvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgX2lucHV0SW1hZ2VXcmFwcGVyID0gaW5wdXRJbWFnZVdyYXBwZXI7XG5cbiAgICAgICAgaW5pdEJ1ZmZlcnMoKTtcbiAgICAgICAgaW5pdENhbnZhcygpO1xuICAgIH0sXG5cbiAgICBsb2NhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGF0Y2hlc0ZvdW5kLFxuICAgICAgICAgICAgdG9wTGFiZWxzLFxuICAgICAgICAgICAgYm94ZXM7XG5cbiAgICAgICAgaWYgKF9jb25maWcuaGFsZlNhbXBsZSkge1xuICAgICAgICAgICAgaGFsZlNhbXBsZShfaW5wdXRJbWFnZVdyYXBwZXIsIF9jdXJyZW50SW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJpbmFyaXplSW1hZ2UoKTtcbiAgICAgICAgcGF0Y2hlc0ZvdW5kID0gZmluZFBhdGNoZXMoKTtcbiAgICAgICAgLy8gcmV0dXJuIHVubGVzcyA1JSBvciBtb3JlIHBhdGNoZXMgYXJlIGZvdW5kXG4gICAgICAgIGlmIChwYXRjaGVzRm91bmQubGVuZ3RoIDwgX251bVBhdGNoZXMueCAqIF9udW1QYXRjaGVzLnkgKiAwLjA1KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJhc3RlcnJpemUgYXJlYSBieSBjb21wYXJpbmcgYW5ndWxhciBzaW1pbGFyaXR5O1xuICAgICAgICB2YXIgbWF4TGFiZWwgPSByYXN0ZXJpemVBbmd1bGFyU2ltaWxhcml0eShwYXRjaGVzRm91bmQpO1xuICAgICAgICBpZiAobWF4TGFiZWwgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNlYXJjaCBmb3IgYXJlYSB3aXRoIHRoZSBtb3N0IHBhdGNoZXMgKGJpZ2dlc3QgY29ubmVjdGVkIGFyZWEpXG4gICAgICAgIHRvcExhYmVscyA9IGZpbmRCaWdnZXN0Q29ubmVjdGVkQXJlYXMobWF4TGFiZWwpO1xuICAgICAgICBpZiAodG9wTGFiZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBib3hlcyA9IGZpbmRCb3hlcyh0b3BMYWJlbHMsIG1heExhYmVsKTtcbiAgICAgICAgcmV0dXJuIGJveGVzO1xuICAgIH0sXG5cbiAgICBjaGVja0ltYWdlQ29uc3RyYWludHM6IGZ1bmN0aW9uKGlucHV0U3RyZWFtLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBhdGNoU2l6ZSxcbiAgICAgICAgICAgIHdpZHRoID0gaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgIGhlaWdodCA9IGlucHV0U3RyZWFtLmdldEhlaWdodCgpLFxuICAgICAgICAgICAgaGFsZlNhbXBsZSA9IGNvbmZpZy5oYWxmU2FtcGxlID8gMC41IDogMSxcbiAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICBhcmVhO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB3aWR0aCBhbmQgaGVpZ2h0IGJhc2VkIG9uIGFyZWFcbiAgICAgICAgaWYgKGlucHV0U3RyZWFtLmdldENvbmZpZygpLmFyZWEpIHtcbiAgICAgICAgICAgIGFyZWEgPSBjb21wdXRlSW1hZ2VBcmVhKHdpZHRoLCBoZWlnaHQsIGlucHV0U3RyZWFtLmdldENvbmZpZygpLmFyZWEpO1xuICAgICAgICAgICAgaW5wdXRTdHJlYW0uc2V0VG9wUmlnaHQoe3g6IGFyZWEuc3gsIHk6IGFyZWEuc3l9KTtcbiAgICAgICAgICAgIGlucHV0U3RyZWFtLnNldENhbnZhc1NpemUoe3g6IHdpZHRoLCB5OiBoZWlnaHR9KTtcbiAgICAgICAgICAgIHdpZHRoID0gYXJlYS5zdztcbiAgICAgICAgICAgIGhlaWdodCA9IGFyZWEuc2g7XG4gICAgICAgIH1cblxuICAgICAgICBzaXplID0ge1xuICAgICAgICAgICAgeDogTWF0aC5mbG9vcih3aWR0aCAqIGhhbGZTYW1wbGUpLFxuICAgICAgICAgICAgeTogTWF0aC5mbG9vcihoZWlnaHQgKiBoYWxmU2FtcGxlKVxuICAgICAgICB9O1xuXG4gICAgICAgIHBhdGNoU2l6ZSA9IGNhbGN1bGF0ZVBhdGNoU2l6ZShjb25maWcucGF0Y2hTaXplLCBzaXplKTtcbiAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJQYXRjaC1TaXplOiBcIiArIEpTT04uc3RyaW5naWZ5KHBhdGNoU2l6ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXRTdHJlYW0uc2V0V2lkdGgoTWF0aC5mbG9vcihNYXRoLmZsb29yKHNpemUueCAvIHBhdGNoU2l6ZS54KSAqICgxIC8gaGFsZlNhbXBsZSkgKiBwYXRjaFNpemUueCkpO1xuICAgICAgICBpbnB1dFN0cmVhbS5zZXRIZWlnaHQoTWF0aC5mbG9vcihNYXRoLmZsb29yKHNpemUueSAvIHBhdGNoU2l6ZS55KSAqICgxIC8gaGFsZlNhbXBsZSkgKiBwYXRjaFNpemUueSkpO1xuXG4gICAgICAgIGlmICgoaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSAlIHBhdGNoU2l6ZS54KSA9PT0gMCAmJiAoaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCkgJSBwYXRjaFNpemUueSkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgZGltZW5zaW9ucyBkbyBub3QgY29tcGx5IHdpdGggdGhlIGN1cnJlbnQgc2V0dGluZ3M6IFdpZHRoIChcIiArXG4gICAgICAgICAgICB3aWR0aCArIFwiIClhbmQgaGVpZ2h0IChcIiArIGhlaWdodCArXG4gICAgICAgICAgICBcIikgbXVzdCBhIG11bHRpcGxlIG9mIFwiICsgcGF0Y2hTaXplLngpO1xuICAgIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbG9jYXRvci9iYXJjb2RlX2xvY2F0b3IuanMiLCJpbXBvcnQgVHJhY2VyIGZyb20gJy4vdHJhY2VyJztcblxuLyoqXG4gKiBodHRwOi8vd3d3LmNvZGVwcm9qZWN0LmNvbS9UaXBzLzQwNzE3Mi9Db25uZWN0ZWQtQ29tcG9uZW50LUxhYmVsaW5nLWFuZC1WZWN0b3JpemF0aW9uXG4gKi9cbnZhciBSYXN0ZXJpemVyID0ge1xuICAgIGNyZWF0ZUNvbnRvdXIyRDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXI6IG51bGwsXG4gICAgICAgICAgICBpbmRleDogbnVsbCxcbiAgICAgICAgICAgIGZpcnN0VmVydGV4OiBudWxsLFxuICAgICAgICAgICAgaW5zaWRlQ29udG91cnM6IG51bGwsXG4gICAgICAgICAgICBuZXh0cGVlcjogbnVsbCxcbiAgICAgICAgICAgIHByZXZwZWVyOiBudWxsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBDT05UT1VSX0RJUjoge1xuICAgICAgICBDV19ESVI6IDAsXG4gICAgICAgIENDV19ESVI6IDEsXG4gICAgICAgIFVOS05PV05fRElSOiAyXG4gICAgfSxcbiAgICBESVI6IHtcbiAgICAgICAgT1VUU0lERV9FREdFOiAtMzI3NjcsXG4gICAgICAgIElOU0lERV9FREdFOiAtMzI3NjZcbiAgICB9LFxuICAgIGNyZWF0ZTogZnVuY3Rpb24oaW1hZ2VXcmFwcGVyLCBsYWJlbFdyYXBwZXIpIHtcbiAgICAgICAgdmFyIGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhLFxuICAgICAgICAgICAgbGFiZWxEYXRhID0gbGFiZWxXcmFwcGVyLmRhdGEsXG4gICAgICAgICAgICB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLngsXG4gICAgICAgICAgICBoZWlnaHQgPSBpbWFnZVdyYXBwZXIuc2l6ZS55LFxuICAgICAgICAgICAgdHJhY2VyID0gVHJhY2VyLmNyZWF0ZShpbWFnZVdyYXBwZXIsIGxhYmVsV3JhcHBlcik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhc3Rlcml6ZTogZnVuY3Rpb24oZGVwdGhsYWJlbCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgYmMsXG4gICAgICAgICAgICAgICAgICAgIGxjLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBjeCxcbiAgICAgICAgICAgICAgICAgICAgY3ksXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yTWFwID0gW10sXG4gICAgICAgICAgICAgICAgICAgIHZlcnRleCxcbiAgICAgICAgICAgICAgICAgICAgcCxcbiAgICAgICAgICAgICAgICAgICAgY2MsXG4gICAgICAgICAgICAgICAgICAgIHNjLFxuICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZENvdW50ID0gMCxcbiAgICAgICAgICAgICAgICAgICAgaTtcblxuICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgNDAwOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JNYXBbaV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbG9yTWFwWzBdID0gaW1hZ2VEYXRhWzBdO1xuICAgICAgICAgICAgICAgIGNjID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKCBjeSA9IDE7IGN5IDwgaGVpZ2h0IC0gMTsgY3krKykge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYmMgPSBjb2xvck1hcFswXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICggY3ggPSAxOyBjeCA8IHdpZHRoIC0gMTsgY3grKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gY3kgKiB3aWR0aCArIGN4O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsRGF0YVtwb3NdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBpbWFnZURhdGFbcG9zXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3IgIT09IGJjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYyA9IGNvbm5lY3RlZENvdW50ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yTWFwW2xjXSA9IGNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmMgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRleCA9IHRyYWNlci5jb250b3VyVHJhY2luZyhjeSwgY3gsIGxjLCBjb2xvciwgUmFzdGVyaXplci5ESVIuT1VUU0lERV9FREdFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0ZWRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsaW5kZXggPSBsYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gUmFzdGVyaXplci5jcmVhdGVDb250b3VyMkQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmRpciA9IFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuQ1dfRElSO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuaW5kZXggPSBsYWJlbGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZmlyc3RWZXJ0ZXggPSB2ZXJ0ZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5uZXh0cGVlciA9IGNjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuaW5zaWRlQ29udG91cnMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYy5wcmV2cGVlciA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNjID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRleCA9IHRyYWNlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb250b3VyVHJhY2luZyhjeSwgY3gsIFJhc3Rlcml6ZXIuRElSLklOU0lERV9FREdFLCBjb2xvciwgbGFiZWxpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVydGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IFJhc3Rlcml6ZXIuY3JlYXRlQ29udG91cjJEKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5maXJzdFZlcnRleCA9IHZlcnRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmluc2lkZUNvbnRvdXJzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGhsYWJlbCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmRpciA9IFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuQ0NXX0RJUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmRpciA9IFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuQ1dfRElSO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmluZGV4ID0gZGVwdGhsYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYyA9IGNjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoc2MgIT09IG51bGwpICYmIHNjLmluZGV4ICE9PSBsYWJlbGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjID0gc2MubmV4dHBlZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLm5leHRwZWVyID0gc2MuaW5zaWRlQ29udG91cnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzYy5pbnNpZGVDb250b3VycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2MuaW5zaWRlQ29udG91cnMucHJldnBlZXIgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjLmluc2lkZUNvbnRvdXJzID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbERhdGFbcG9zXSA9IGxhYmVsaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYWJlbERhdGFbcG9zXSA9PT0gUmFzdGVyaXplci5ESVIuT1VUU0lERV9FREdFXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGxhYmVsRGF0YVtwb3NdID09PSBSYXN0ZXJpemVyLkRJUi5JTlNJREVfRURHRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbERhdGFbcG9zXSA9PT0gUmFzdGVyaXplci5ESVIuSU5TSURFX0VER0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmMgPSBpbWFnZURhdGFbcG9zXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYyA9IGNvbG9yTWFwWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxpbmRleCA9IGxhYmVsRGF0YVtwb3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJjID0gY29sb3JNYXBbbGFiZWxpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2MgPSBjYztcbiAgICAgICAgICAgICAgICB3aGlsZSAoc2MgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2MuaW5kZXggPSBkZXB0aGxhYmVsO1xuICAgICAgICAgICAgICAgICAgICBzYyA9IHNjLm5leHRwZWVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjYzogY2MsXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiBjb25uZWN0ZWRDb3VudFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVidWc6IHtcbiAgICAgICAgICAgICAgICBkcmF3Q29udG91cjogZnVuY3Rpb24oY2FudmFzLCBmaXJzdENvbnRvdXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcSA9IGZpcnN0Q29udG91cixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlxLFxuICAgICAgICAgICAgICAgICAgICAgICAgcSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHA7XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJyZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwicmVkXCI7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBwcS5pbnNpZGVDb250b3VycztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwcSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9IGlxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gaXEubmV4dHBlZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBwcTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcSA9IHBxLm5leHRwZWVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcSA9IHBxLmluc2lkZUNvbnRvdXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocS5kaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmFzdGVyaXplci5DT05UT1VSX0RJUi5DV19ESVI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJyZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmFzdGVyaXplci5DT05UT1VSX0RJUi5DQ1dfRElSOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiYmx1ZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLlVOS05PV05fRElSOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiZ3JlZW5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHEuZmlyc3RWZXJ0ZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHAueCwgcC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocC54LCBwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAocCAhPT0gcS5maXJzdFZlcnRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgUmFzdGVyaXplcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9sb2NhdG9yL3Jhc3Rlcml6ZXIuanMiLCIvKiBAcHJlc2VydmUgQVNNIEJFR0lOICovXG4vKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEqL1xuZnVuY3Rpb24gU2tlbGV0b25pemVyKHN0ZGxpYiwgZm9yZWlnbiwgYnVmZmVyKSB7XG4gICAgXCJ1c2UgYXNtXCI7XG5cbiAgICB2YXIgaW1hZ2VzID0gbmV3IHN0ZGxpYi5VaW50OEFycmF5KGJ1ZmZlciksXG4gICAgICAgIHNpemUgPSBmb3JlaWduLnNpemUgfCAwLFxuICAgICAgICBpbXVsID0gc3RkbGliLk1hdGguaW11bDtcblxuICAgIGZ1bmN0aW9uIGVyb2RlKGluSW1hZ2VQdHIsIG91dEltYWdlUHRyKSB7XG4gICAgICAgIGluSW1hZ2VQdHIgPSBpbkltYWdlUHRyIHwgMDtcbiAgICAgICAgb3V0SW1hZ2VQdHIgPSBvdXRJbWFnZVB0ciB8IDA7XG5cbiAgICAgICAgdmFyIHYgPSAwLFxuICAgICAgICAgICAgdSA9IDAsXG4gICAgICAgICAgICBzdW0gPSAwLFxuICAgICAgICAgICAgeVN0YXJ0MSA9IDAsXG4gICAgICAgICAgICB5U3RhcnQyID0gMCxcbiAgICAgICAgICAgIHhTdGFydDEgPSAwLFxuICAgICAgICAgICAgeFN0YXJ0MiA9IDAsXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGZvciAoIHYgPSAxOyAodiB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgdiA9ICh2ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0ICsgc2l6ZSkgfCAwO1xuICAgICAgICAgICAgZm9yICggdSA9IDE7ICh1IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB1ID0gKHUgKyAxKSB8IDApIHtcbiAgICAgICAgICAgICAgICB5U3RhcnQxID0gKG9mZnNldCAtIHNpemUpIHwgMDtcbiAgICAgICAgICAgICAgICB5U3RhcnQyID0gKG9mZnNldCArIHNpemUpIHwgMDtcbiAgICAgICAgICAgICAgICB4U3RhcnQxID0gKHUgLSAxKSB8IDA7XG4gICAgICAgICAgICAgICAgeFN0YXJ0MiA9ICh1ICsgMSkgfCAwO1xuICAgICAgICAgICAgICAgIHN1bSA9ICgoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MSArIHhTdGFydDEpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MikgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQyICsgeFN0YXJ0MSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQyKSB8IDBdIHwgMCkpIHwgMDtcbiAgICAgICAgICAgICAgICBpZiAoKHN1bSB8IDApID09ICg1IHwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGFJbWFnZVB0ciwgYkltYWdlUHRyLCBvdXRJbWFnZVB0cikge1xuICAgICAgICBhSW1hZ2VQdHIgPSBhSW1hZ2VQdHIgfCAwO1xuICAgICAgICBiSW1hZ2VQdHIgPSBiSW1hZ2VQdHIgfCAwO1xuICAgICAgICBvdXRJbWFnZVB0ciA9IG91dEltYWdlUHRyIHwgMDtcblxuICAgICAgICB2YXIgbGVuZ3RoID0gMDtcblxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcblxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcbiAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gPVxuICAgICAgICAgICAgICAgICgoaW1hZ2VzWyhhSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSAtIChpbWFnZXNbKGJJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApKSB8IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiaXR3aXNlT3IoYUltYWdlUHRyLCBiSW1hZ2VQdHIsIG91dEltYWdlUHRyKSB7XG4gICAgICAgIGFJbWFnZVB0ciA9IGFJbWFnZVB0ciB8IDA7XG4gICAgICAgIGJJbWFnZVB0ciA9IGJJbWFnZVB0ciB8IDA7XG4gICAgICAgIG91dEltYWdlUHRyID0gb3V0SW1hZ2VQdHIgfCAwO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSA9XG4gICAgICAgICAgICAgICAgKChpbWFnZXNbKGFJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApIHwgKGltYWdlc1soYkltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCkpIHwgMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvdW50Tm9uWmVybyhpbWFnZVB0cikge1xuICAgICAgICBpbWFnZVB0ciA9IGltYWdlUHRyIHwgMDtcblxuICAgICAgICB2YXIgc3VtID0gMCxcbiAgICAgICAgICAgIGxlbmd0aCA9IDA7XG5cbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XG5cbiAgICAgICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XG4gICAgICAgICAgICBzdW0gPSAoKHN1bSB8IDApICsgKGltYWdlc1soaW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSkgfCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChzdW0gfCAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0KGltYWdlUHRyLCB2YWx1ZSkge1xuICAgICAgICBpbWFnZVB0ciA9IGltYWdlUHRyIHwgMDtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSB8IDA7XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG5cbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XG5cbiAgICAgICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgbGVuZ3RoKSB8IDBdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaWxhdGUoaW5JbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcbiAgICAgICAgaW5JbWFnZVB0ciA9IGluSW1hZ2VQdHIgfCAwO1xuICAgICAgICBvdXRJbWFnZVB0ciA9IG91dEltYWdlUHRyIHwgMDtcblxuICAgICAgICB2YXIgdiA9IDAsXG4gICAgICAgICAgICB1ID0gMCxcbiAgICAgICAgICAgIHN1bSA9IDAsXG4gICAgICAgICAgICB5U3RhcnQxID0gMCxcbiAgICAgICAgICAgIHlTdGFydDIgPSAwLFxuICAgICAgICAgICAgeFN0YXJ0MSA9IDAsXG4gICAgICAgICAgICB4U3RhcnQyID0gMCxcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG5cbiAgICAgICAgZm9yICggdiA9IDE7ICh2IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB2ID0gKHYgKyAxKSB8IDApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgKyBzaXplKSB8IDA7XG4gICAgICAgICAgICBmb3IgKCB1ID0gMTsgKHUgfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHUgPSAodSArIDEpIHwgMCkge1xuICAgICAgICAgICAgICAgIHlTdGFydDEgPSAob2Zmc2V0IC0gc2l6ZSkgfCAwO1xuICAgICAgICAgICAgICAgIHlTdGFydDIgPSAob2Zmc2V0ICsgc2l6ZSkgfCAwO1xuICAgICAgICAgICAgICAgIHhTdGFydDEgPSAodSAtIDEpIHwgMDtcbiAgICAgICAgICAgICAgICB4U3RhcnQyID0gKHUgKyAxKSB8IDA7XG4gICAgICAgICAgICAgICAgc3VtID0gKChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDEgKyB4U3RhcnQyKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQxKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MiArIHhTdGFydDIpIHwgMF0gfCAwKSkgfCAwO1xuICAgICAgICAgICAgICAgIGlmICgoc3VtIHwgMCkgPiAoMCB8IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdID0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZW1jcHkoc3JjSW1hZ2VQdHIsIGRzdEltYWdlUHRyKSB7XG4gICAgICAgIHNyY0ltYWdlUHRyID0gc3JjSW1hZ2VQdHIgfCAwO1xuICAgICAgICBkc3RJbWFnZVB0ciA9IGRzdEltYWdlUHRyIHwgMDtcblxuICAgICAgICB2YXIgbGVuZ3RoID0gMDtcblxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcblxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcbiAgICAgICAgICAgIGltYWdlc1soZHN0SW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gPSAoaW1hZ2VzWyhzcmNJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0JvcmRlcihpbWFnZVB0cikge1xuICAgICAgICBpbWFnZVB0ciA9IGltYWdlUHRyIHwgMDtcblxuICAgICAgICB2YXIgeCA9IDAsXG4gICAgICAgICAgICB5ID0gMDtcblxuICAgICAgICBmb3IgKCB4ID0gMDsgKHggfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHggPSAoeCArIDEpIHwgMCkge1xuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIHgpIHwgMF0gPSAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIHkpIHwgMF0gPSAwO1xuICAgICAgICAgICAgeSA9ICgoeSArIHNpemUpIC0gMSkgfCAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIHkpIHwgMF0gPSAwO1xuICAgICAgICAgICAgeSA9ICh5ICsgMSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoIHggPSAwOyAoeCB8IDApIDwgKHNpemUgfCAwKTsgeCA9ICh4ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgeSkgfCAwXSA9IDA7XG4gICAgICAgICAgICB5ID0gKHkgKyAxKSB8IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBza2VsZXRvbml6ZSgpIHtcbiAgICAgICAgdmFyIHN1YkltYWdlUHRyID0gMCxcbiAgICAgICAgICAgIGVyb2RlZEltYWdlUHRyID0gMCxcbiAgICAgICAgICAgIHRlbXBJbWFnZVB0ciA9IDAsXG4gICAgICAgICAgICBza2VsSW1hZ2VQdHIgPSAwLFxuICAgICAgICAgICAgc3VtID0gMCxcbiAgICAgICAgICAgIGRvbmUgPSAwO1xuXG4gICAgICAgIGVyb2RlZEltYWdlUHRyID0gaW11bChzaXplLCBzaXplKSB8IDA7XG4gICAgICAgIHRlbXBJbWFnZVB0ciA9IChlcm9kZWRJbWFnZVB0ciArIGVyb2RlZEltYWdlUHRyKSB8IDA7XG4gICAgICAgIHNrZWxJbWFnZVB0ciA9ICh0ZW1wSW1hZ2VQdHIgKyBlcm9kZWRJbWFnZVB0cikgfCAwO1xuXG4gICAgICAgIC8vIGluaXQgc2tlbC1pbWFnZVxuICAgICAgICBpbml0KHNrZWxJbWFnZVB0ciwgMCk7XG4gICAgICAgIHplcm9Cb3JkZXIoc3ViSW1hZ2VQdHIpO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGVyb2RlKHN1YkltYWdlUHRyLCBlcm9kZWRJbWFnZVB0cik7XG4gICAgICAgICAgICBkaWxhdGUoZXJvZGVkSW1hZ2VQdHIsIHRlbXBJbWFnZVB0cik7XG4gICAgICAgICAgICBzdWJ0cmFjdChzdWJJbWFnZVB0ciwgdGVtcEltYWdlUHRyLCB0ZW1wSW1hZ2VQdHIpO1xuICAgICAgICAgICAgYml0d2lzZU9yKHNrZWxJbWFnZVB0ciwgdGVtcEltYWdlUHRyLCBza2VsSW1hZ2VQdHIpO1xuICAgICAgICAgICAgbWVtY3B5KGVyb2RlZEltYWdlUHRyLCBzdWJJbWFnZVB0cik7XG4gICAgICAgICAgICBzdW0gPSBjb3VudE5vblplcm8oc3ViSW1hZ2VQdHIpIHwgMDtcbiAgICAgICAgICAgIGRvbmUgPSAoKHN1bSB8IDApID09IDAgfCAwKTtcbiAgICAgICAgfSB3aGlsZSAoIWRvbmUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBza2VsZXRvbml6ZTogc2tlbGV0b25pemVcbiAgICB9O1xufVxuLyogQHByZXNlcnZlIEFTTSBFTkQgKi9cbmV4cG9ydCBkZWZhdWx0IFNrZWxldG9uaXplcjtcbi8qIGVzbGludC1lbmFibGUgZXFlcWVxKi9cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9sb2NhdG9yL3NrZWxldG9uaXplci5qcyIsImltcG9ydCBCYXJjb2RlUmVhZGVyIGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5mdW5jdGlvbiBUd29PZkZpdmVSZWFkZXIob3B0cykge1xuICAgIEJhcmNvZGVSZWFkZXIuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICB0aGlzLmJhclNwYWNlUmF0aW8gPSBbMSwgMV07XG59XG5cbnZhciBOID0gMSxcbiAgICBXID0gMyxcbiAgICBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBTVEFSVF9QQVRURVJOOiB7dmFsdWU6IFtXLCBOLCBXLCBOLCBOLCBOXX0sXG4gICAgICAgIFNUT1BfUEFUVEVSTjoge3ZhbHVlOiBbVywgTiwgTiwgTiwgV119LFxuICAgICAgICBDT0RFX1BBVFRFUk46IHt2YWx1ZTogW1xuICAgICAgICAgICAgW04sIE4sIFcsIFcsIE5dLFxuICAgICAgICAgICAgW1csIE4sIE4sIE4sIFddLFxuICAgICAgICAgICAgW04sIFcsIE4sIE4sIFddLFxuICAgICAgICAgICAgW1csIFcsIE4sIE4sIE5dLFxuICAgICAgICAgICAgW04sIE4sIFcsIE4sIFddLFxuICAgICAgICAgICAgW1csIE4sIFcsIE4sIE5dLFxuICAgICAgICAgICAgW04sIFcsIFcsIE4sIE5dLFxuICAgICAgICAgICAgW04sIE4sIE4sIFcsIFddLFxuICAgICAgICAgICAgW1csIE4sIE4sIFcsIE5dLFxuICAgICAgICAgICAgW04sIFcsIE4sIFcsIE5dXG4gICAgICAgIF19LFxuICAgICAgICBTSU5HTEVfQ09ERV9FUlJPUjoge3ZhbHVlOiAwLjc4LCB3cml0YWJsZTogdHJ1ZX0sXG4gICAgICAgIEFWR19DT0RFX0VSUk9SOiB7dmFsdWU6IDAuMzAsIHdyaXRhYmxlOiB0cnVlfSxcbiAgICAgICAgRk9STUFUOiB7dmFsdWU6IFwiMm9mNVwifVxuICAgIH07XG5cbmNvbnN0IHN0YXJ0UGF0dGVybkxlbmd0aCA9IHByb3BlcnRpZXMuU1RBUlRfUEFUVEVSTi52YWx1ZS5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwsIDApO1xuXG5Ud29PZkZpdmVSZWFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXJjb2RlUmVhZGVyLnByb3RvdHlwZSwgcHJvcGVydGllcyk7XG5Ud29PZkZpdmVSZWFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHdvT2ZGaXZlUmVhZGVyO1xuXG5Ud29PZkZpdmVSZWFkZXIucHJvdG90eXBlLl9maW5kUGF0dGVybiA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9mZnNldCwgaXNXaGl0ZSwgdHJ5SGFyZGVyKSB7XG4gICAgdmFyIGNvdW50ZXIgPSBbXSxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIGksXG4gICAgICAgIGNvdW50ZXJQb3MgPSAwLFxuICAgICAgICBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGosXG4gICAgICAgIHN1bSxcbiAgICAgICAgZXBzaWxvbiA9IHNlbGYuQVZHX0NPREVfRVJST1I7XG5cbiAgICBpc1doaXRlID0gaXNXaGl0ZSB8fCBmYWxzZTtcbiAgICB0cnlIYXJkZXIgPSB0cnlIYXJkZXIgfHwgZmFsc2U7XG5cbiAgICBpZiAoIW9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSBzZWxmLl9uZXh0U2V0KHNlbGYuX3Jvdyk7XG4gICAgfVxuXG4gICAgZm9yICggaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvdW50ZXJbaV0gPSAwO1xuICAgIH1cblxuICAgIGZvciAoIGkgPSBvZmZzZXQ7IGkgPCBzZWxmLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGYuX3Jvd1tpXSBeIGlzV2hpdGUpIHtcbiAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoIGogPSAwOyBqIDwgY291bnRlci5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gY291bnRlcltqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBzZWxmLl9tYXRjaFBhdHRlcm4oY291bnRlciwgcGF0dGVybik7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLnN0YXJ0ID0gaSAtIHN1bTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0cnlIYXJkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoIC0gMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDJdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDFdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5Ud29PZkZpdmVSZWFkZXIucHJvdG90eXBlLl9maW5kU3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQsXG4gICAgICAgIG9mZnNldCA9IHNlbGYuX25leHRTZXQoc2VsZi5fcm93KSxcbiAgICAgICAgc3RhcnRJbmZvLFxuICAgICAgICBuYXJyb3dCYXJXaWR0aCA9IDE7XG5cbiAgICB3aGlsZSAoIXN0YXJ0SW5mbykge1xuICAgICAgICBzdGFydEluZm8gPSBzZWxmLl9maW5kUGF0dGVybihzZWxmLlNUQVJUX1BBVFRFUk4sIG9mZnNldCwgZmFsc2UsIHRydWUpO1xuICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbmFycm93QmFyV2lkdGggPSBNYXRoLmZsb29yKChzdGFydEluZm8uZW5kIC0gc3RhcnRJbmZvLnN0YXJ0KSAvIHN0YXJ0UGF0dGVybkxlbmd0aCk7XG4gICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSBzdGFydEluZm8uc3RhcnQgLSBuYXJyb3dCYXJXaWR0aCAqIDU7XG4gICAgICAgIGlmIChsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl9tYXRjaFJhbmdlKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQsIHN0YXJ0SW5mby5zdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9mZnNldCA9IHN0YXJ0SW5mby5lbmQ7XG4gICAgICAgIHN0YXJ0SW5mbyA9IG51bGw7XG4gICAgfVxufTtcblxuVHdvT2ZGaXZlUmVhZGVyLnByb3RvdHlwZS5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlID0gZnVuY3Rpb24oZW5kSW5mbykge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kO1xuXG4gICAgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyKTtcbiAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgc2VsZi5fcm93Lmxlbmd0aCkge1xuICAgICAgICBpZiAoc2VsZi5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5Ud29PZkZpdmVSZWFkZXIucHJvdG90eXBlLl9maW5kRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBlbmRJbmZvLFxuICAgICAgICB0bXAsXG4gICAgICAgIG9mZnNldDtcblxuICAgIHNlbGYuX3Jvdy5yZXZlcnNlKCk7XG4gICAgb2Zmc2V0ID0gc2VsZi5fbmV4dFNldChzZWxmLl9yb3cpO1xuICAgIGVuZEluZm8gPSBzZWxmLl9maW5kUGF0dGVybihzZWxmLlNUT1BfUEFUVEVSTiwgb2Zmc2V0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgc2VsZi5fcm93LnJldmVyc2UoKTtcblxuICAgIGlmIChlbmRJbmZvID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIHJldmVyc2UgbnVtYmVyc1xuICAgIHRtcCA9IGVuZEluZm8uc3RhcnQ7XG4gICAgZW5kSW5mby5zdGFydCA9IHNlbGYuX3Jvdy5sZW5ndGggLSBlbmRJbmZvLmVuZDtcbiAgICBlbmRJbmZvLmVuZCA9IHNlbGYuX3Jvdy5sZW5ndGggLSB0bXA7XG5cbiAgICByZXR1cm4gZW5kSW5mbyAhPT0gbnVsbCA/IHNlbGYuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvKSA6IG51bGw7XG59O1xuXG5Ud29PZkZpdmVSZWFkZXIucHJvdG90eXBlLl9kZWNvZGVDb2RlID0gZnVuY3Rpb24oY291bnRlcikge1xuICAgIHZhciBqLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgc3VtID0gMCxcbiAgICAgICAgbm9ybWFsaXplZCxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGVwc2lsb24gPSBzZWxmLkFWR19DT0RFX0VSUk9SLFxuICAgICAgICBjb2RlLFxuICAgICAgICBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDBcbiAgICAgICAgfTtcblxuICAgIGZvciAoIGogPSAwOyBqIDwgY291bnRlci5sZW5ndGg7IGorKykge1xuICAgICAgICBzdW0gKz0gY291bnRlcltqXTtcbiAgICB9XG4gICAgZm9yIChjb2RlID0gMDsgY29kZSA8IHNlbGYuQ09ERV9QQVRURVJOLmxlbmd0aDsgY29kZSsrKSB7XG4gICAgICAgIGVycm9yID0gc2VsZi5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHNlbGYuQ09ERV9QQVRURVJOW2NvZGVdKTtcbiAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yKSB7XG4gICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XG4gICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmVzdE1hdGNoLmVycm9yIDwgZXBzaWxvbikge1xuICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgIH1cbn07XG5cblR3b09mRml2ZVJlYWRlci5wcm90b3R5cGUuX2RlY29kZVBheWxvYWQgPSBmdW5jdGlvbihjb3VudGVycywgcmVzdWx0LCBkZWNvZGVkQ29kZXMpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIHBvcyA9IDAsXG4gICAgICAgIGNvdW50ZXJMZW5ndGggPSBjb3VudGVycy5sZW5ndGgsXG4gICAgICAgIGNvdW50ZXIgPSBbMCwgMCwgMCwgMCwgMF0sXG4gICAgICAgIGNvZGU7XG5cbiAgICB3aGlsZSAocG9zIDwgY291bnRlckxlbmd0aCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudGVyW2ldID0gY291bnRlcnNbcG9zXSAqIHRoaXMuYmFyU3BhY2VSYXRpb1swXTtcbiAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGNvZGUgPSBzZWxmLl9kZWNvZGVDb2RlKGNvdW50ZXIpO1xuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKGNvZGUuY29kZSArIFwiXCIpO1xuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGU7XG59O1xuXG5Ud29PZkZpdmVSZWFkZXIucHJvdG90eXBlLl92ZXJpZnlDb3VudGVyTGVuZ3RoID0gZnVuY3Rpb24oY291bnRlcnMpIHtcbiAgICByZXR1cm4gKGNvdW50ZXJzLmxlbmd0aCAlIDEwID09PSAwKTtcbn07XG5cblR3b09mRml2ZVJlYWRlci5wcm90b3R5cGUuX2RlY29kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFydEluZm8sXG4gICAgICAgIGVuZEluZm8sXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBjb2RlLFxuICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgZGVjb2RlZENvZGVzID0gW10sXG4gICAgICAgIGNvdW50ZXJzO1xuXG4gICAgc3RhcnRJbmZvID0gc2VsZi5fZmluZFN0YXJ0KCk7XG4gICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRlY29kZWRDb2Rlcy5wdXNoKHN0YXJ0SW5mbyk7XG5cbiAgICBlbmRJbmZvID0gc2VsZi5fZmluZEVuZCgpO1xuICAgIGlmICghZW5kSW5mbykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb3VudGVycyA9IHNlbGYuX2ZpbGxDb3VudGVycyhzdGFydEluZm8uZW5kLCBlbmRJbmZvLnN0YXJ0LCBmYWxzZSk7XG4gICAgaWYgKCFzZWxmLl92ZXJpZnlDb3VudGVyTGVuZ3RoKGNvdW50ZXJzKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29kZSA9IHNlbGYuX2RlY29kZVBheWxvYWQoY291bnRlcnMsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcbiAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChyZXN1bHQubGVuZ3RoIDwgNSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBkZWNvZGVkQ29kZXMucHVzaChlbmRJbmZvKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiByZXN1bHQuam9pbihcIlwiKSxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgZW5kOiBlbmRJbmZvLmVuZCxcbiAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8sXG4gICAgICAgIGRlY29kZWRDb2RlczogZGVjb2RlZENvZGVzXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFR3b09mRml2ZVJlYWRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZWFkZXIvMm9mNV9yZWFkZXIuanMiLCJpbXBvcnQgQmFyY29kZVJlYWRlciBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuZnVuY3Rpb24gQ29kYWJhclJlYWRlcigpIHtcbiAgICBCYXJjb2RlUmVhZGVyLmNhbGwodGhpcyk7XG4gICAgdGhpcy5fY291bnRlcnMgPSBbXTtcbn1cblxudmFyIHByb3BlcnRpZXMgPSB7XG4gICAgQUxQSEFCRVRIX1NUUklORzoge3ZhbHVlOiBcIjAxMjM0NTY3ODktJDovLitBQkNEXCJ9LFxuICAgIEFMUEhBQkVUOiB7dmFsdWU6IFs0OCwgNDksIDUwLCA1MSwgNTIsIDUzLCA1NCwgNTUsIDU2LCA1NywgNDUsIDM2LCA1OCwgNDcsIDQ2LCA0MywgNjUsIDY2LCA2NywgNjhdfSxcbiAgICBDSEFSQUNURVJfRU5DT0RJTkdTOiB7dmFsdWU6IFsweDAwMywgMHgwMDYsIDB4MDA5LCAweDA2MCwgMHgwMTIsIDB4MDQyLCAweDAyMSwgMHgwMjQsIDB4MDMwLCAweDA0OCwgMHgwMGMsIDB4MDE4LFxuICAgICAgICAweDA0NSwgMHgwNTEsIDB4MDU0LCAweDAxNSwgMHgwMUEsIDB4MDI5LCAweDAwQiwgMHgwMEVdfSxcbiAgICBTVEFSVF9FTkQ6IHt2YWx1ZTogWzB4MDFBLCAweDAyOSwgMHgwMEIsIDB4MDBFXX0sXG4gICAgTUlOX0VOQ09ERURfQ0hBUlM6IHt2YWx1ZTogNH0sXG4gICAgTUFYX0FDQ0VQVEFCTEU6IHt2YWx1ZTogMi4wfSxcbiAgICBQQURESU5HOiB7dmFsdWU6IDEuNX0sXG4gICAgRk9STUFUOiB7dmFsdWU6IFwiY29kYWJhclwiLCB3cml0ZWFibGU6IGZhbHNlfVxufTtcblxuQ29kYWJhclJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhcmNvZGVSZWFkZXIucHJvdG90eXBlLCBwcm9wZXJ0aWVzKTtcbkNvZGFiYXJSZWFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29kYWJhclJlYWRlcjtcblxuQ29kYWJhclJlYWRlci5wcm90b3R5cGUuX2RlY29kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBkZWNvZGVkQ2hhcixcbiAgICAgICAgcGF0dGVybixcbiAgICAgICAgbmV4dFN0YXJ0LFxuICAgICAgICBlbmQ7XG5cbiAgICB0aGlzLl9jb3VudGVycyA9IHNlbGYuX2ZpbGxDb3VudGVycygpO1xuICAgIHN0YXJ0ID0gc2VsZi5fZmluZFN0YXJ0KCk7XG4gICAgaWYgKCFzdGFydCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbmV4dFN0YXJ0ID0gc3RhcnQuc3RhcnRDb3VudGVyO1xuXG4gICAgZG8ge1xuICAgICAgICBwYXR0ZXJuID0gc2VsZi5fdG9QYXR0ZXJuKG5leHRTdGFydCk7XG4gICAgICAgIGlmIChwYXR0ZXJuIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlZENoYXIgPSBzZWxmLl9wYXR0ZXJuVG9DaGFyKHBhdHRlcm4pO1xuICAgICAgICBpZiAoZGVjb2RlZENoYXIgPCAwKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcbiAgICAgICAgbmV4dFN0YXJ0ICs9IDg7XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMSAmJiBzZWxmLl9pc1N0YXJ0RW5kKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKG5leHRTdGFydCA8IHNlbGYuX2NvdW50ZXJzLmxlbmd0aCk7XG5cbiAgICAvLyB2ZXJpZnkgZW5kXG4gICAgaWYgKChyZXN1bHQubGVuZ3RoIC0gMikgPCBzZWxmLk1JTl9FTkNPREVEX0NIQVJTIHx8ICFzZWxmLl9pc1N0YXJ0RW5kKHBhdHRlcm4pKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIHZlcmlmeSBlbmQgd2hpdGUgc3BhY2VcbiAgICBpZiAoIXNlbGYuX3ZlcmlmeVdoaXRlc3BhY2Uoc3RhcnQuc3RhcnRDb3VudGVyLCBuZXh0U3RhcnQgLSA4KSl7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghc2VsZi5fdmFsaWRhdGVSZXN1bHQocmVzdWx0LCBzdGFydC5zdGFydENvdW50ZXIpKXtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbmV4dFN0YXJ0ID0gbmV4dFN0YXJ0ID4gc2VsZi5fY291bnRlcnMubGVuZ3RoID8gc2VsZi5fY291bnRlcnMubGVuZ3RoIDogbmV4dFN0YXJ0O1xuICAgIGVuZCA9IHN0YXJ0LnN0YXJ0ICsgc2VsZi5fc3VtQ291bnRlcnMoc3RhcnQuc3RhcnRDb3VudGVyLCBuZXh0U3RhcnQgLSA4KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKFwiXCIpLFxuICAgICAgICBzdGFydDogc3RhcnQuc3RhcnQsXG4gICAgICAgIGVuZDogZW5kLFxuICAgICAgICBzdGFydEluZm86IHN0YXJ0LFxuICAgICAgICBkZWNvZGVkQ29kZXM6IHJlc3VsdFxuICAgIH07XG59O1xuXG5Db2RhYmFyUmVhZGVyLnByb3RvdHlwZS5fdmVyaWZ5V2hpdGVzcGFjZSA9IGZ1bmN0aW9uKHN0YXJ0Q291bnRlciwgZW5kQ291bnRlcikge1xuICAgIGlmICgoc3RhcnRDb3VudGVyIC0gMSA8PSAwKVxuICAgICAgICAgICAgfHwgdGhpcy5fY291bnRlcnNbc3RhcnRDb3VudGVyIC0gMV0gPj0gKHRoaXMuX2NhbGN1bGF0ZVBhdHRlcm5MZW5ndGgoc3RhcnRDb3VudGVyKSAvIDIuMCkpIHtcbiAgICAgICAgaWYgKChlbmRDb3VudGVyICsgOCA+PSB0aGlzLl9jb3VudGVycy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5fY291bnRlcnNbZW5kQ291bnRlciArIDddID49ICh0aGlzLl9jYWxjdWxhdGVQYXR0ZXJuTGVuZ3RoKGVuZENvdW50ZXIpIC8gMi4wKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuQ29kYWJhclJlYWRlci5wcm90b3R5cGUuX2NhbGN1bGF0ZVBhdHRlcm5MZW5ndGggPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgc3VtID0gMDtcblxuICAgIGZvciAoaSA9IG9mZnNldDsgaSA8IG9mZnNldCArIDc7IGkrKykge1xuICAgICAgICBzdW0gKz0gdGhpcy5fY291bnRlcnNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1bTtcbn07XG5cbkNvZGFiYXJSZWFkZXIucHJvdG90eXBlLl90aHJlc2hvbGRSZXN1bHRQYXR0ZXJuID0gZnVuY3Rpb24ocmVzdWx0LCBzdGFydENvdW50ZXIpe1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgY2F0ZWdvcml6YXRpb24gPSB7XG4gICAgICAgICAgICBzcGFjZToge1xuICAgICAgICAgICAgICAgIG5hcnJvdzogeyBzaXplOiAwLCBjb3VudHM6IDAsIG1pbjogMCwgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFfSxcbiAgICAgICAgICAgICAgICB3aWRlOiB7c2l6ZTogMCwgY291bnRzOiAwLCBtaW46IDAsIG1heDogTnVtYmVyLk1BWF9WQUxVRX1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYXI6IHtcbiAgICAgICAgICAgICAgICBuYXJyb3c6IHsgc2l6ZTogMCwgY291bnRzOiAwLCBtaW46IDAsIG1heDogTnVtYmVyLk1BWF9WQUxVRX0sXG4gICAgICAgICAgICAgICAgd2lkZTogeyBzaXplOiAwLCBjb3VudHM6IDAsIG1pbjogMCwgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBraW5kLFxuICAgICAgICBjYXQsXG4gICAgICAgIGksXG4gICAgICAgIGosXG4gICAgICAgIHBvcyA9IHN0YXJ0Q291bnRlcixcbiAgICAgICAgcGF0dGVybjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspe1xuICAgICAgICBwYXR0ZXJuID0gc2VsZi5fY2hhclRvUGF0dGVybihyZXN1bHRbaV0pO1xuICAgICAgICBmb3IgKGogPSA2OyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAga2luZCA9IChqICYgMSkgPT09IDIgPyBjYXRlZ29yaXphdGlvbi5iYXIgOiBjYXRlZ29yaXphdGlvbi5zcGFjZTtcbiAgICAgICAgICAgIGNhdCA9IChwYXR0ZXJuICYgMSkgPT09IDEgPyBraW5kLndpZGUgOiBraW5kLm5hcnJvdztcbiAgICAgICAgICAgIGNhdC5zaXplICs9IHNlbGYuX2NvdW50ZXJzW3BvcyArIGpdO1xuICAgICAgICAgICAgY2F0LmNvdW50cysrO1xuICAgICAgICAgICAgcGF0dGVybiA+Pj0gMTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gODtcbiAgICB9XG5cbiAgICBbXCJzcGFjZVwiLCBcImJhclwiXS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgbmV3a2luZCA9IGNhdGVnb3JpemF0aW9uW2tleV07XG4gICAgICAgIG5ld2tpbmQud2lkZS5taW4gPVxuICAgICAgICAgICAgTWF0aC5mbG9vcigobmV3a2luZC5uYXJyb3cuc2l6ZSAvIG5ld2tpbmQubmFycm93LmNvdW50cyArIG5ld2tpbmQud2lkZS5zaXplIC8gbmV3a2luZC53aWRlLmNvdW50cykgLyAyKTtcbiAgICAgICAgbmV3a2luZC5uYXJyb3cubWF4ID0gTWF0aC5jZWlsKG5ld2tpbmQud2lkZS5taW4pO1xuICAgICAgICBuZXdraW5kLndpZGUubWF4ID0gTWF0aC5jZWlsKChuZXdraW5kLndpZGUuc2l6ZSAqIHNlbGYuTUFYX0FDQ0VQVEFCTEUgKyBzZWxmLlBBRERJTkcpIC8gbmV3a2luZC53aWRlLmNvdW50cyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2F0ZWdvcml6YXRpb247XG59O1xuXG5Db2RhYmFyUmVhZGVyLnByb3RvdHlwZS5fY2hhclRvUGF0dGVybiA9IGZ1bmN0aW9uKGNoYXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGNoYXJDb2RlID0gY2hhci5jaGFyQ29kZUF0KDApLFxuICAgICAgICBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNlbGYuQUxQSEFCRVQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGYuQUxQSEFCRVRbaV0gPT09IGNoYXJDb2RlKXtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLkNIQVJBQ1RFUl9FTkNPRElOR1NbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDB4MDtcbn07XG5cbkNvZGFiYXJSZWFkZXIucHJvdG90eXBlLl92YWxpZGF0ZVJlc3VsdCA9IGZ1bmN0aW9uKHJlc3VsdCwgc3RhcnRDb3VudGVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICB0aHJlc2hvbGRzID0gc2VsZi5fdGhyZXNob2xkUmVzdWx0UGF0dGVybihyZXN1bHQsIHN0YXJ0Q291bnRlciksXG4gICAgICAgIGksXG4gICAgICAgIGosXG4gICAgICAgIGtpbmQsXG4gICAgICAgIGNhdCxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgcG9zID0gc3RhcnRDb3VudGVyLFxuICAgICAgICBwYXR0ZXJuO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXR0ZXJuID0gc2VsZi5fY2hhclRvUGF0dGVybihyZXN1bHRbaV0pO1xuICAgICAgICBmb3IgKGogPSA2OyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAga2luZCA9IChqICYgMSkgPT09IDAgPyB0aHJlc2hvbGRzLmJhciA6IHRocmVzaG9sZHMuc3BhY2U7XG4gICAgICAgICAgICBjYXQgPSAocGF0dGVybiAmIDEpID09PSAxID8ga2luZC53aWRlIDoga2luZC5uYXJyb3c7XG4gICAgICAgICAgICBzaXplID0gc2VsZi5fY291bnRlcnNbcG9zICsgal07XG4gICAgICAgICAgICBpZiAoc2l6ZSA8IGNhdC5taW4gfHwgc2l6ZSA+IGNhdC5tYXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXR0ZXJuID4+PSAxO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSA4O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbkNvZGFiYXJSZWFkZXIucHJvdG90eXBlLl9wYXR0ZXJuVG9DaGFyID0gZnVuY3Rpb24ocGF0dGVybikge1xuICAgIHZhciBpLFxuICAgICAgICBzZWxmID0gdGhpcztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzZWxmLkNIQVJBQ1RFUl9FTkNPRElOR1MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGYuQ0hBUkFDVEVSX0VOQ09ESU5HU1tpXSA9PT0gcGF0dGVybikge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoc2VsZi5BTFBIQUJFVFtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcblxuQ29kYWJhclJlYWRlci5wcm90b3R5cGUuX2NvbXB1dGVBbHRlcm5hdGluZ1RocmVzaG9sZCA9IGZ1bmN0aW9uKG9mZnNldCwgZW5kKSB7XG4gICAgdmFyIGksXG4gICAgICAgIG1pbiA9IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgIG1heCA9IDAsXG4gICAgICAgIGNvdW50ZXI7XG5cbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBlbmQ7IGkgKz0gMil7XG4gICAgICAgIGNvdW50ZXIgPSB0aGlzLl9jb3VudGVyc1tpXTtcbiAgICAgICAgaWYgKGNvdW50ZXIgPiBtYXgpIHtcbiAgICAgICAgICAgIG1heCA9IGNvdW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50ZXIgPCBtaW4pIHtcbiAgICAgICAgICAgIG1pbiA9IGNvdW50ZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKChtaW4gKyBtYXgpIC8gMi4wKSB8IDA7XG59O1xuXG5Db2RhYmFyUmVhZGVyLnByb3RvdHlwZS5fdG9QYXR0ZXJuID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgdmFyIG51bUNvdW50ZXJzID0gNyxcbiAgICAgICAgZW5kID0gb2Zmc2V0ICsgbnVtQ291bnRlcnMsXG4gICAgICAgIGJhclRocmVzaG9sZCxcbiAgICAgICAgc3BhY2VUaHJlc2hvbGQsXG4gICAgICAgIGJpdG1hc2sgPSAxIDw8IChudW1Db3VudGVycyAtIDEpLFxuICAgICAgICBwYXR0ZXJuID0gMCxcbiAgICAgICAgaSxcbiAgICAgICAgdGhyZXNob2xkO1xuXG4gICAgaWYgKGVuZCA+IHRoaXMuX2NvdW50ZXJzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgYmFyVGhyZXNob2xkID0gdGhpcy5fY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkKG9mZnNldCwgZW5kKTtcbiAgICBzcGFjZVRocmVzaG9sZCA9IHRoaXMuX2NvbXB1dGVBbHRlcm5hdGluZ1RocmVzaG9sZChvZmZzZXQgKyAxLCBlbmQpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG51bUNvdW50ZXJzOyBpKyspe1xuICAgICAgICB0aHJlc2hvbGQgPSAoaSAmIDEpID09PSAwID8gYmFyVGhyZXNob2xkIDogc3BhY2VUaHJlc2hvbGQ7XG4gICAgICAgIGlmICh0aGlzLl9jb3VudGVyc1tvZmZzZXQgKyBpXSA+IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgcGF0dGVybiB8PSBiaXRtYXNrO1xuICAgICAgICB9XG4gICAgICAgIGJpdG1hc2sgPj49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdHRlcm47XG59O1xuXG5Db2RhYmFyUmVhZGVyLnByb3RvdHlwZS5faXNTdGFydEVuZCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLlNUQVJUX0VORC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5TVEFSVF9FTkRbaV0gPT09IHBhdHRlcm4pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbkNvZGFiYXJSZWFkZXIucHJvdG90eXBlLl9zdW1Db3VudGVycyA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgc3VtID0gMDtcblxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgc3VtICs9IHRoaXMuX2NvdW50ZXJzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufTtcblxuQ29kYWJhclJlYWRlci5wcm90b3R5cGUuX2ZpbmRTdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgaSxcbiAgICAgICAgcGF0dGVybixcbiAgICAgICAgc3RhcnQgPSBzZWxmLl9uZXh0VW5zZXQoc2VsZi5fcm93KSxcbiAgICAgICAgZW5kO1xuXG4gICAgZm9yIChpID0gMTsgaSA8IHRoaXMuX2NvdW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhdHRlcm4gPSBzZWxmLl90b1BhdHRlcm4oaSk7XG4gICAgICAgIGlmIChwYXR0ZXJuICE9PSAtMSAmJiBzZWxmLl9pc1N0YXJ0RW5kKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBMb29rIGZvciB3aGl0ZXNwYWNlIGFoZWFkXG4gICAgICAgICAgICBzdGFydCArPSBzZWxmLl9zdW1Db3VudGVycygwLCBpKTtcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0ICsgc2VsZi5fc3VtQ291bnRlcnMoaSwgaSArIDgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICAgICAgc3RhcnRDb3VudGVyOiBpLFxuICAgICAgICAgICAgICAgIGVuZENvdW50ZXI6IGkgKyA4XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQ29kYWJhclJlYWRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZWFkZXIvY29kYWJhcl9yZWFkZXIuanMiLCJpbXBvcnQgQmFyY29kZVJlYWRlciBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuZnVuY3Rpb24gQ29kZTEyOFJlYWRlcigpIHtcbiAgICBCYXJjb2RlUmVhZGVyLmNhbGwodGhpcyk7XG59XG5cbnZhciBwcm9wZXJ0aWVzID0ge1xuICAgIENPREVfU0hJRlQ6IHt2YWx1ZTogOTh9LFxuICAgIENPREVfQzoge3ZhbHVlOiA5OX0sXG4gICAgQ09ERV9COiB7dmFsdWU6IDEwMH0sXG4gICAgQ09ERV9BOiB7dmFsdWU6IDEwMX0sXG4gICAgU1RBUlRfQ09ERV9BOiB7dmFsdWU6IDEwM30sXG4gICAgU1RBUlRfQ09ERV9COiB7dmFsdWU6IDEwNH0sXG4gICAgU1RBUlRfQ09ERV9DOiB7dmFsdWU6IDEwNX0sXG4gICAgU1RPUF9DT0RFOiB7dmFsdWU6IDEwNn0sXG4gICAgQ09ERV9QQVRURVJOOiB7dmFsdWU6IFtcbiAgICAgICAgWzIsIDEsIDIsIDIsIDIsIDJdLFxuICAgICAgICBbMiwgMiwgMiwgMSwgMiwgMl0sXG4gICAgICAgIFsyLCAyLCAyLCAyLCAyLCAxXSxcbiAgICAgICAgWzEsIDIsIDEsIDIsIDIsIDNdLFxuICAgICAgICBbMSwgMiwgMSwgMywgMiwgMl0sXG4gICAgICAgIFsxLCAzLCAxLCAyLCAyLCAyXSxcbiAgICAgICAgWzEsIDIsIDIsIDIsIDEsIDNdLFxuICAgICAgICBbMSwgMiwgMiwgMywgMSwgMl0sXG4gICAgICAgIFsxLCAzLCAyLCAyLCAxLCAyXSxcbiAgICAgICAgWzIsIDIsIDEsIDIsIDEsIDNdLFxuICAgICAgICBbMiwgMiwgMSwgMywgMSwgMl0sXG4gICAgICAgIFsyLCAzLCAxLCAyLCAxLCAyXSxcbiAgICAgICAgWzEsIDEsIDIsIDIsIDMsIDJdLFxuICAgICAgICBbMSwgMiwgMiwgMSwgMywgMl0sXG4gICAgICAgIFsxLCAyLCAyLCAyLCAzLCAxXSxcbiAgICAgICAgWzEsIDEsIDMsIDIsIDIsIDJdLFxuICAgICAgICBbMSwgMiwgMywgMSwgMiwgMl0sXG4gICAgICAgIFsxLCAyLCAzLCAyLCAyLCAxXSxcbiAgICAgICAgWzIsIDIsIDMsIDIsIDEsIDFdLFxuICAgICAgICBbMiwgMiwgMSwgMSwgMywgMl0sXG4gICAgICAgIFsyLCAyLCAxLCAyLCAzLCAxXSxcbiAgICAgICAgWzIsIDEsIDMsIDIsIDEsIDJdLFxuICAgICAgICBbMiwgMiwgMywgMSwgMSwgMl0sXG4gICAgICAgIFszLCAxLCAyLCAxLCAzLCAxXSxcbiAgICAgICAgWzMsIDEsIDEsIDIsIDIsIDJdLFxuICAgICAgICBbMywgMiwgMSwgMSwgMiwgMl0sXG4gICAgICAgIFszLCAyLCAxLCAyLCAyLCAxXSxcbiAgICAgICAgWzMsIDEsIDIsIDIsIDEsIDJdLFxuICAgICAgICBbMywgMiwgMiwgMSwgMSwgMl0sXG4gICAgICAgIFszLCAyLCAyLCAyLCAxLCAxXSxcbiAgICAgICAgWzIsIDEsIDIsIDEsIDIsIDNdLFxuICAgICAgICBbMiwgMSwgMiwgMywgMiwgMV0sXG4gICAgICAgIFsyLCAzLCAyLCAxLCAyLCAxXSxcbiAgICAgICAgWzEsIDEsIDEsIDMsIDIsIDNdLFxuICAgICAgICBbMSwgMywgMSwgMSwgMiwgM10sXG4gICAgICAgIFsxLCAzLCAxLCAzLCAyLCAxXSxcbiAgICAgICAgWzEsIDEsIDIsIDMsIDEsIDNdLFxuICAgICAgICBbMSwgMywgMiwgMSwgMSwgM10sXG4gICAgICAgIFsxLCAzLCAyLCAzLCAxLCAxXSxcbiAgICAgICAgWzIsIDEsIDEsIDMsIDEsIDNdLFxuICAgICAgICBbMiwgMywgMSwgMSwgMSwgM10sXG4gICAgICAgIFsyLCAzLCAxLCAzLCAxLCAxXSxcbiAgICAgICAgWzEsIDEsIDIsIDEsIDMsIDNdLFxuICAgICAgICBbMSwgMSwgMiwgMywgMywgMV0sXG4gICAgICAgIFsxLCAzLCAyLCAxLCAzLCAxXSxcbiAgICAgICAgWzEsIDEsIDMsIDEsIDIsIDNdLFxuICAgICAgICBbMSwgMSwgMywgMywgMiwgMV0sXG4gICAgICAgIFsxLCAzLCAzLCAxLCAyLCAxXSxcbiAgICAgICAgWzMsIDEsIDMsIDEsIDIsIDFdLFxuICAgICAgICBbMiwgMSwgMSwgMywgMywgMV0sXG4gICAgICAgIFsyLCAzLCAxLCAxLCAzLCAxXSxcbiAgICAgICAgWzIsIDEsIDMsIDEsIDEsIDNdLFxuICAgICAgICBbMiwgMSwgMywgMywgMSwgMV0sXG4gICAgICAgIFsyLCAxLCAzLCAxLCAzLCAxXSxcbiAgICAgICAgWzMsIDEsIDEsIDEsIDIsIDNdLFxuICAgICAgICBbMywgMSwgMSwgMywgMiwgMV0sXG4gICAgICAgIFszLCAzLCAxLCAxLCAyLCAxXSxcbiAgICAgICAgWzMsIDEsIDIsIDEsIDEsIDNdLFxuICAgICAgICBbMywgMSwgMiwgMywgMSwgMV0sXG4gICAgICAgIFszLCAzLCAyLCAxLCAxLCAxXSxcbiAgICAgICAgWzMsIDEsIDQsIDEsIDEsIDFdLFxuICAgICAgICBbMiwgMiwgMSwgNCwgMSwgMV0sXG4gICAgICAgIFs0LCAzLCAxLCAxLCAxLCAxXSxcbiAgICAgICAgWzEsIDEsIDEsIDIsIDIsIDRdLFxuICAgICAgICBbMSwgMSwgMSwgNCwgMiwgMl0sXG4gICAgICAgIFsxLCAyLCAxLCAxLCAyLCA0XSxcbiAgICAgICAgWzEsIDIsIDEsIDQsIDIsIDFdLFxuICAgICAgICBbMSwgNCwgMSwgMSwgMiwgMl0sXG4gICAgICAgIFsxLCA0LCAxLCAyLCAyLCAxXSxcbiAgICAgICAgWzEsIDEsIDIsIDIsIDEsIDRdLFxuICAgICAgICBbMSwgMSwgMiwgNCwgMSwgMl0sXG4gICAgICAgIFsxLCAyLCAyLCAxLCAxLCA0XSxcbiAgICAgICAgWzEsIDIsIDIsIDQsIDEsIDFdLFxuICAgICAgICBbMSwgNCwgMiwgMSwgMSwgMl0sXG4gICAgICAgIFsxLCA0LCAyLCAyLCAxLCAxXSxcbiAgICAgICAgWzIsIDQsIDEsIDIsIDEsIDFdLFxuICAgICAgICBbMiwgMiwgMSwgMSwgMSwgNF0sXG4gICAgICAgIFs0LCAxLCAzLCAxLCAxLCAxXSxcbiAgICAgICAgWzIsIDQsIDEsIDEsIDEsIDJdLFxuICAgICAgICBbMSwgMywgNCwgMSwgMSwgMV0sXG4gICAgICAgIFsxLCAxLCAxLCAyLCA0LCAyXSxcbiAgICAgICAgWzEsIDIsIDEsIDEsIDQsIDJdLFxuICAgICAgICBbMSwgMiwgMSwgMiwgNCwgMV0sXG4gICAgICAgIFsxLCAxLCA0LCAyLCAxLCAyXSxcbiAgICAgICAgWzEsIDIsIDQsIDEsIDEsIDJdLFxuICAgICAgICBbMSwgMiwgNCwgMiwgMSwgMV0sXG4gICAgICAgIFs0LCAxLCAxLCAyLCAxLCAyXSxcbiAgICAgICAgWzQsIDIsIDEsIDEsIDEsIDJdLFxuICAgICAgICBbNCwgMiwgMSwgMiwgMSwgMV0sXG4gICAgICAgIFsyLCAxLCAyLCAxLCA0LCAxXSxcbiAgICAgICAgWzIsIDEsIDQsIDEsIDIsIDFdLFxuICAgICAgICBbNCwgMSwgMiwgMSwgMiwgMV0sXG4gICAgICAgIFsxLCAxLCAxLCAxLCA0LCAzXSxcbiAgICAgICAgWzEsIDEsIDEsIDMsIDQsIDFdLFxuICAgICAgICBbMSwgMywgMSwgMSwgNCwgMV0sXG4gICAgICAgIFsxLCAxLCA0LCAxLCAxLCAzXSxcbiAgICAgICAgWzEsIDEsIDQsIDMsIDEsIDFdLFxuICAgICAgICBbNCwgMSwgMSwgMSwgMSwgM10sXG4gICAgICAgIFs0LCAxLCAxLCAzLCAxLCAxXSxcbiAgICAgICAgWzEsIDEsIDMsIDEsIDQsIDFdLFxuICAgICAgICBbMSwgMSwgNCwgMSwgMywgMV0sXG4gICAgICAgIFszLCAxLCAxLCAxLCA0LCAxXSxcbiAgICAgICAgWzQsIDEsIDEsIDEsIDMsIDFdLFxuICAgICAgICBbMiwgMSwgMSwgNCwgMSwgMl0sXG4gICAgICAgIFsyLCAxLCAxLCAyLCAxLCA0XSxcbiAgICAgICAgWzIsIDEsIDEsIDIsIDMsIDJdLFxuICAgICAgICBbMiwgMywgMywgMSwgMSwgMSwgMl1cbiAgICBdfSxcbiAgICBTSU5HTEVfQ09ERV9FUlJPUjoge3ZhbHVlOiAwLjY0fSxcbiAgICBBVkdfQ09ERV9FUlJPUjoge3ZhbHVlOiAwLjMwfSxcbiAgICBGT1JNQVQ6IHt2YWx1ZTogXCJjb2RlXzEyOFwiLCB3cml0ZWFibGU6IGZhbHNlfSxcbiAgICBNT0RVTEVfSU5ESUNFUzoge3ZhbHVlOiB7YmFyOiBbMCwgMiwgNF0sIHNwYWNlOiBbMSwgMywgNV19fVxufTtcblxuQ29kZTEyOFJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhcmNvZGVSZWFkZXIucHJvdG90eXBlLCBwcm9wZXJ0aWVzKTtcbkNvZGUxMjhSZWFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29kZTEyOFJlYWRlcjtcblxuQ29kZTEyOFJlYWRlci5wcm90b3R5cGUuX2RlY29kZUNvZGUgPSBmdW5jdGlvbihzdGFydCwgY29ycmVjdGlvbikge1xuICAgIHZhciBjb3VudGVyID0gWzAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgICBpLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgb2Zmc2V0ID0gc3RhcnQsXG4gICAgICAgIGlzV2hpdGUgPSAhc2VsZi5fcm93W29mZnNldF0sXG4gICAgICAgIGNvdW50ZXJQb3MgPSAwLFxuICAgICAgICBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBzdGFydCxcbiAgICAgICAgICAgIGNvcnJlY3Rpb246IHtcbiAgICAgICAgICAgICAgICBiYXI6IDEsXG4gICAgICAgICAgICAgICAgc3BhY2U6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29kZSxcbiAgICAgICAgZXJyb3I7XG5cbiAgICBmb3IgKCBpID0gb2Zmc2V0OyBpIDwgc2VsZi5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmLl9yb3dbaV0gXiBpc1doaXRlKSB7XG4gICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvcnJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fY29ycmVjdChjb3VudGVyLCBjb3JyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb2RlID0gMDsgY29kZSA8IHNlbGYuQ09ERV9QQVRURVJOLmxlbmd0aDsgY29kZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gc2VsZi5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHNlbGYuQ09ERV9QQVRURVJOW2NvZGVdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICBpZiAoYmVzdE1hdGNoLmNvZGUgPT09IC0xIHx8IGJlc3RNYXRjaC5lcnJvciA+IHNlbGYuQVZHX0NPREVfRVJST1IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvcnJlY3Rpb24uYmFyID0gY2FsY3VsYXRlQ29ycmVjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSwgY291bnRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTU9EVUxFX0lORElDRVMuYmFyKTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvcnJlY3Rpb24uc3BhY2UgPSBjYWxjdWxhdGVDb3JyZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5zcGFjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuQ29kZTEyOFJlYWRlci5wcm90b3R5cGUuX2NvcnJlY3QgPSBmdW5jdGlvbihjb3VudGVyLCBjb3JyZWN0aW9uKSB7XG4gICAgdGhpcy5fY29ycmVjdEJhcnMoY291bnRlciwgY29ycmVjdGlvbi5iYXIsIHRoaXMuTU9EVUxFX0lORElDRVMuYmFyKTtcbiAgICB0aGlzLl9jb3JyZWN0QmFycyhjb3VudGVyLCBjb3JyZWN0aW9uLnNwYWNlLCB0aGlzLk1PRFVMRV9JTkRJQ0VTLnNwYWNlKTtcbn07XG5cbkNvZGUxMjhSZWFkZXIucHJvdG90eXBlLl9maW5kU3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY291bnRlciA9IFswLCAwLCAwLCAwLCAwLCAwXSxcbiAgICAgICAgaSxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIG9mZnNldCA9IHNlbGYuX25leHRTZXQoc2VsZi5fcm93KSxcbiAgICAgICAgaXNXaGl0ZSA9IGZhbHNlLFxuICAgICAgICBjb3VudGVyUG9zID0gMCxcbiAgICAgICAgYmVzdE1hdGNoID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwLFxuICAgICAgICAgICAgY29ycmVjdGlvbjoge1xuICAgICAgICAgICAgICAgIGJhcjogMSxcbiAgICAgICAgICAgICAgICBzcGFjZTogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb2RlLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgaixcbiAgICAgICAgc3VtO1xuXG4gICAgZm9yICggaSA9IG9mZnNldDsgaSA8IHNlbGYuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZi5fcm93W2ldIF4gaXNXaGl0ZSkge1xuICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICggaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBjb3VudGVyW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvZGUgPSBzZWxmLlNUQVJUX0NPREVfQTsgY29kZSA8PSBzZWxmLlNUQVJUX0NPREVfQzsgY29kZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gc2VsZi5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHNlbGYuQ09ERV9QQVRURVJOW2NvZGVdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmVzdE1hdGNoLmVycm9yIDwgc2VsZi5BVkdfQ09ERV9FUlJPUikge1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gc3VtO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvcnJlY3Rpb24uYmFyID0gY2FsY3VsYXRlQ29ycmVjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSwgY291bnRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTU9EVUxFX0lORElDRVMuYmFyKTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvcnJlY3Rpb24uc3BhY2UgPSBjYWxjdWxhdGVDb3JyZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5zcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICggaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyWzRdID0gMDtcbiAgICAgICAgICAgICAgICBjb3VudGVyWzVdID0gMDtcbiAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuQ29kZTEyOFJlYWRlci5wcm90b3R5cGUuX2RlY29kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgc3RhcnRJbmZvID0gc2VsZi5fZmluZFN0YXJ0KCksXG4gICAgICAgIGNvZGUgPSBudWxsLFxuICAgICAgICBkb25lID0gZmFsc2UsXG4gICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICBtdWx0aXBsaWVyID0gMCxcbiAgICAgICAgY2hlY2tzdW0gPSAwLFxuICAgICAgICBjb2Rlc2V0LFxuICAgICAgICByYXdSZXN1bHQgPSBbXSxcbiAgICAgICAgZGVjb2RlZENvZGVzID0gW10sXG4gICAgICAgIHNoaWZ0TmV4dCA9IGZhbHNlLFxuICAgICAgICB1bnNoaWZ0LFxuICAgICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gdHJ1ZTtcblxuICAgIGlmIChzdGFydEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvZGUgPSB7XG4gICAgICAgIGNvZGU6IHN0YXJ0SW5mby5jb2RlLFxuICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICBlbmQ6IHN0YXJ0SW5mby5lbmQsXG4gICAgICAgIGNvcnJlY3Rpb246IHtcbiAgICAgICAgICAgIGJhcjogc3RhcnRJbmZvLmNvcnJlY3Rpb24uYmFyLFxuICAgICAgICAgICAgc3BhY2U6IHN0YXJ0SW5mby5jb3JyZWN0aW9uLnNwYWNlXG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgIGNoZWNrc3VtID0gY29kZS5jb2RlO1xuICAgIHN3aXRjaCAoY29kZS5jb2RlKSB7XG4gICAgY2FzZSBzZWxmLlNUQVJUX0NPREVfQTpcbiAgICAgICAgY29kZXNldCA9IHNlbGYuQ09ERV9BO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIHNlbGYuU1RBUlRfQ09ERV9COlxuICAgICAgICBjb2Rlc2V0ID0gc2VsZi5DT0RFX0I7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2Ugc2VsZi5TVEFSVF9DT0RFX0M6XG4gICAgICAgIGNvZGVzZXQgPSBzZWxmLkNPREVfQztcbiAgICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgIHVuc2hpZnQgPSBzaGlmdE5leHQ7XG4gICAgICAgIHNoaWZ0TmV4dCA9IGZhbHNlO1xuICAgICAgICBjb2RlID0gc2VsZi5fZGVjb2RlQ29kZShjb2RlLmVuZCwgY29kZS5jb3JyZWN0aW9uKTtcbiAgICAgICAgaWYgKGNvZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHNlbGYuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHNlbGYuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgcmF3UmVzdWx0LnB1c2goY29kZS5jb2RlKTtcbiAgICAgICAgICAgICAgICBtdWx0aXBsaWVyKys7XG4gICAgICAgICAgICAgICAgY2hlY2tzdW0gKz0gbXVsdGlwbGllciAqIGNvZGUuY29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGNvZGVzZXQpIHtcbiAgICAgICAgICAgIGNhc2Ugc2VsZi5DT0RFX0E6XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA8IDY0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoMzIgKyBjb2RlLmNvZGUpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUuY29kZSA8IDk2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZS5jb2RlIC0gNjQpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSBzZWxmLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZS5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5DT0RFX1NISUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnROZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSBzZWxmLkNPREVfQjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHNlbGYuQ09ERV9COlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHNlbGYuQ09ERV9CO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5DT0RFX0M6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gc2VsZi5DT0RFX0M7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBzZWxmLlNUT1BfQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNlbGYuQ09ERV9COlxuICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPCA5Nikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKDMyICsgY29kZS5jb2RlKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gc2VsZi5TVE9QX0NPREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHNlbGYuQ09ERV9TSElGVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0TmV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gc2VsZi5DT0RFX0E7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBzZWxmLkNPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSBzZWxmLkNPREVfQTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHNlbGYuQ09ERV9DOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHNlbGYuQ09ERV9DO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5TVE9QX0NPREU6XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzZWxmLkNPREVfQzpcbiAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlIDwgMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvZGUuY29kZSA8IDEwID8gXCIwXCIgKyBjb2RlLmNvZGUgOiBjb2RlLmNvZGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHNlbGYuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBzZWxmLkNPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSBzZWxmLkNPREVfQTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHNlbGYuQ09ERV9COlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHNlbGYuQ09ERV9CO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5TVE9QX0NPREU6XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuc2hpZnQpIHtcbiAgICAgICAgICAgIGNvZGVzZXQgPSBjb2Rlc2V0ID09PSBzZWxmLkNPREVfQSA/IHNlbGYuQ09ERV9CIDogc2VsZi5DT0RFX0E7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb2RlLmVuZCA9IHNlbGYuX25leHRVbnNldChzZWxmLl9yb3csIGNvZGUuZW5kKTtcbiAgICBpZiAoIXNlbGYuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShjb2RlKSl7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNoZWNrc3VtIC09IG11bHRpcGxpZXIgKiByYXdSZXN1bHRbcmF3UmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgIGlmIChjaGVja3N1bSAlIDEwMyAhPT0gcmF3UmVzdWx0W3Jhd1Jlc3VsdC5sZW5ndGggLSAxXSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGxhc3QgY29kZSBmcm9tIHJlc3VsdCAoY2hlY2tzdW0pXG4gICAgaWYgKHJlbW92ZUxhc3RDaGFyYWN0ZXIpIHtcbiAgICAgICAgcmVzdWx0LnNwbGljZShyZXN1bHQubGVuZ3RoIC0gMSwgMSk7XG4gICAgfVxuXG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiByZXN1bHQuam9pbihcIlwiKSxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgZW5kOiBjb2RlLmVuZCxcbiAgICAgICAgY29kZXNldDogY29kZXNldCxcbiAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8sXG4gICAgICAgIGRlY29kZWRDb2RlczogZGVjb2RlZENvZGVzLFxuICAgICAgICBlbmRJbmZvOiBjb2RlXG4gICAgfTtcbn07XG5cblxuQmFyY29kZVJlYWRlci5wcm90b3R5cGUuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZSA9IGZ1bmN0aW9uKGVuZEluZm8pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIHRyYWlsaW5nV2hpdGVzcGFjZUVuZDtcblxuICAgIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpIC8gMik7XG4gICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHNlbGYuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHNlbGYuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuZnVuY3Rpb24gY2FsY3VsYXRlQ29ycmVjdGlvbihleHBlY3RlZCwgbm9ybWFsaXplZCwgaW5kaWNlcykge1xuICAgIHZhciBsZW5ndGggPSBpbmRpY2VzLmxlbmd0aCxcbiAgICAgICAgc3VtTm9ybWFsaXplZCA9IDAsXG4gICAgICAgIHN1bUV4cGVjdGVkID0gMDtcblxuICAgIHdoaWxlKGxlbmd0aC0tKSB7XG4gICAgICAgIHN1bUV4cGVjdGVkICs9IGV4cGVjdGVkW2luZGljZXNbbGVuZ3RoXV07XG4gICAgICAgIHN1bU5vcm1hbGl6ZWQgKz0gbm9ybWFsaXplZFtpbmRpY2VzW2xlbmd0aF1dO1xuICAgIH1cbiAgICByZXR1cm4gc3VtRXhwZWN0ZWQvc3VtTm9ybWFsaXplZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29kZTEyOFJlYWRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZWFkZXIvY29kZV8xMjhfcmVhZGVyLmpzIiwiaW1wb3J0IENvZGUzOVJlYWRlciBmcm9tICcuL2NvZGVfMzlfcmVhZGVyJztcblxuZnVuY3Rpb24gQ29kZTM5VklOUmVhZGVyKCkge1xuICAgIENvZGUzOVJlYWRlci5jYWxsKHRoaXMpO1xufVxuXG52YXIgcGF0dGVybnMgPSB7XG4gICAgSU9ROiAvW0lPUV0vZyxcbiAgICBBWjA5OiAvW0EtWjAtOV17MTd9L1xufTtcblxuQ29kZTM5VklOUmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29kZTM5UmVhZGVyLnByb3RvdHlwZSk7XG5Db2RlMzlWSU5SZWFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29kZTM5VklOUmVhZGVyO1xuXG4vLyBDcmliYmVkIGZyb206XG4vLyBodHRwczovL2dpdGh1Yi5jb20venhpbmcvenhpbmcvYmxvYi9tYXN0ZXIvY29yZS9zcmMvbWFpbi9qYXZhL2NvbS9nb29nbGUvenhpbmcvY2xpZW50L3Jlc3VsdC9WSU5SZXN1bHRQYXJzZXIuamF2YVxuQ29kZTM5VklOUmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3VsdCA9IENvZGUzOVJlYWRlci5wcm90b3R5cGUuX2RlY29kZS5hcHBseSh0aGlzKTtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgY29kZSA9IHJlc3VsdC5jb2RlO1xuXG4gICAgaWYgKCFjb2RlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocGF0dGVybnMuSU9RLCAnJyk7XG5cbiAgICBpZiAoIWNvZGUubWF0Y2gocGF0dGVybnMuQVowOSkpIHtcbiAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCBBWjA5IHBhdHRlcm4gY29kZTonLCBjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2NoZWNrQ2hlY2tzdW0oY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmVzdWx0LmNvZGUgPSBjb2RlO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5Db2RlMzlWSU5SZWFkZXIucHJvdG90eXBlLl9jaGVja0NoZWNrc3VtID0gZnVuY3Rpb24oY29kZSkge1xuICAgIC8vIFRPRE9cbiAgICByZXR1cm4gISFjb2RlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQ29kZTM5VklOUmVhZGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlYWRlci9jb2RlXzM5X3Zpbl9yZWFkZXIuanMiLCJpbXBvcnQgQmFyY29kZVJlYWRlciBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcblxuZnVuY3Rpb24gQ29kZTkzUmVhZGVyKCkge1xuICAgIEJhcmNvZGVSZWFkZXIuY2FsbCh0aGlzKTtcbn1cblxuY29uc3QgQUxQSEFCRVRIX1NUUklORyA9IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaLS4gJC8rJWFiY2QqXCI7XG5cbnZhciBwcm9wZXJ0aWVzID0ge1xuICAgIEFMUEhBQkVUSF9TVFJJTkc6IHt2YWx1ZTogQUxQSEFCRVRIX1NUUklOR30sXG4gICAgQUxQSEFCRVQ6IHt2YWx1ZTogQUxQSEFCRVRIX1NUUklORy5zcGxpdCgnJykubWFwKGNoYXIgPT4gY2hhci5jaGFyQ29kZUF0KDApKX0sXG4gICAgQ0hBUkFDVEVSX0VOQ09ESU5HUzoge3ZhbHVlOiBbXG4gICAgICAgIDB4MTE0LCAweDE0OCwgMHgxNDQsIDB4MTQyLCAweDEyOCwgMHgxMjQsIDB4MTIyLCAweDE1MCwgMHgxMTIsIDB4MTBBLFxuICAgICAgICAweDFBOCwgMHgxQTQsIDB4MUEyLCAweDE5NCwgMHgxOTIsIDB4MThBLCAweDE2OCwgMHgxNjQsIDB4MTYyLCAweDEzNCxcbiAgICAgICAgMHgxMUEsIDB4MTU4LCAweDE0QywgMHgxNDYsIDB4MTJDLCAweDExNiwgMHgxQjQsIDB4MUIyLCAweDFBQywgMHgxQTYsXG4gICAgICAgIDB4MTk2LCAweDE5QSwgMHgxNkMsIDB4MTY2LCAweDEzNiwgMHgxM0EsIDB4MTJFLCAweDFENCwgMHgxRDIsIDB4MUNBLFxuICAgICAgICAweDE2RSwgMHgxNzYsIDB4MUFFLCAweDEyNiwgMHgxREEsIDB4MUQ2LCAweDEzMiwgMHgxNUVcbiAgICBdfSxcbiAgICBBU1RFUklTSzoge3ZhbHVlOiAweDE1RX0sXG4gICAgRk9STUFUOiB7dmFsdWU6IFwiY29kZV85M1wiLCB3cml0ZWFibGU6IGZhbHNlfVxufTtcblxuQ29kZTkzUmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFyY29kZVJlYWRlci5wcm90b3R5cGUsIHByb3BlcnRpZXMpO1xuQ29kZTkzUmVhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvZGU5M1JlYWRlcjtcblxuQ29kZTkzUmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBjb3VudGVycyA9IFswLCAwLCAwLCAwLCAwLCAwXSxcbiAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgIHN0YXJ0ID0gc2VsZi5fZmluZFN0YXJ0KCksXG4gICAgICAgIGRlY29kZWRDaGFyLFxuICAgICAgICBsYXN0U3RhcnQsXG4gICAgICAgIHBhdHRlcm4sXG4gICAgICAgIG5leHRTdGFydDtcblxuICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG5leHRTdGFydCA9IHNlbGYuX25leHRTZXQoc2VsZi5fcm93LCBzdGFydC5lbmQpO1xuXG4gICAgZG8ge1xuICAgICAgICBjb3VudGVycyA9IHNlbGYuX3RvQ291bnRlcnMobmV4dFN0YXJ0LCBjb3VudGVycyk7XG4gICAgICAgIHBhdHRlcm4gPSBzZWxmLl90b1BhdHRlcm4oY291bnRlcnMpO1xuICAgICAgICBpZiAocGF0dGVybiA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZWRDaGFyID0gc2VsZi5fcGF0dGVyblRvQ2hhcihwYXR0ZXJuKTtcbiAgICAgICAgaWYgKGRlY29kZWRDaGFyIDwgMCl7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkQ2hhcik7XG4gICAgICAgIGxhc3RTdGFydCA9IG5leHRTdGFydDtcbiAgICAgICAgbmV4dFN0YXJ0ICs9IEFycmF5SGVscGVyLnN1bShjb3VudGVycyk7XG4gICAgICAgIG5leHRTdGFydCA9IHNlbGYuX25leHRTZXQoc2VsZi5fcm93LCBuZXh0U3RhcnQpO1xuICAgIH0gd2hpbGUgKGRlY29kZWRDaGFyICE9PSAnKicpO1xuICAgIHJlc3VsdC5wb3AoKTtcblxuICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIXNlbGYuX3ZlcmlmeUVuZChsYXN0U3RhcnQsIG5leHRTdGFydCwgY291bnRlcnMpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghc2VsZi5fdmVyaWZ5Q2hlY2tzdW1zKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIHJlc3VsdC5sZW5ndGggLSAyKTtcbiAgICBpZiAoKHJlc3VsdCA9IHNlbGYuX2RlY29kZUV4dGVuZGVkKHJlc3VsdCkpID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiByZXN1bHQuam9pbihcIlwiKSxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LnN0YXJ0LFxuICAgICAgICBlbmQ6IG5leHRTdGFydCxcbiAgICAgICAgc3RhcnRJbmZvOiBzdGFydCxcbiAgICAgICAgZGVjb2RlZENvZGVzOiByZXN1bHRcbiAgICB9O1xufTtcblxuQ29kZTkzUmVhZGVyLnByb3RvdHlwZS5fdmVyaWZ5RW5kID0gZnVuY3Rpb24obGFzdFN0YXJ0LCBuZXh0U3RhcnQpIHtcbiAgICBpZiAobGFzdFN0YXJ0ID09PSBuZXh0U3RhcnQgfHwgIXRoaXMuX3Jvd1tuZXh0U3RhcnRdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5Db2RlOTNSZWFkZXIucHJvdG90eXBlLl9wYXR0ZXJuVG9DaGFyID0gZnVuY3Rpb24ocGF0dGVybikge1xuICAgIHZhciBpLFxuICAgICAgICBzZWxmID0gdGhpcztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzZWxmLkNIQVJBQ1RFUl9FTkNPRElOR1MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGYuQ0hBUkFDVEVSX0VOQ09ESU5HU1tpXSA9PT0gcGF0dGVybikge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoc2VsZi5BTFBIQUJFVFtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcblxuQ29kZTkzUmVhZGVyLnByb3RvdHlwZS5fdG9QYXR0ZXJuID0gZnVuY3Rpb24oY291bnRlcnMpIHtcbiAgICBjb25zdCBudW1Db3VudGVycyA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICBsZXQgcGF0dGVybiA9IDA7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVyczsgaSsrKSB7XG4gICAgICAgIHN1bSArPSBjb3VudGVyc1tpXTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvdW50ZXJzOyBpKyspIHtcbiAgICAgICAgbGV0IG5vcm1hbGl6ZWQgPSBNYXRoLnJvdW5kKGNvdW50ZXJzW2ldICogOSAvIHN1bSk7XG4gICAgICAgIGlmIChub3JtYWxpemVkIDwgMSB8fCBub3JtYWxpemVkID4gNCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaSAmIDEpID09PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vcm1hbGl6ZWQ7IGorKykge1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gPSAocGF0dGVybiA8PCAxKSB8IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXR0ZXJuIDw8PSBub3JtYWxpemVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdHRlcm47XG59O1xuXG5Db2RlOTNSZWFkZXIucHJvdG90eXBlLl9maW5kU3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIG9mZnNldCA9IHNlbGYuX25leHRTZXQoc2VsZi5fcm93KSxcbiAgICAgICAgcGF0dGVyblN0YXJ0ID0gb2Zmc2V0LFxuICAgICAgICBjb3VudGVyID0gWzAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgICBjb3VudGVyUG9zID0gMCxcbiAgICAgICAgaXNXaGl0ZSA9IGZhbHNlLFxuICAgICAgICBpLFxuICAgICAgICBqLFxuICAgICAgICB3aGl0ZVNwYWNlTXVzdFN0YXJ0O1xuXG4gICAgZm9yICggaSA9IG9mZnNldDsgaSA8IHNlbGYuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZi5fcm93W2ldIF4gaXNXaGl0ZSkge1xuICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIC8vIGZpbmQgc3RhcnQgcGF0dGVyblxuICAgICAgICAgICAgICAgIGlmIChzZWxmLl90b1BhdHRlcm4oY291bnRlcikgPT09IHNlbGYuQVNURVJJU0spIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGVTcGFjZU11c3RTdGFydCA9IE1hdGguZmxvb3IoTWF0aC5tYXgoMCwgcGF0dGVyblN0YXJ0IC0gKChpIC0gcGF0dGVyblN0YXJ0KSAvIDQpKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLl9tYXRjaFJhbmdlKHdoaXRlU3BhY2VNdXN0U3RhcnQsIHBhdHRlcm5TdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHBhdHRlcm5TdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGlcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlclswXSArIGNvdW50ZXJbMV07XG4gICAgICAgICAgICAgICAgZm9yICggaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyWzRdID0gMDtcbiAgICAgICAgICAgICAgICBjb3VudGVyWzVdID0gMDtcbiAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuQ29kZTkzUmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlRXh0ZW5kZWQgPSBmdW5jdGlvbihjaGFyQXJyYXkpIHtcbiAgICBjb25zdCBsZW5ndGggPSBjaGFyQXJyYXkubGVuZ3RoO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hhciA9IGNoYXJBcnJheVtpXTtcbiAgICAgICAgaWYgKGNoYXIgPj0gJ2EnICYmIGNoYXIgPD0gJ2QnKSB7XG4gICAgICAgICAgICBpZiAoaSA+IChsZW5ndGggLSAyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV4dENoYXIgPSBjaGFyQXJyYXlbKytpXTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRDaGFyQ29kZSA9IG5leHRDaGFyLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBsZXQgZGVjb2RlZENoYXI7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hhciA+PSAnQScgJiYgbmV4dENoYXIgPD0gJ1onKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgLSA2NCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnRScpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSAtIDM4KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID49ICdGJyAmJiBuZXh0Q2hhciA8PSAnSicpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSAtIDExKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID49ICdLJyAmJiBuZXh0Q2hhciA8PSAnTycpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSArIDE2KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID49ICdQJyAmJiBuZXh0Q2hhciA8PSAnUycpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSArIDQzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID49ICdUJyAmJiBuZXh0Q2hhciA8PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyNyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnTycpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSAtIDMyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID09PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSAnOic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSArIDMyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkQ2hhcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjaGFyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuQ29kZTkzUmVhZGVyLnByb3RvdHlwZS5fdmVyaWZ5Q2hlY2tzdW1zID0gZnVuY3Rpb24oY2hhckFycmF5KSB7XG4gICAgcmV0dXJuIHRoaXMuX21hdGNoQ2hlY2tDaGFyKGNoYXJBcnJheSwgY2hhckFycmF5Lmxlbmd0aCAtIDIsIDIwKVxuICAgICAgICAmJiB0aGlzLl9tYXRjaENoZWNrQ2hhcihjaGFyQXJyYXksIGNoYXJBcnJheS5sZW5ndGggLSAxLCAxNSk7XG59O1xuXG5Db2RlOTNSZWFkZXIucHJvdG90eXBlLl9tYXRjaENoZWNrQ2hhciA9IGZ1bmN0aW9uKGNoYXJBcnJheSwgaW5kZXgsIG1heFdlaWdodCkge1xuICAgIGNvbnN0IGFycmF5VG9DaGVjayA9IGNoYXJBcnJheS5zbGljZSgwLCBpbmRleCk7XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXlUb0NoZWNrLmxlbmd0aDtcbiAgICBjb25zdCB3ZWlnaHRlZFN1bXMgPSBhcnJheVRvQ2hlY2sucmVkdWNlKChzdW0sIGNoYXIsIGkpID0+IHtcbiAgICAgICAgY29uc3Qgd2VpZ2h0ID0gKCgoaSAqIC0xKSArIChsZW5ndGggLSAxKSkgJSBtYXhXZWlnaHQpICsgMTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLkFMUEhBQkVULmluZGV4T2YoY2hhci5jaGFyQ29kZUF0KDApKTtcbiAgICAgICAgcmV0dXJuIHN1bSArICh3ZWlnaHQgKiB2YWx1ZSk7XG4gICAgfSwgMCk7XG5cbiAgICBjb25zdCBjaGVja0NoYXIgPSB0aGlzLkFMUEhBQkVUWyh3ZWlnaHRlZFN1bXMgJSA0NyldO1xuICAgIHJldHVybiBjaGVja0NoYXIgPT09IGNoYXJBcnJheVtpbmRleF0uY2hhckNvZGVBdCgwKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENvZGU5M1JlYWRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZWFkZXIvY29kZV85M19yZWFkZXIuanMiLCJpbXBvcnQgRUFOUmVhZGVyIGZyb20gJy4vZWFuX3JlYWRlcic7XG5cbmZ1bmN0aW9uIEVBTjJSZWFkZXIoKSB7XG4gICAgRUFOUmVhZGVyLmNhbGwodGhpcyk7XG59XG5cbnZhciBwcm9wZXJ0aWVzID0ge1xuICAgIEZPUk1BVDoge3ZhbHVlOiBcImVhbl8yXCIsIHdyaXRlYWJsZTogZmFsc2V9XG59O1xuXG5FQU4yUmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRUFOUmVhZGVyLnByb3RvdHlwZSwgcHJvcGVydGllcyk7XG5FQU4yUmVhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVBTjJSZWFkZXI7XG5cbkVBTjJSZWFkZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHJvdywgc3RhcnQpIHtcbiAgICB0aGlzLl9yb3cgPSByb3c7XG4gICAgdmFyIGNvdW50ZXJzID0gWzAsIDAsIDAsIDBdLFxuICAgICAgICBjb2RlRnJlcXVlbmN5ID0gMCxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIG9mZnNldCA9IHN0YXJ0LFxuICAgICAgICBlbmQgPSB0aGlzLl9yb3cubGVuZ3RoLFxuICAgICAgICBjb2RlLFxuICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgZGVjb2RlZENvZGVzID0gW107XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgMiAmJiBvZmZzZXQgPCBlbmQ7IGkrKykge1xuICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShvZmZzZXQpO1xuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUgJSAxMCk7XG4gICAgICAgIGlmIChjb2RlLmNvZGUgPj0gdGhpcy5DT0RFX0dfU1RBUlQpIHtcbiAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gMSA8PCAoMSAtIGkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpICE9IDEpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBjb2RlLmVuZCk7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93LCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5sZW5ndGggIT0gMiB8fCAocGFyc2VJbnQocmVzdWx0LmpvaW4oXCJcIikpICUgNCkgICE9PSBjb2RlRnJlcXVlbmN5KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiByZXN1bHQuam9pbihcIlwiKSxcbiAgICAgICAgZGVjb2RlZENvZGVzLFxuICAgICAgICBlbmQ6IGNvZGUuZW5kXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEVBTjJSZWFkZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVhZGVyL2Vhbl8yX3JlYWRlci5qcyIsImltcG9ydCBFQU5SZWFkZXIgZnJvbSAnLi9lYW5fcmVhZGVyJztcblxuZnVuY3Rpb24gRUFONVJlYWRlcigpIHtcbiAgICBFQU5SZWFkZXIuY2FsbCh0aGlzKTtcbn1cblxudmFyIHByb3BlcnRpZXMgPSB7XG4gICAgRk9STUFUOiB7dmFsdWU6IFwiZWFuXzVcIiwgd3JpdGVhYmxlOiBmYWxzZX1cbn07XG5cbmNvbnN0IENIRUNLX0RJR0lUX0VOQ09ESU5HUyA9IFsyNCwgMjAsIDE4LCAxNywgMTIsIDYsIDMsIDEwLCA5LCA1XTtcblxuRUFONVJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVBTlJlYWRlci5wcm90b3R5cGUsIHByb3BlcnRpZXMpO1xuRUFONVJlYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFQU41UmVhZGVyO1xuXG5FQU41UmVhZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihyb3csIHN0YXJ0KSB7XG4gICAgdGhpcy5fcm93ID0gcm93O1xuICAgIHZhciBjb3VudGVycyA9IFswLCAwLCAwLCAwXSxcbiAgICAgICAgY29kZUZyZXF1ZW5jeSA9IDAsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBvZmZzZXQgPSBzdGFydCxcbiAgICAgICAgZW5kID0gdGhpcy5fcm93Lmxlbmd0aCxcbiAgICAgICAgY29kZSxcbiAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgIGRlY29kZWRDb2RlcyA9IFtdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IDUgJiYgb2Zmc2V0IDwgZW5kOyBpKyspIHtcbiAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUob2Zmc2V0KTtcbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgcmVzdWx0LnB1c2goY29kZS5jb2RlICUgMTApO1xuICAgICAgICBpZiAoY29kZS5jb2RlID49IHRoaXMuQ09ERV9HX1NUQVJUKSB7XG4gICAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9IDEgPDwgKDQgLSBpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSAhPSA0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3JvdywgY29kZS5lbmQpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3Jvdywgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXN1bHQubGVuZ3RoICE9IDUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGV4dGVuc2lvbkNoZWNrc3VtKHJlc3VsdCkgIT09IGRldGVybWluZUNoZWNrRGlnaXQoY29kZUZyZXF1ZW5jeSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKFwiXCIpLFxuICAgICAgICBkZWNvZGVkQ29kZXMsXG4gICAgICAgIGVuZDogY29kZS5lbmRcbiAgICB9O1xufTtcblxuZnVuY3Rpb24gZGV0ZXJtaW5lQ2hlY2tEaWdpdChjb2RlRnJlcXVlbmN5KSB7XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgaWYgKGNvZGVGcmVxdWVuY3kgPT09IENIRUNLX0RJR0lUX0VOQ09ESU5HU1tpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cblxuZnVuY3Rpb24gZXh0ZW5zaW9uQ2hlY2tzdW0ocmVzdWx0KSB7XG4gICAgdmFyIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGgsXG4gICAgICAgIHN1bSA9IDAsXG4gICAgICAgIGk7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICBzdW0gKz0gcmVzdWx0W2ldO1xuICAgIH1cbiAgICBzdW0gKj0gMztcbiAgICBmb3IgKGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICBzdW0gKz0gcmVzdWx0W2ldO1xuICAgIH1cbiAgICBzdW0gKj0gMztcbiAgICByZXR1cm4gc3VtICUgMTA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVBTjVSZWFkZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVhZGVyL2Vhbl81X3JlYWRlci5qcyIsImltcG9ydCBFQU5SZWFkZXIgZnJvbSAnLi9lYW5fcmVhZGVyJztcblxuZnVuY3Rpb24gRUFOOFJlYWRlcihvcHRzLCBzdXBwbGVtZW50cykge1xuICAgIEVBTlJlYWRlci5jYWxsKHRoaXMsIG9wdHMsIHN1cHBsZW1lbnRzKTtcbn1cblxudmFyIHByb3BlcnRpZXMgPSB7XG4gICAgRk9STUFUOiB7dmFsdWU6IFwiZWFuXzhcIiwgd3JpdGVhYmxlOiBmYWxzZX1cbn07XG5cbkVBTjhSZWFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFQU5SZWFkZXIucHJvdG90eXBlLCBwcm9wZXJ0aWVzKTtcbkVBTjhSZWFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRUFOOFJlYWRlcjtcblxuRUFOOFJlYWRlci5wcm90b3R5cGUuX2RlY29kZVBheWxvYWQgPSBmdW5jdGlvbihjb2RlLCByZXN1bHQsIGRlY29kZWRDb2Rlcykge1xuICAgIHZhciBpLFxuICAgICAgICBzZWxmID0gdGhpcztcblxuICAgIGZvciAoIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIGNvZGUgPSBzZWxmLl9kZWNvZGVDb2RlKGNvZGUuZW5kLCBzZWxmLkNPREVfR19TVEFSVCk7XG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goY29kZS5jb2RlKTtcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgfVxuXG4gICAgY29kZSA9IHNlbGYuX2ZpbmRQYXR0ZXJuKHNlbGYuTUlERExFX1BBVFRFUk4sIGNvZGUuZW5kLCB0cnVlLCBmYWxzZSk7XG4gICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuXG4gICAgZm9yICggaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgY29kZSA9IHNlbGYuX2RlY29kZUNvZGUoY29kZS5lbmQsIHNlbGYuQ09ERV9HX1NUQVJUKTtcbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgcmVzdWx0LnB1c2goY29kZS5jb2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29kZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEVBTjhSZWFkZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVhZGVyL2Vhbl84X3JlYWRlci5qcyIsImltcG9ydCBCYXJjb2RlUmVhZGVyIGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuaW1wb3J0IHttZXJnZX0gZnJvbSAnbG9kYXNoJztcblxuZnVuY3Rpb24gSTJvZjVSZWFkZXIob3B0cykge1xuICAgIG9wdHMgPSBtZXJnZShnZXREZWZhdWxDb25maWcoKSwgb3B0cyk7XG4gICAgQmFyY29kZVJlYWRlci5jYWxsKHRoaXMsIG9wdHMpO1xuICAgIHRoaXMuYmFyU3BhY2VSYXRpbyA9IFsxLCAxXTtcbiAgICBpZiAob3B0cy5ub3JtYWxpemVCYXJTcGFjZVdpZHRoKSB7XG4gICAgICAgIHRoaXMuU0lOR0xFX0NPREVfRVJST1IgPSAwLjM4O1xuICAgICAgICB0aGlzLkFWR19DT0RFX0VSUk9SID0gMC4wOTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bENvbmZpZygpIHtcbiAgICB2YXIgY29uZmlnID0ge307XG5cbiAgICBPYmplY3Qua2V5cyhJMm9mNVJlYWRlci5DT05GSUdfS0VZUykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgY29uZmlnW2tleV0gPSBJMm9mNVJlYWRlci5DT05GSUdfS0VZU1trZXldLmRlZmF1bHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbmZpZztcbn1cblxudmFyIE4gPSAxLFxuICAgIFcgPSAzLFxuICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgIFNUQVJUX1BBVFRFUk46IHt2YWx1ZTogW04sIE4sIE4sIE5dfSxcbiAgICAgICAgU1RPUF9QQVRURVJOOiB7dmFsdWU6IFtOLCBOLCBXXX0sXG4gICAgICAgIENPREVfUEFUVEVSTjoge3ZhbHVlOiBbXG4gICAgICAgICAgICBbTiwgTiwgVywgVywgTl0sXG4gICAgICAgICAgICBbVywgTiwgTiwgTiwgV10sXG4gICAgICAgICAgICBbTiwgVywgTiwgTiwgV10sXG4gICAgICAgICAgICBbVywgVywgTiwgTiwgTl0sXG4gICAgICAgICAgICBbTiwgTiwgVywgTiwgV10sXG4gICAgICAgICAgICBbVywgTiwgVywgTiwgTl0sXG4gICAgICAgICAgICBbTiwgVywgVywgTiwgTl0sXG4gICAgICAgICAgICBbTiwgTiwgTiwgVywgV10sXG4gICAgICAgICAgICBbVywgTiwgTiwgVywgTl0sXG4gICAgICAgICAgICBbTiwgVywgTiwgVywgTl1cbiAgICAgICAgXX0sXG4gICAgICAgIFNJTkdMRV9DT0RFX0VSUk9SOiB7dmFsdWU6IDAuNzgsIHdyaXRhYmxlOiB0cnVlfSxcbiAgICAgICAgQVZHX0NPREVfRVJST1I6IHt2YWx1ZTogMC4zOCwgd3JpdGFibGU6IHRydWV9LFxuICAgICAgICBNQVhfQ09SUkVDVElPTl9GQUNUT1I6IHt2YWx1ZTogNX0sXG4gICAgICAgIEZPUk1BVDoge3ZhbHVlOiBcImkyb2Y1XCJ9XG4gICAgfTtcblxuSTJvZjVSZWFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXJjb2RlUmVhZGVyLnByb3RvdHlwZSwgcHJvcGVydGllcyk7XG5JMm9mNVJlYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJMm9mNVJlYWRlcjtcblxuSTJvZjVSZWFkZXIucHJvdG90eXBlLl9tYXRjaFBhdHRlcm4gPSBmdW5jdGlvbihjb3VudGVyLCBjb2RlKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLm5vcm1hbGl6ZUJhclNwYWNlV2lkdGgpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBjb3VudGVyU3VtID0gWzAsIDBdLFxuICAgICAgICAgICAgY29kZVN1bSA9IFswLCAwXSxcbiAgICAgICAgICAgIGNvcnJlY3Rpb24gPSBbMCwgMF0sXG4gICAgICAgICAgICBjb3JyZWN0aW9uUmF0aW8gPSB0aGlzLk1BWF9DT1JSRUNUSU9OX0ZBQ1RPUixcbiAgICAgICAgICAgIGNvcnJlY3Rpb25SYXRpb0ludmVyc2UgPSAxIC8gY29ycmVjdGlvblJhdGlvO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudGVyU3VtW2kgJSAyXSArPSBjb3VudGVyW2ldO1xuICAgICAgICAgICAgY29kZVN1bVtpICUgMl0gKz0gY29kZVtpXTtcbiAgICAgICAgfVxuICAgICAgICBjb3JyZWN0aW9uWzBdID0gY29kZVN1bVswXSAvIGNvdW50ZXJTdW1bMF07XG4gICAgICAgIGNvcnJlY3Rpb25bMV0gPSBjb2RlU3VtWzFdIC8gY291bnRlclN1bVsxXTtcblxuICAgICAgICBjb3JyZWN0aW9uWzBdID0gTWF0aC5tYXgoTWF0aC5taW4oY29ycmVjdGlvblswXSwgY29ycmVjdGlvblJhdGlvKSwgY29ycmVjdGlvblJhdGlvSW52ZXJzZSk7XG4gICAgICAgIGNvcnJlY3Rpb25bMV0gPSBNYXRoLm1heChNYXRoLm1pbihjb3JyZWN0aW9uWzFdLCBjb3JyZWN0aW9uUmF0aW8pLCBjb3JyZWN0aW9uUmF0aW9JbnZlcnNlKTtcbiAgICAgICAgdGhpcy5iYXJTcGFjZVJhdGlvID0gY29ycmVjdGlvbjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvdW50ZXJbaV0gKj0gdGhpcy5iYXJTcGFjZVJhdGlvW2kgJSAyXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQmFyY29kZVJlYWRlci5wcm90b3R5cGUuX21hdGNoUGF0dGVybi5jYWxsKHRoaXMsIGNvdW50ZXIsIGNvZGUpO1xufTtcblxuSTJvZjVSZWFkZXIucHJvdG90eXBlLl9maW5kUGF0dGVybiA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9mZnNldCwgaXNXaGl0ZSwgdHJ5SGFyZGVyKSB7XG4gICAgdmFyIGNvdW50ZXIgPSBbXSxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIGksXG4gICAgICAgIGNvdW50ZXJQb3MgPSAwLFxuICAgICAgICBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGosXG4gICAgICAgIHN1bSxcbiAgICAgICAgbm9ybWFsaXplZCxcbiAgICAgICAgZXBzaWxvbiA9IHNlbGYuQVZHX0NPREVfRVJST1I7XG5cbiAgICBpc1doaXRlID0gaXNXaGl0ZSB8fCBmYWxzZTtcbiAgICB0cnlIYXJkZXIgPSB0cnlIYXJkZXIgfHwgZmFsc2U7XG5cbiAgICBpZiAoIW9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSBzZWxmLl9uZXh0U2V0KHNlbGYuX3Jvdyk7XG4gICAgfVxuXG4gICAgZm9yICggaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvdW50ZXJbaV0gPSAwO1xuICAgIH1cblxuICAgIGZvciAoIGkgPSBvZmZzZXQ7IGkgPCBzZWxmLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGYuX3Jvd1tpXSBeIGlzV2hpdGUpIHtcbiAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoIGogPSAwOyBqIDwgY291bnRlci5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gY291bnRlcltqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBzZWxmLl9tYXRjaFBhdHRlcm4oY291bnRlciwgcGF0dGVybik7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLnN0YXJ0ID0gaSAtIHN1bTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0cnlIYXJkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoIC0gMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDJdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDFdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5JMm9mNVJlYWRlci5wcm90b3R5cGUuX2ZpbmRTdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgbGVhZGluZ1doaXRlc3BhY2VTdGFydCxcbiAgICAgICAgb2Zmc2V0ID0gc2VsZi5fbmV4dFNldChzZWxmLl9yb3cpLFxuICAgICAgICBzdGFydEluZm8sXG4gICAgICAgIG5hcnJvd0JhcldpZHRoID0gMTtcblxuICAgIHdoaWxlICghc3RhcnRJbmZvKSB7XG4gICAgICAgIHN0YXJ0SW5mbyA9IHNlbGYuX2ZpbmRQYXR0ZXJuKHNlbGYuU1RBUlRfUEFUVEVSTiwgb2Zmc2V0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBuYXJyb3dCYXJXaWR0aCA9IE1hdGguZmxvb3IoKHN0YXJ0SW5mby5lbmQgLSBzdGFydEluZm8uc3RhcnQpIC8gNCk7XG4gICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSBzdGFydEluZm8uc3RhcnQgLSBuYXJyb3dCYXJXaWR0aCAqIDEwO1xuICAgICAgICBpZiAobGVhZGluZ1doaXRlc3BhY2VTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5fbWF0Y2hSYW5nZShsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0LCBzdGFydEluZm8uc3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0SW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgPSBzdGFydEluZm8uZW5kO1xuICAgICAgICBzdGFydEluZm8gPSBudWxsO1xuICAgIH1cbn07XG5cbkkyb2Y1UmVhZGVyLnByb3RvdHlwZS5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlID0gZnVuY3Rpb24oZW5kSW5mbykge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kO1xuXG4gICAgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyKTtcbiAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgc2VsZi5fcm93Lmxlbmd0aCkge1xuICAgICAgICBpZiAoc2VsZi5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5JMm9mNVJlYWRlci5wcm90b3R5cGUuX2ZpbmRFbmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGVuZEluZm8sXG4gICAgICAgIHRtcDtcblxuICAgIHNlbGYuX3Jvdy5yZXZlcnNlKCk7XG4gICAgZW5kSW5mbyA9IHNlbGYuX2ZpbmRQYXR0ZXJuKHNlbGYuU1RPUF9QQVRURVJOKTtcbiAgICBzZWxmLl9yb3cucmV2ZXJzZSgpO1xuXG4gICAgaWYgKGVuZEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gcmV2ZXJzZSBudW1iZXJzXG4gICAgdG1wID0gZW5kSW5mby5zdGFydDtcbiAgICBlbmRJbmZvLnN0YXJ0ID0gc2VsZi5fcm93Lmxlbmd0aCAtIGVuZEluZm8uZW5kO1xuICAgIGVuZEluZm8uZW5kID0gc2VsZi5fcm93Lmxlbmd0aCAtIHRtcDtcblxuICAgIHJldHVybiBlbmRJbmZvICE9PSBudWxsID8gc2VsZi5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pIDogbnVsbDtcbn07XG5cbkkyb2Y1UmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlUGFpciA9IGZ1bmN0aW9uKGNvdW50ZXJQYWlyKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGNvZGUsXG4gICAgICAgIGNvZGVzID0gW10sXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50ZXJQYWlyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvZGUgPSBzZWxmLl9kZWNvZGVDb2RlKGNvdW50ZXJQYWlyW2ldKTtcbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb2Rlcy5wdXNoKGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZXM7XG59O1xuXG5JMm9mNVJlYWRlci5wcm90b3R5cGUuX2RlY29kZUNvZGUgPSBmdW5jdGlvbihjb3VudGVyKSB7XG4gICAgdmFyIGosXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBzdW0gPSAwLFxuICAgICAgICBub3JtYWxpemVkLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgZXBzaWxvbiA9IHNlbGYuQVZHX0NPREVfRVJST1IsXG4gICAgICAgIGNvZGUsXG4gICAgICAgIGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMFxuICAgICAgICB9O1xuXG4gICAgZm9yICggaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHN1bSArPSBjb3VudGVyW2pdO1xuICAgIH1cbiAgICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgc2VsZi5DT0RFX1BBVFRFUk4ubGVuZ3RoOyBjb2RlKyspIHtcbiAgICAgICAgZXJyb3IgPSBzZWxmLl9tYXRjaFBhdHRlcm4oY291bnRlciwgc2VsZi5DT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcbiAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcbiAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChiZXN0TWF0Y2guZXJyb3IgPCBlcHNpbG9uKSB7XG4gICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgfVxufTtcblxuSTJvZjVSZWFkZXIucHJvdG90eXBlLl9kZWNvZGVQYXlsb2FkID0gZnVuY3Rpb24oY291bnRlcnMsIHJlc3VsdCwgZGVjb2RlZENvZGVzKSB7XG4gICAgdmFyIGksXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBwb3MgPSAwLFxuICAgICAgICBjb3VudGVyTGVuZ3RoID0gY291bnRlcnMubGVuZ3RoLFxuICAgICAgICBjb3VudGVyUGFpciA9IFtbMCwgMCwgMCwgMCwgMF0sIFswLCAwLCAwLCAwLCAwXV0sXG4gICAgICAgIGNvZGVzO1xuXG4gICAgd2hpbGUgKHBvcyA8IGNvdW50ZXJMZW5ndGgpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgY291bnRlclBhaXJbMF1baV0gPSBjb3VudGVyc1twb3NdICogdGhpcy5iYXJTcGFjZVJhdGlvWzBdO1xuICAgICAgICAgICAgY291bnRlclBhaXJbMV1baV0gPSBjb3VudGVyc1twb3MgKyAxXSAqIHRoaXMuYmFyU3BhY2VSYXRpb1sxXTtcbiAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVzID0gc2VsZi5fZGVjb2RlUGFpcihjb3VudGVyUGFpcik7XG4gICAgICAgIGlmICghY29kZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY29kZXNbaV0uY29kZSArIFwiXCIpO1xuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZXNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2Rlcztcbn07XG5cbkkyb2Y1UmVhZGVyLnByb3RvdHlwZS5fdmVyaWZ5Q291bnRlckxlbmd0aCA9IGZ1bmN0aW9uKGNvdW50ZXJzKSB7XG4gICAgcmV0dXJuIChjb3VudGVycy5sZW5ndGggJSAxMCA9PT0gMCk7XG59O1xuXG5JMm9mNVJlYWRlci5wcm90b3R5cGUuX2RlY29kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFydEluZm8sXG4gICAgICAgIGVuZEluZm8sXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBjb2RlLFxuICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgZGVjb2RlZENvZGVzID0gW10sXG4gICAgICAgIGNvdW50ZXJzO1xuXG4gICAgc3RhcnRJbmZvID0gc2VsZi5fZmluZFN0YXJ0KCk7XG4gICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRlY29kZWRDb2Rlcy5wdXNoKHN0YXJ0SW5mbyk7XG5cbiAgICBlbmRJbmZvID0gc2VsZi5fZmluZEVuZCgpO1xuICAgIGlmICghZW5kSW5mbykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb3VudGVycyA9IHNlbGYuX2ZpbGxDb3VudGVycyhzdGFydEluZm8uZW5kLCBlbmRJbmZvLnN0YXJ0LCBmYWxzZSk7XG4gICAgaWYgKCFzZWxmLl92ZXJpZnlDb3VudGVyTGVuZ3RoKGNvdW50ZXJzKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29kZSA9IHNlbGYuX2RlY29kZVBheWxvYWQoY291bnRlcnMsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcbiAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChyZXN1bHQubGVuZ3RoICUgMiAhPT0gMCB8fFxuICAgICAgICAgICAgcmVzdWx0Lmxlbmd0aCA8IDYpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZGVjb2RlZENvZGVzLnB1c2goZW5kSW5mbyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oXCJcIiksXG4gICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgIGVuZDogZW5kSW5mby5lbmQsXG4gICAgICAgIHN0YXJ0SW5mbzogc3RhcnRJbmZvLFxuICAgICAgICBkZWNvZGVkQ29kZXM6IGRlY29kZWRDb2Rlc1xuICAgIH07XG59O1xuXG5JMm9mNVJlYWRlci5DT05GSUdfS0VZUyA9IHtcbiAgICBub3JtYWxpemVCYXJTcGFjZVdpZHRoOiB7XG4gICAgICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICAgICAnZGVmYXVsdCc6IGZhbHNlLFxuICAgICAgICAnZGVzY3JpcHRpb24nOiAnSWYgdHJ1ZSwgdGhlIHJlYWRlciB0cmllcyB0byBub3JtYWxpemUgdGhlJyArXG4gICAgICAgICd3aWR0aC1kaWZmZXJlbmNlIGJldHdlZW4gYmFycyBhbmQgc3BhY2VzJ1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEkyb2Y1UmVhZGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlYWRlci9pMm9mNV9yZWFkZXIuanMiLCJpbXBvcnQgRUFOUmVhZGVyIGZyb20gJy4vZWFuX3JlYWRlcic7XG5cbmZ1bmN0aW9uIFVQQ0VSZWFkZXIob3B0cywgc3VwcGxlbWVudHMpIHtcbiAgICBFQU5SZWFkZXIuY2FsbCh0aGlzLCBvcHRzLCBzdXBwbGVtZW50cyk7XG59XG5cbnZhciBwcm9wZXJ0aWVzID0ge1xuICAgIENPREVfRlJFUVVFTkNZOiB7dmFsdWU6IFtcbiAgICAgICAgWyA1NiwgNTIsIDUwLCA0OSwgNDQsIDM4LCAzNSwgNDIsIDQxLCAzNyBdLFxuICAgICAgICBbNywgMTEsIDEzLCAxNCwgMTksIDI1LCAyOCwgMjEsIDIyLCAyNl1dfSxcbiAgICBTVE9QX1BBVFRFUk46IHsgdmFsdWU6IFsxIC8gNiAqIDcsIDEgLyA2ICogNywgMSAvIDYgKiA3LCAxIC8gNiAqIDcsIDEgLyA2ICogNywgMSAvIDYgKiA3XX0sXG4gICAgRk9STUFUOiB7dmFsdWU6IFwidXBjX2VcIiwgd3JpdGVhYmxlOiBmYWxzZX1cbn07XG5cblVQQ0VSZWFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFQU5SZWFkZXIucHJvdG90eXBlLCBwcm9wZXJ0aWVzKTtcblVQQ0VSZWFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVVBDRVJlYWRlcjtcblxuVVBDRVJlYWRlci5wcm90b3R5cGUuX2RlY29kZVBheWxvYWQgPSBmdW5jdGlvbihjb2RlLCByZXN1bHQsIGRlY29kZWRDb2Rlcykge1xuICAgIHZhciBpLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgY29kZUZyZXF1ZW5jeSA9IDB4MDtcblxuICAgIGZvciAoIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgIGNvZGUgPSBzZWxmLl9kZWNvZGVDb2RlKGNvZGUuZW5kKTtcbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZS5jb2RlID49IHNlbGYuQ09ERV9HX1NUQVJUKSB7XG4gICAgICAgICAgICBjb2RlLmNvZGUgPSBjb2RlLmNvZGUgLSBzZWxmLkNPREVfR19TVEFSVDtcbiAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gMSA8PCAoNSAtIGkpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKGNvZGUuY29kZSk7XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgIH1cbiAgICBpZiAoIXNlbGYuX2RldGVybWluZVBhcml0eShjb2RlRnJlcXVlbmN5LCByZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjb2RlO1xufTtcblxuVVBDRVJlYWRlci5wcm90b3R5cGUuX2RldGVybWluZVBhcml0eSA9IGZ1bmN0aW9uKGNvZGVGcmVxdWVuY3ksIHJlc3VsdCkge1xuICAgIHZhciBpLFxuICAgICAgICBuclN5c3RlbTtcblxuICAgIGZvciAobnJTeXN0ZW0gPSAwOyBuclN5c3RlbSA8IHRoaXMuQ09ERV9GUkVRVUVOQ1kubGVuZ3RoOyBuclN5c3RlbSsrKXtcbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCB0aGlzLkNPREVfRlJFUVVFTkNZW25yU3lzdGVtXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvZGVGcmVxdWVuY3kgPT09IHRoaXMuQ09ERV9GUkVRVUVOQ1lbbnJTeXN0ZW1dW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnVuc2hpZnQobnJTeXN0ZW0pO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblVQQ0VSZWFkZXIucHJvdG90eXBlLl9jb252ZXJ0VG9VUENBID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgdmFyIHVwY2EgPSBbcmVzdWx0WzBdXSxcbiAgICAgICAgbGFzdERpZ2l0ID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAyXTtcblxuICAgIGlmIChsYXN0RGlnaXQgPD0gMikge1xuICAgICAgICB1cGNhID0gdXBjYS5jb25jYXQocmVzdWx0LnNsaWNlKDEsIDMpKVxuICAgICAgICAgICAgLmNvbmNhdChbbGFzdERpZ2l0LCAwLCAwLCAwLCAwXSlcbiAgICAgICAgICAgIC5jb25jYXQocmVzdWx0LnNsaWNlKDMsIDYpKTtcbiAgICB9IGVsc2UgaWYgKGxhc3REaWdpdCA9PT0gMykge1xuICAgICAgICB1cGNhID0gdXBjYS5jb25jYXQocmVzdWx0LnNsaWNlKDEsIDQpKVxuICAgICAgICAgICAgLmNvbmNhdChbMCwgMCwgMCwgMCwgMF0pXG4gICAgICAgICAgICAuY29uY2F0KHJlc3VsdC5zbGljZSg0LCA2KSk7XG4gICAgfSBlbHNlIGlmIChsYXN0RGlnaXQgPT09IDQpIHtcbiAgICAgICAgdXBjYSA9IHVwY2EuY29uY2F0KHJlc3VsdC5zbGljZSgxLCA1KSlcbiAgICAgICAgICAgIC5jb25jYXQoWzAsIDAsIDAsIDAsIDAsIHJlc3VsdFs1XV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHVwY2EgPSB1cGNhLmNvbmNhdChyZXN1bHQuc2xpY2UoMSwgNikpXG4gICAgICAgICAgICAuY29uY2F0KFswLCAwLCAwLCAwLCBsYXN0RGlnaXRdKTtcbiAgICB9XG5cbiAgICB1cGNhLnB1c2gocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSk7XG4gICAgcmV0dXJuIHVwY2E7XG59O1xuXG5VUENFUmVhZGVyLnByb3RvdHlwZS5fY2hlY2tzdW0gPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICByZXR1cm4gRUFOUmVhZGVyLnByb3RvdHlwZS5fY2hlY2tzdW0uY2FsbCh0aGlzLCB0aGlzLl9jb252ZXJ0VG9VUENBKHJlc3VsdCkpO1xufTtcblxuVVBDRVJlYWRlci5wcm90b3R5cGUuX2ZpbmRFbmQgPSBmdW5jdGlvbihvZmZzZXQsIGlzV2hpdGUpIHtcbiAgICBpc1doaXRlID0gdHJ1ZTtcbiAgICByZXR1cm4gRUFOUmVhZGVyLnByb3RvdHlwZS5fZmluZEVuZC5jYWxsKHRoaXMsIG9mZnNldCwgaXNXaGl0ZSk7XG59O1xuXG5VUENFUmVhZGVyLnByb3RvdHlwZS5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlID0gZnVuY3Rpb24oZW5kSW5mbykge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kO1xuXG4gICAgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyKTtcbiAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgc2VsZi5fcm93Lmxlbmd0aCkge1xuICAgICAgICBpZiAoc2VsZi5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBVUENFUmVhZGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlYWRlci91cGNfZV9yZWFkZXIuanMiLCJpbXBvcnQgRUFOUmVhZGVyIGZyb20gJy4vZWFuX3JlYWRlcic7XG5cbmZ1bmN0aW9uIFVQQ1JlYWRlcihvcHRzLCBzdXBwbGVtZW50cykge1xuICAgIEVBTlJlYWRlci5jYWxsKHRoaXMsIG9wdHMsIHN1cHBsZW1lbnRzKTtcbn1cblxudmFyIHByb3BlcnRpZXMgPSB7XG4gICAgRk9STUFUOiB7dmFsdWU6IFwidXBjX2FcIiwgd3JpdGVhYmxlOiBmYWxzZX1cbn07XG5cblVQQ1JlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVBTlJlYWRlci5wcm90b3R5cGUsIHByb3BlcnRpZXMpO1xuVVBDUmVhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVQQ1JlYWRlcjtcblxuVVBDUmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3VsdCA9IEVBTlJlYWRlci5wcm90b3R5cGUuX2RlY29kZS5jYWxsKHRoaXMpO1xuXG4gICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuY29kZSAmJiByZXN1bHQuY29kZS5sZW5ndGggPT09IDEzICYmIHJlc3VsdC5jb2RlLmNoYXJBdCgwKSA9PT0gXCIwXCIpIHtcbiAgICAgICAgcmVzdWx0LmNvZGUgPSByZXN1bHQuY29kZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVVBDUmVhZGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlYWRlci91cGNfcmVhZGVyLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBjb3B5XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDIgdG8gYW5vdGhlclxuICpcbiAqIEBhbGlhcyBtYXQyLmNvcHlcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXVxuICBvdXRbMV0gPSBhWzFdXG4gIG91dFsyXSA9IGFbMl1cbiAgb3V0WzNdID0gYVszXVxuICByZXR1cm4gb3V0XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZ2wtbWF0Mi9jb3B5LmpzXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0MlxuICpcbiAqIEBhbGlhcyBtYXQyLmNyZWF0ZVxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSg0KVxuICBvdXRbMF0gPSAxXG4gIG91dFsxXSA9IDBcbiAgb3V0WzJdID0gMFxuICBvdXRbM10gPSAxXG4gIHJldHVybiBvdXRcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9nbC1tYXQyL2NyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBpbnZlcnRcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0MlxuICpcbiAqIEBhbGlhcyBtYXQyLmludmVydFxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMCA9IGFbMF1cbiAgdmFyIGExID0gYVsxXVxuICB2YXIgYTIgPSBhWzJdXG4gIHZhciBhMyA9IGFbM11cbiAgdmFyIGRldCA9IGEwICogYTMgLSBhMiAqIGExXG5cbiAgaWYgKCFkZXQpIHJldHVybiBudWxsXG4gIGRldCA9IDEuMCAvIGRldFxuXG4gIG91dFswXSA9ICBhMyAqIGRldFxuICBvdXRbMV0gPSAtYTEgKiBkZXRcbiAgb3V0WzJdID0gLWEyICogZGV0XG4gIG91dFszXSA9ICBhMCAqIGRldFxuXG4gIHJldHVybiBvdXRcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9nbC1tYXQyL2ludmVydC5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBzY2FsZVxuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzIgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlxuICAgIG91dFsxXSA9IGFbMV0gKiBiXG4gICAgcmV0dXJuIG91dFxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9nbC12ZWMyL3NjYWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybU1hdDJcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQyfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQyKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV1cbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeVxuICAgIHJldHVybiBvdXRcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZ2wtdmVjMi90cmFuc2Zvcm1NYXQyLmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gY2xvbmUoYSkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDMpXG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGFbMV1cbiAgICBvdXRbMl0gPSBhWzJdXG4gICAgcmV0dXJuIG91dFxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9nbC12ZWMzL2Nsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaGFzaENsZWFyID0gcmVxdWlyZSgnLi9faGFzaENsZWFyJyksXG4gICAgaGFzaERlbGV0ZSA9IHJlcXVpcmUoJy4vX2hhc2hEZWxldGUnKSxcbiAgICBoYXNoR2V0ID0gcmVxdWlyZSgnLi9faGFzaEdldCcpLFxuICAgIGhhc2hIYXMgPSByZXF1aXJlKCcuL19oYXNoSGFzJyksXG4gICAgaGFzaFNldCA9IHJlcXVpcmUoJy4vX2hhc2hTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX0hhc2guanNcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBzdGFja0NsZWFyID0gcmVxdWlyZSgnLi9fc3RhY2tDbGVhcicpLFxuICAgIHN0YWNrRGVsZXRlID0gcmVxdWlyZSgnLi9fc3RhY2tEZWxldGUnKSxcbiAgICBzdGFja0dldCA9IHJlcXVpcmUoJy4vX3N0YWNrR2V0JyksXG4gICAgc3RhY2tIYXMgPSByZXF1aXJlKCcuL19zdGFja0hhcycpLFxuICAgIHN0YWNrU2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fU3RhY2suanNcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVpbnQ4QXJyYXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19VaW50OEFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19hcHBseS5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheU1hcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2FycmF5TWFwLmpzXG4vLyBtb2R1bGUgaWQgPSA5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYXJyYXlQdXNoLmpzXG4vLyBtb2R1bGUgaWQgPSA5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNyZWF0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VDcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0ZsYXR0ZW5hYmxlID0gcmVxdWlyZSgnLi9faXNGbGF0dGVuYWJsZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmxhdHRlbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VGbGF0dGVuLmpzXG4vLyBtb2R1bGUgaWQgPSA5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY3JlYXRlQmFzZUZvciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUJhc2VGb3InKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3I7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19iYXNlRm9yLmpzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYmFzZUdldC5qc1xuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhc0luO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYmFzZUhhc0luLmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0FyZ3VtZW50cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qc1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc01hc2tlZCA9IHJlcXVpcmUoJy4vX2lzTWFza2VkJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hdGl2ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qc1xuLy8gbW9kdWxlIGlkID0gOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1R5cGVkQXJyYXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXNJbiA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzSW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19iYXNlS2V5c0luLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBhc3NpZ25NZXJnZVZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduTWVyZ2VWYWx1ZScpLFxuICAgIGJhc2VGb3IgPSByZXF1aXJlKCcuL19iYXNlRm9yJyksXG4gICAgYmFzZU1lcmdlRGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VNZXJnZURlZXAnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpLFxuICAgIHNhZmVHZXQgPSByZXF1aXJlKCcuL19zYWZlR2V0Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgID8gY3VzdG9taXplcihzYWZlR2V0KG9iamVjdCwga2V5KSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICB9XG4gICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9LCBrZXlzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNZXJnZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VNZXJnZS5qc1xuLy8gbW9kdWxlIGlkID0gMTAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhc3NpZ25NZXJnZVZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduTWVyZ2VWYWx1ZScpLFxuICAgIGNsb25lQnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVCdWZmZXInKSxcbiAgICBjbG9uZVR5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19jbG9uZVR5cGVkQXJyYXknKSxcbiAgICBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKSxcbiAgICBpbml0Q2xvbmVPYmplY3QgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNBcnJheUxpa2VPYmplY3QgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlT2JqZWN0JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL2lzUGxhaW5PYmplY3QnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpLFxuICAgIHNhZmVHZXQgPSByZXF1aXJlKCcuL19zYWZlR2V0JyksXG4gICAgdG9QbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vdG9QbGFpbk9iamVjdCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXG4gICAgICBzcmNWYWx1ZSA9IHNhZmVHZXQoc291cmNlLCBrZXkpLFxuICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgaWYgKHN0YWNrZWQpIHtcbiAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICA6IHVuZGVmaW5lZDtcblxuICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gIGlmIChpc0NvbW1vbikge1xuICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxuICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XG4gICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IGlzRnVuY3Rpb24ob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNDb21tb24pIHtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gIH1cbiAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNZXJnZURlZXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19iYXNlTWVyZ2VEZWVwLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VQaWNrQnkgPSByZXF1aXJlKCcuL19iYXNlUGlja0J5JyksXG4gICAgaGFzSW4gPSByZXF1aXJlKCcuL2hhc0luJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucGlja2Agd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gKiBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVBpY2sob2JqZWN0LCBwYXRocykge1xuICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgIHJldHVybiBoYXNJbihvYmplY3QsIHBhdGgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUGljaztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VQaWNrLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0JyksXG4gICAgYmFzZVNldCA9IHJlcXVpcmUoJy4vX2Jhc2VTZXQnKSxcbiAgICBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICByZXN1bHQgPSB7fTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBwYXRoID0gcGF0aHNbaW5kZXhdLFxuICAgICAgICB2YWx1ZSA9IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcblxuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIHBhdGgpKSB7XG4gICAgICBiYXNlU2V0KHJlc3VsdCwgY2FzdFBhdGgocGF0aCwgb2JqZWN0KSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQaWNrQnk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19iYXNlUGlja0J5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIG92ZXJSZXN0ID0gcmVxdWlyZSgnLi9fb3ZlclJlc3QnKSxcbiAgICBzZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFRvU3RyaW5nJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSZXN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYmFzZVJlc3QuanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcbiAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSksXG4gICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcbiAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaXNPYmplY3Qob2JqVmFsdWUpXG4gICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuICAgICAgfVxuICAgIH1cbiAgICBhc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VTZXQuanNcbi8vIG1vZHVsZSBpZCA9IDEwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29uc3RhbnQgPSByZXF1aXJlKCcuL2NvbnN0YW50JyksXG4gICAgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgJ3ZhbHVlJzogY29uc3RhbnQoc3RyaW5nKSxcbiAgICAnd3JpdGFibGUnOiB0cnVlXG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2V0VG9TdHJpbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19iYXNlU2V0VG9TdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VUaW1lcy5qc1xuLy8gbW9kdWxlIGlkID0gMTA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1N0cmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VUb1N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19iYXNlVW5hcnkuanNcbi8vIG1vZHVsZSBpZCA9IDExMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQXJyYXlCdWZmZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19jbG9uZUFycmF5QnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVCdWZmZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19jbG9uZUJ1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gMTEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lVHlwZWRBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Nsb25lVHlwZWRBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2NvcHlBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyk7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlPYmplY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19jb3B5T2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZUpzRGF0YTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2NvcmVKc0RhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBc3NpZ25lcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2NyZWF0ZUFzc2lnbmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUZvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2NyZWF0ZUJhc2VGb3IuanNcbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZmxhdHRlbiA9IHJlcXVpcmUoJy4vZmxhdHRlbicpLFxuICAgIG92ZXJSZXN0ID0gcmVxdWlyZSgnLi9fb3ZlclJlc3QnKSxcbiAgICBzZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFRvU3RyaW5nJyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggZmxhdHRlbnMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZmxhdFJlc3QoZnVuYykge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgdW5kZWZpbmVkLCBmbGF0dGVuKSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0UmVzdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2ZsYXRSZXN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UmF3VGFnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fZ2V0UmF3VGFnLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmFsdWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19nZXRWYWx1ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNQYXRoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9faGFzUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gMTIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaENsZWFyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9faGFzaENsZWFyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoRGVsZXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9faGFzaERlbGV0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19oYXNoR2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEhhcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2hhc2hIYXMuanNcbi8vIG1vZHVsZSBpZCA9IDEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hTZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19oYXNoU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lT2JqZWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9faW5pdENsb25lT2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGbGF0dGVuYWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2lzRmxhdHRlbmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDEyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSXRlcmF0ZWVDYWxsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9faXNJdGVyYXRlZUNhbGwuanNcbi8vIG1vZHVsZSBpZCA9IDEzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19pc0tleS5qc1xuLy8gbW9kdWxlIGlkID0gMTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19pc0tleWFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDEzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29yZUpzRGF0YSA9IHJlcXVpcmUoJy4vX2NvcmVKc0RhdGEnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2lzTWFza2VkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVEZWxldGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanNcbi8vIG1vZHVsZSBpZCA9IDEzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fbGlzdENhY2hlR2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVIYXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19saXN0Q2FjaGVIYXMuanNcbi8vIG1vZHVsZSBpZCA9IDEzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVTZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19saXN0Q2FjaGVTZXQuanNcbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSGFzaCA9IHJlcXVpcmUoJy4vX0hhc2gnKSxcbiAgICBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlQ2xlYXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19tYXBDYWNoZUNsZWFyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanNcbi8vIG1vZHVsZSBpZCA9IDE0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlR2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fbWFwQ2FjaGVHZXQuanNcbi8vIG1vZHVsZSBpZCA9IDE0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX21hcENhY2hlSGFzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX21hcENhY2hlU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1lbW9pemUgPSByZXF1aXJlKCcuL21lbW9pemUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemVDYXBwZWQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19tZW1vaXplQ2FwcGVkLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5c0luO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fbmF0aXZlS2V5c0luLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICBpZiAodHlwZXMpIHtcbiAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVV0aWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19ub2RlVXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDE0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fb3ZlckFyZy5qc1xuLy8gbW9kdWxlIGlkID0gMTQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbnZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgSE9UX1NQQU4gPSAxNjtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gKiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG9ydE91dDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX3Nob3J0T3V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrQ2xlYXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19zdGFja0NsZWFyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrRGVsZXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fc3RhY2tEZWxldGUuanNcbi8vIG1vZHVsZSBpZCA9IDE1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tHZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19zdGFja0dldC5qc1xuLy8gbW9kdWxlIGlkID0gMTUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19zdGFja0hhcy5qc1xuLy8gbW9kdWxlIGlkID0gMTUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrU2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fc3RhY2tTZXQuanNcbi8vIG1vZHVsZSBpZCA9IDE1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWVtb2l6ZUNhcHBlZCA9IHJlcXVpcmUoJy4vX21lbW9pemVDYXBwZWQnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ1RvUGF0aDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX3N0cmluZ1RvUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX3RvU291cmNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc3RhbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL2NvbnN0YW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKTtcblxuLyoqXG4gKiBGbGF0dGVucyBgYXJyYXlgIGEgc2luZ2xlIGxldmVsIGRlZXAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5mbGF0dGVuKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIDEpIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvZmxhdHRlbi5qc1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlSGFzSW4gPSByZXF1aXJlKCcuL19iYXNlSGFzSW4nKSxcbiAgICBoYXNQYXRoID0gcmVxdWlyZSgnLi9faGFzUGF0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzSW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL2hhc0luLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZU9iamVjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvaXNBcnJheUxpa2VPYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9tZW1vaXplLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VQaWNrID0gcmVxdWlyZSgnLi9fYmFzZVBpY2snKSxcbiAgICBmbGF0UmVzdCA9IHJlcXVpcmUoJy4vX2ZsYXRSZXN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAqL1xudmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2sob2JqZWN0LCBwYXRocyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwaWNrO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9waWNrLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJGYWxzZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvc3R1YkZhbHNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nXG4gKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gKi9cbmZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvUGxhaW5PYmplY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL3RvUGxhaW5PYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVRvU3RyaW5nJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvdG9TdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDE2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9